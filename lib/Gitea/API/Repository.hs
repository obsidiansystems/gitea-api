{-
   Gitea API

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API API version: 1.23.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Repository
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Repository where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Repository

-- *** acceptRepoTransfer

-- | @POST \/repos\/{owner}\/{repo}\/transfer\/accept@
-- 
-- Accept a repo transfer
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
acceptRepoTransfer
  :: Owner -- ^ "owner" -  owner of the repo to transfer
  -> Repo -- ^ "repo" -  name of the repo to transfer
  -> GiteaRequest AcceptRepoTransfer MimeNoContent Repository MimeJSON
acceptRepoTransfer (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/transfer/accept"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AcceptRepoTransfer  
-- | @application/json@
instance Produces AcceptRepoTransfer MimeJSON


-- *** createCurrentUserRepo

-- | @POST \/user\/repos@
-- 
-- Create a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createCurrentUserRepo
  :: (Consumes CreateCurrentUserRepo MimeJSON)
  => GiteaRequest CreateCurrentUserRepo MimeJSON Repository MimeJSON
createCurrentUserRepo =
  _mkRequest "POST" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateCurrentUserRepo 
instance HasBodyParam CreateCurrentUserRepo CreateRepoOption 

-- | @application/json@
instance Consumes CreateCurrentUserRepo MimeJSON

-- | @application/json@
instance Produces CreateCurrentUserRepo MimeJSON


-- *** createFork

-- | @POST \/repos\/{owner}\/{repo}\/forks@
-- 
-- Fork a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createFork
  :: (Consumes CreateFork contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to fork
  -> Repo -- ^ "repo" -  name of the repo to fork
  -> GiteaRequest CreateFork contentType Repository MimeJSON
createFork _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateFork 
instance HasBodyParam CreateFork CreateForkOption 

-- | @application/json@
instance Consumes CreateFork MimeJSON
-- | @text/plain@
instance Consumes CreateFork MimePlainText

-- | @application/json@
instance Produces CreateFork MimeJSON


-- *** createRepoVariable

-- | @POST \/repos\/{owner}\/{repo}\/actions\/variables\/{variablename}@
-- 
-- Create a repo-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createRepoVariable
  :: (Consumes CreateRepoVariable contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  name of the owner
  -> Repo -- ^ "repo" -  name of the repository
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest CreateRepoVariable contentType NoContent MimeNoContent
createRepoVariable _ (Owner owner) (Repo repo) (Variablename variablename) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateRepoVariable 
instance HasBodyParam CreateRepoVariable CreateVariableOption 

-- | @application/json@
instance Consumes CreateRepoVariable MimeJSON
-- | @text/plain@
instance Consumes CreateRepoVariable MimePlainText

instance Produces CreateRepoVariable MimeNoContent


-- *** deleteRepoSecret

-- | @DELETE \/repos\/{owner}\/{repo}\/actions\/secrets\/{secretname}@
-- 
-- Delete a secret in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
deleteRepoSecret
  :: Owner -- ^ "owner" -  owner of the repository
  -> Repo -- ^ "repo" -  name of the repository
  -> Secretname -- ^ "secretname" -  name of the secret
  -> GiteaRequest DeleteRepoSecret MimeNoContent NoContent MimeNoContent
deleteRepoSecret (Owner owner) (Repo repo) (Secretname secretname) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/actions/secrets/",toPath secretname]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data DeleteRepoSecret  
instance Produces DeleteRepoSecret MimeNoContent


-- *** deleteRepoVariable

-- | @DELETE \/repos\/{owner}\/{repo}\/actions\/variables\/{variablename}@
-- 
-- Delete a repo-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
deleteRepoVariable
  :: Owner -- ^ "owner" -  name of the owner
  -> Repo -- ^ "repo" -  name of the repository
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest DeleteRepoVariable MimeNoContent ActionVariable MimeJSON
deleteRepoVariable (Owner owner) (Repo repo) (Variablename variablename) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data DeleteRepoVariable  
-- | @application/json@
instance Produces DeleteRepoVariable MimeJSON


-- *** generateRepo

-- | @POST \/repos\/{template_owner}\/{template_repo}\/generate@
-- 
-- Create a repository using a template
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
generateRepo
  :: (Consumes GenerateRepo MimeJSON)
  => TemplateOwner -- ^ "templateOwner" -  name of the template repository owner
  -> TemplateRepo -- ^ "templateRepo" -  name of the template repository
  -> GiteaRequest GenerateRepo MimeJSON Repository MimeJSON
generateRepo (TemplateOwner templateOwner) (TemplateRepo templateRepo) =
  _mkRequest "POST" ["/repos/",toPath templateOwner,"/",toPath templateRepo,"/generate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GenerateRepo 
instance HasBodyParam GenerateRepo GenerateRepoOption 

-- | @application/json@
instance Consumes GenerateRepo MimeJSON

-- | @application/json@
instance Produces GenerateRepo MimeJSON


-- *** getAnnotatedTag

-- | @GET \/repos\/{owner}\/{repo}\/git\/tags\/{sha}@
-- 
-- Gets the tag object of an annotated tag (not lightweight tags)
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getAnnotatedTag
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
  -> GiteaRequest GetAnnotatedTag MimeNoContent AnnotatedTag MimeJSON
getAnnotatedTag (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/tags/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetAnnotatedTag  
-- | @application/json@
instance Produces GetAnnotatedTag MimeJSON


-- *** getBlob

-- | @GET \/repos\/{owner}\/{repo}\/git\/blobs\/{sha}@
-- 
-- Gets the blob of a repository.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getBlob
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetBlob MimeNoContent GitBlobResponse MimeJSON
getBlob (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/blobs/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetBlob  
-- | @application/json@
instance Produces GetBlob MimeJSON


-- *** getRepoVariable

-- | @GET \/repos\/{owner}\/{repo}\/actions\/variables\/{variablename}@
-- 
-- Get a repo-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getRepoVariable
  :: Owner -- ^ "owner" -  name of the owner
  -> Repo -- ^ "repo" -  name of the repository
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest GetRepoVariable MimeNoContent ActionVariable MimeJSON
getRepoVariable (Owner owner) (Repo repo) (Variablename variablename) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetRepoVariable  
-- | @application/json@
instance Produces GetRepoVariable MimeJSON


-- *** getRepoVariablesList

-- | @GET \/repos\/{owner}\/{repo}\/actions\/variables@
-- 
-- Get repo-level variables list
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getRepoVariablesList
  :: Owner -- ^ "owner" -  name of the owner
  -> Repo -- ^ "repo" -  name of the repository
  -> GiteaRequest GetRepoVariablesList MimeNoContent [ActionVariable] MimeJSON
getRepoVariablesList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/actions/variables"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetRepoVariablesList  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam GetRepoVariablesList Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam GetRepoVariablesList Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces GetRepoVariablesList MimeJSON


-- *** getTree

-- | @GET \/repos\/{owner}\/{repo}\/git\/trees\/{sha}@
-- 
-- Gets the tree of a repository.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getTree
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetTree MimeNoContent GitTreeResponse MimeJSON
getTree (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/trees/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetTree  

-- | /Optional Param/ "recursive" - show all directories and files
instance HasOptionalParam GetTree Recursive where
  applyOptionalParam req (Recursive xs) =
    req `addQuery` toQuery ("recursive", Just xs)

-- | /Optional Param/ "page" - page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
instance HasOptionalParam GetTree Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "per_page" - number of items per page
instance HasOptionalParam GetTree PerPage where
  applyOptionalParam req (PerPage xs) =
    req `addQuery` toQuery ("per_page", Just xs)
-- | @application/json@
instance Produces GetTree MimeJSON


-- *** listActionTasks

-- | @GET \/repos\/{owner}\/{repo}\/actions\/tasks@
-- 
-- List a repository's action tasks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
listActionTasks
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest ListActionTasks MimeNoContent ActionTaskResponse MimeJSON
listActionTasks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/actions/tasks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data ListActionTasks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam ListActionTasks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results, default maximum page size is 50
instance HasOptionalParam ListActionTasks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListActionTasks MimeJSON


-- *** listForks

-- | @GET \/repos\/{owner}\/{repo}\/forks@
-- 
-- List a repository's forks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
listForks
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest ListForks MimeNoContent [Repository] MimeJSON
listForks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data ListForks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam ListForks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam ListForks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListForks MimeJSON


-- *** rejectRepoTransfer

-- | @POST \/repos\/{owner}\/{repo}\/transfer\/reject@
-- 
-- Reject a repo transfer
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
rejectRepoTransfer
  :: Owner -- ^ "owner" -  owner of the repo to transfer
  -> Repo -- ^ "repo" -  name of the repo to transfer
  -> GiteaRequest RejectRepoTransfer MimeNoContent Repository MimeJSON
rejectRepoTransfer (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/transfer/reject"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RejectRepoTransfer  
-- | @application/json@
instance Produces RejectRepoTransfer MimeJSON


-- *** repoAddCollaborator

-- | @PUT \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Add or Update a collaborator to a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddCollaborator
  :: (Consumes RepoAddCollaborator contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to add
  -> GiteaRequest RepoAddCollaborator contentType NoContent MimeNoContent
repoAddCollaborator _ (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddCollaborator 
instance HasBodyParam RepoAddCollaborator AddCollaboratorOption 

-- | @application/json@
instance Consumes RepoAddCollaborator MimeJSON
-- | @text/plain@
instance Consumes RepoAddCollaborator MimePlainText

instance Produces RepoAddCollaborator MimeNoContent


-- *** repoAddPushMirror

-- | @POST \/repos\/{owner}\/{repo}\/push_mirrors@
-- 
-- add a push mirror to the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddPushMirror
  :: (Consumes RepoAddPushMirror MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoAddPushMirror MimeJSON PushMirror MimeJSON
repoAddPushMirror (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/push_mirrors"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddPushMirror 
instance HasBodyParam RepoAddPushMirror CreatePushMirrorOption 

-- | @application/json@
instance Consumes RepoAddPushMirror MimeJSON

-- | @application/json@
instance Produces RepoAddPushMirror MimeJSON


-- *** repoAddTeam

-- | @PUT \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Add a team to a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddTeam
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoAddTeam MimeNoContent NoContent MimeNoContent
repoAddTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddTeam  
instance Produces RepoAddTeam MimeNoContent


-- *** repoAddTopic

-- | @PUT \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Add a topic to a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddTopic
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to add
  -> GiteaRequest RepoAddTopic MimeNoContent NoContent MimeNoContent
repoAddTopic (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddTopic  
instance Produces RepoAddTopic MimeNoContent


-- *** repoApplyDiffPatch

-- | @POST \/repos\/{owner}\/{repo}\/diffpatch@
-- 
-- Apply diff patch to repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoApplyDiffPatch
  :: (Consumes RepoApplyDiffPatch MimeJSON, MimeRender MimeJSON UpdateFileOptions)
  => UpdateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoApplyDiffPatch MimeJSON FileResponse MimeJSON
repoApplyDiffPatch body (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/diffpatch"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoApplyDiffPatch 
instance HasBodyParam RepoApplyDiffPatch UpdateFileOptions 

-- | @application/json@
instance Consumes RepoApplyDiffPatch MimeJSON

-- | @application/json@
instance Produces RepoApplyDiffPatch MimeJSON


-- *** repoCancelScheduledAutoMerge

-- | @DELETE \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Cancel the scheduled auto merge for the given pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCancelScheduledAutoMerge
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to merge
  -> GiteaRequest RepoCancelScheduledAutoMerge MimeNoContent NoContent MimeNoContent
repoCancelScheduledAutoMerge (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCancelScheduledAutoMerge  
instance Produces RepoCancelScheduledAutoMerge MimeNoContent


-- *** repoChangeFiles

-- | @POST \/repos\/{owner}\/{repo}\/contents@
-- 
-- Modify multiple files in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoChangeFiles
  :: (Consumes RepoChangeFiles MimeJSON, MimeRender MimeJSON ChangeFilesOptions)
  => ChangeFilesOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoChangeFiles MimeJSON FilesResponse MimeJSON
repoChangeFiles body (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/contents"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoChangeFiles 
instance HasBodyParam RepoChangeFiles ChangeFilesOptions 

-- | @application/json@
instance Consumes RepoChangeFiles MimeJSON

-- | @application/json@
instance Produces RepoChangeFiles MimeJSON


-- *** repoCheckCollaborator

-- | @GET \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Check if a user is a collaborator of a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCheckCollaborator
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator
  -> GiteaRequest RepoCheckCollaborator MimeNoContent NoContent MimeNoContent
repoCheckCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCheckCollaborator  
instance Produces RepoCheckCollaborator MimeNoContent


-- *** repoCheckTeam

-- | @GET \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Check if a team is assigned to a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCheckTeam
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoCheckTeam MimeNoContent Team MimeJSON
repoCheckTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCheckTeam  
-- | @application/json@
instance Produces RepoCheckTeam MimeJSON


-- *** repoCompareDiff

-- | @GET \/repos\/{owner}\/{repo}\/compare\/{basehead}@
-- 
-- Get commit comparison information
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCompareDiff
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Basehead -- ^ "basehead" -  compare two branches or commits
  -> GiteaRequest RepoCompareDiff MimeNoContent Compare MimeJSON
repoCompareDiff (Owner owner) (Repo repo) (Basehead basehead) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/compare/",toPath basehead]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCompareDiff  
-- | @application/json@
instance Produces RepoCompareDiff MimeJSON


-- *** repoCreateBranch

-- | @POST \/repos\/{owner}\/{repo}\/branches@
-- 
-- Create a branch
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateBranch
  :: (Consumes RepoCreateBranch MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateBranch MimeJSON Branch MimeJSON
repoCreateBranch (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/branches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateBranch 
instance HasBodyParam RepoCreateBranch CreateBranchRepoOption 

-- | @application/json@
instance Consumes RepoCreateBranch MimeJSON

-- | @application/json@
instance Produces RepoCreateBranch MimeJSON


-- *** repoCreateBranchProtection

-- | @POST \/repos\/{owner}\/{repo}\/branch_protections@
-- 
-- Create a branch protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateBranchProtection
  :: (Consumes RepoCreateBranchProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateBranchProtection MimeJSON BranchProtection MimeJSON
repoCreateBranchProtection (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateBranchProtection 
instance HasBodyParam RepoCreateBranchProtection CreateBranchProtectionOption 

-- | @application/json@
instance Consumes RepoCreateBranchProtection MimeJSON

-- | @application/json@
instance Produces RepoCreateBranchProtection MimeJSON


-- *** repoCreateFile

-- | @POST \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Create a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateFile
  :: (Consumes RepoCreateFile MimeJSON, MimeRender MimeJSON CreateFileOptions)
  => CreateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to create
  -> GiteaRequest RepoCreateFile MimeJSON FileResponse MimeJSON
repoCreateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreateFile 
instance HasBodyParam RepoCreateFile CreateFileOptions 

-- | @application/json@
instance Consumes RepoCreateFile MimeJSON

-- | @application/json@
instance Produces RepoCreateFile MimeJSON


-- *** repoCreateHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateHook
  :: (Consumes RepoCreateHook MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateHook MimeJSON Hook MimeJSON
repoCreateHook (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateHook 
instance HasBodyParam RepoCreateHook CreateHookOption 

-- | @application/json@
instance Consumes RepoCreateHook MimeJSON

-- | @application/json@
instance Produces RepoCreateHook MimeJSON


-- *** repoCreateKey

-- | @POST \/repos\/{owner}\/{repo}\/keys@
-- 
-- Add a key to a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateKey
  :: (Consumes RepoCreateKey MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateKey MimeJSON DeployKey MimeJSON
repoCreateKey (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateKey 
instance HasBodyParam RepoCreateKey CreateKeyOption 

-- | @application/json@
instance Consumes RepoCreateKey MimeJSON

-- | @application/json@
instance Produces RepoCreateKey MimeJSON


-- *** repoCreatePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls@
-- 
-- Create a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreatePullRequest
  :: (Consumes RepoCreatePullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreatePullRequest MimeJSON PullRequest MimeJSON
repoCreatePullRequest (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreatePullRequest 
instance HasBodyParam RepoCreatePullRequest CreatePullRequestOption 

-- | @application/json@
instance Consumes RepoCreatePullRequest MimeJSON

-- | @application/json@
instance Produces RepoCreatePullRequest MimeJSON


-- *** repoCreatePullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews@
-- 
-- Create a review to an pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreatePullReview
  :: (Consumes RepoCreatePullReview contentType, MimeRender contentType CreatePullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> CreatePullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoCreatePullReview contentType PullReview MimeJSON
repoCreatePullReview _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreatePullReview 
instance HasBodyParam RepoCreatePullReview CreatePullReviewOptions 

-- | @application/json@
instance Consumes RepoCreatePullReview MimeJSON
-- | @text/plain@
instance Consumes RepoCreatePullReview MimePlainText

-- | @application/json@
instance Produces RepoCreatePullReview MimeJSON


-- *** repoCreatePullReviewRequests

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/requested_reviewers@
-- 
-- create review requests for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreatePullReviewRequests
  :: (Consumes RepoCreatePullReviewRequests contentType, MimeRender contentType PullReviewRequestOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> PullReviewRequestOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoCreatePullReviewRequests contentType [PullReview] MimeJSON
repoCreatePullReviewRequests _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/requested_reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreatePullReviewRequests 
instance HasBodyParam RepoCreatePullReviewRequests PullReviewRequestOptions 

-- | @application/json@
instance Consumes RepoCreatePullReviewRequests MimeJSON
-- | @text/plain@
instance Consumes RepoCreatePullReviewRequests MimePlainText

-- | @application/json@
instance Produces RepoCreatePullReviewRequests MimeJSON


-- *** repoCreateRelease

-- | @POST \/repos\/{owner}\/{repo}\/releases@
-- 
-- Create a release
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateRelease
  :: (Consumes RepoCreateRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateRelease MimeJSON Release MimeJSON
repoCreateRelease (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateRelease 
instance HasBodyParam RepoCreateRelease CreateReleaseOption 

-- | @application/json@
instance Consumes RepoCreateRelease MimeJSON

-- | @application/json@
instance Produces RepoCreateRelease MimeJSON


-- *** repoCreateReleaseAttachment

-- | @POST \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- Create a release attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateReleaseAttachment
  :: (Consumes RepoCreateReleaseAttachment contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoCreateReleaseAttachment contentType Attachment MimeJSON
repoCreateReleaseAttachment _ (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateReleaseAttachment  

-- | /Optional Param/ "attachment" - attachment to upload
instance HasOptionalParam RepoCreateReleaseAttachment Attachment2 where
  applyOptionalParam req (Attachment2 xs) =
    req `_addMultiFormPart` NH.partFileSource "attachment" xs

-- | /Optional Param/ "name" - name of the attachment
instance HasOptionalParam RepoCreateReleaseAttachment Name where
  applyOptionalParam req (Name xs) =
    req `addQuery` toQuery ("name", Just xs)

-- | @application/octet-stream@
instance Consumes RepoCreateReleaseAttachment MimeOctetStream
-- | @multipart/form-data@
instance Consumes RepoCreateReleaseAttachment MimeMultipartFormData

-- | @application/json@
instance Produces RepoCreateReleaseAttachment MimeJSON


-- *** repoCreateStatus

-- | @POST \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Create a commit status
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateStatus
  :: (Consumes RepoCreateStatus contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoCreateStatus contentType CommitStatus MimeJSON
repoCreateStatus _ (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateStatus 
instance HasBodyParam RepoCreateStatus CreateStatusOption 

-- | @application/json@
instance Consumes RepoCreateStatus MimeJSON
-- | @text/plain@
instance Consumes RepoCreateStatus MimePlainText

-- | @application/json@
instance Produces RepoCreateStatus MimeJSON


-- *** repoCreateTag

-- | @POST \/repos\/{owner}\/{repo}\/tags@
-- 
-- Create a new git tag in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateTag
  :: (Consumes RepoCreateTag contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateTag contentType Tag MimeJSON
repoCreateTag _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/tags"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateTag 
instance HasBodyParam RepoCreateTag CreateTagOption 

-- | @application/json@
instance Consumes RepoCreateTag MimeJSON
-- | @text/plain@
instance Consumes RepoCreateTag MimePlainText

-- | @application/json@
instance Produces RepoCreateTag MimeJSON


-- *** repoCreateTagProtection

-- | @POST \/repos\/{owner}\/{repo}\/tag_protections@
-- 
-- Create a tag protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateTagProtection
  :: (Consumes RepoCreateTagProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateTagProtection MimeJSON TagProtection MimeJSON
repoCreateTagProtection (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/tag_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateTagProtection 
instance HasBodyParam RepoCreateTagProtection CreateTagProtectionOption 

-- | @application/json@
instance Consumes RepoCreateTagProtection MimeJSON

-- | @application/json@
instance Produces RepoCreateTagProtection MimeJSON


-- *** repoCreateWikiPage

-- | @POST \/repos\/{owner}\/{repo}\/wiki\/new@
-- 
-- Create a wiki page
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateWikiPage
  :: (Consumes RepoCreateWikiPage MimeJSON)
  => Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateWikiPage MimeJSON WikiPage accept
repoCreateWikiPage  _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/wiki/new"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateWikiPage 
instance HasBodyParam RepoCreateWikiPage CreateWikiPageOptions 

-- | @application/json@
instance Consumes RepoCreateWikiPage MimeJSON

-- | @text/html@
instance Produces RepoCreateWikiPage MimeTextHtml
-- | @application/json@
instance Produces RepoCreateWikiPage MimeJSON


-- *** repoDelete

-- | @DELETE \/repos\/{owner}\/{repo}@
-- 
-- Delete a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDelete
  :: Owner -- ^ "owner" -  owner of the repo to delete
  -> Repo -- ^ "repo" -  name of the repo to delete
  -> GiteaRequest RepoDelete MimeNoContent NoContent MimeNoContent
repoDelete (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDelete  
instance Produces RepoDelete MimeNoContent


-- *** repoDeleteAvatar

-- | @DELETE \/repos\/{owner}\/{repo}\/avatar@
-- 
-- Delete avatar
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteAvatar
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoDeleteAvatar MimeNoContent NoContent MimeNoContent
repoDeleteAvatar (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/avatar"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteAvatar  
instance Produces RepoDeleteAvatar MimeNoContent


-- *** repoDeleteBranch

-- | @DELETE \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Delete a specific branch from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteBranch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  branch to delete
  -> GiteaRequest RepoDeleteBranch MimeNoContent NoContent MimeNoContent
repoDeleteBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteBranch  
instance Produces RepoDeleteBranch MimeNoContent


-- *** repoDeleteBranchProtection

-- | @DELETE \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Delete a specific branch protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteBranchProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoDeleteBranchProtection MimeNoContent NoContent MimeNoContent
repoDeleteBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteBranchProtection  
instance Produces RepoDeleteBranchProtection MimeNoContent


-- *** repoDeleteCollaborator

-- | @DELETE \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Delete a collaborator from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteCollaborator
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to delete
  -> GiteaRequest RepoDeleteCollaborator MimeNoContent NoContent MimeNoContent
repoDeleteCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteCollaborator  
instance Produces RepoDeleteCollaborator MimeNoContent


-- *** repoDeleteFile

-- | @DELETE \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Delete a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteFile
  :: (Consumes RepoDeleteFile MimeJSON, MimeRender MimeJSON DeleteFileOptions)
  => DeleteFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to delete
  -> GiteaRequest RepoDeleteFile MimeJSON FileDeleteResponse MimeJSON
repoDeleteFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDeleteFile 
instance HasBodyParam RepoDeleteFile DeleteFileOptions 

-- | @application/json@
instance Consumes RepoDeleteFile MimeJSON

-- | @application/json@
instance Produces RepoDeleteFile MimeJSON


-- *** repoDeleteGitHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Delete a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteGitHook
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoDeleteGitHook MimeNoContent NoContent MimeNoContent
repoDeleteGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteGitHook  
instance Produces RepoDeleteGitHook MimeNoContent


-- *** repoDeleteHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Delete a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteHook
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest RepoDeleteHook MimeNoContent NoContent MimeNoContent
repoDeleteHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteHook  
instance Produces RepoDeleteHook MimeNoContent


-- *** repoDeleteKey

-- | @DELETE \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Delete a key from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteKey
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to delete
  -> GiteaRequest RepoDeleteKey MimeNoContent NoContent MimeNoContent
repoDeleteKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteKey  
instance Produces RepoDeleteKey MimeNoContent


-- *** repoDeletePullReview

-- | @DELETE \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Delete a specific review from a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeletePullReview
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoDeletePullReview MimeNoContent NoContent MimeNoContent
repoDeletePullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeletePullReview  
instance Produces RepoDeletePullReview MimeNoContent


-- *** repoDeletePullReviewRequests

-- | @DELETE \/repos\/{owner}\/{repo}\/pulls\/{index}\/requested_reviewers@
-- 
-- cancel review requests for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeletePullReviewRequests
  :: (Consumes RepoDeletePullReviewRequests contentType, MimeRender contentType PullReviewRequestOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> PullReviewRequestOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoDeletePullReviewRequests contentType NoContent MimeNoContent
repoDeletePullReviewRequests _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/requested_reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDeletePullReviewRequests 
instance HasBodyParam RepoDeletePullReviewRequests PullReviewRequestOptions 

-- | @application/json@
instance Consumes RepoDeletePullReviewRequests MimeJSON
-- | @text/plain@
instance Consumes RepoDeletePullReviewRequests MimePlainText

instance Produces RepoDeletePullReviewRequests MimeNoContent


-- *** repoDeletePushMirror

-- | @DELETE \/repos\/{owner}\/{repo}\/push_mirrors\/{name}@
-- 
-- deletes a push mirror from a repository by remoteName
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeletePushMirror
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  remote name of the pushMirror
  -> GiteaRequest RepoDeletePushMirror MimeNoContent NoContent MimeNoContent
repoDeletePushMirror (Owner owner) (Repo repo) (Name name) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/push_mirrors/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeletePushMirror  
instance Produces RepoDeletePushMirror MimeNoContent


-- *** repoDeleteRelease

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Delete a release
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteRelease
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to delete
  -> GiteaRequest RepoDeleteRelease MimeNoContent NoContent MimeNoContent
repoDeleteRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteRelease  
instance Produces RepoDeleteRelease MimeNoContent


-- *** repoDeleteReleaseAttachment

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Delete a release attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteReleaseAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to delete
  -> GiteaRequest RepoDeleteReleaseAttachment MimeNoContent NoContent MimeNoContent
repoDeleteReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteReleaseAttachment  
instance Produces RepoDeleteReleaseAttachment MimeNoContent


-- *** repoDeleteReleaseByTag

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/tags\/{tag}@
-- 
-- Delete a release by tag name
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteReleaseByTag
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  tag name of the release to delete
  -> GiteaRequest RepoDeleteReleaseByTag MimeNoContent NoContent MimeNoContent
repoDeleteReleaseByTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteReleaseByTag  
instance Produces RepoDeleteReleaseByTag MimeNoContent


-- *** repoDeleteTag

-- | @DELETE \/repos\/{owner}\/{repo}\/tags\/{tag}@
-- 
-- Delete a repository's tag by name
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteTag
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  name of tag to delete
  -> GiteaRequest RepoDeleteTag MimeNoContent NoContent MimeNoContent
repoDeleteTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTag  
instance Produces RepoDeleteTag MimeNoContent


-- *** repoDeleteTagProtection

-- | @DELETE \/repos\/{owner}\/{repo}\/tag_protections\/{id}@
-- 
-- Delete a specific tag protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteTagProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdInt -- ^ "id" -  id of protected tag
  -> GiteaRequest RepoDeleteTagProtection MimeNoContent NoContent MimeNoContent
repoDeleteTagProtection (Owner owner) (Repo repo) (IdInt id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/tag_protections/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTagProtection  
instance Produces RepoDeleteTagProtection MimeNoContent


-- *** repoDeleteTeam

-- | @DELETE \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Delete a team from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteTeam
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoDeleteTeam MimeNoContent NoContent MimeNoContent
repoDeleteTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTeam  
instance Produces RepoDeleteTeam MimeNoContent


-- *** repoDeleteTopic

-- | @DELETE \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Delete a topic from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteTopic
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to delete
  -> GiteaRequest RepoDeleteTopic MimeNoContent NoContent MimeNoContent
repoDeleteTopic (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTopic  
instance Produces RepoDeleteTopic MimeNoContent


-- *** repoDeleteWikiPage

-- | @DELETE \/repos\/{owner}\/{repo}\/wiki\/page\/{pageName}@
-- 
-- Delete a wiki page
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteWikiPage
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> PageName -- ^ "pageName" -  name of the page
  -> GiteaRequest RepoDeleteWikiPage MimeNoContent NoContent MimeNoContent
repoDeleteWikiPage (Owner owner) (Repo repo) (PageName pageName) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/wiki/page/",toPath pageName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteWikiPage  
instance Produces RepoDeleteWikiPage MimeNoContent


-- *** repoDismissPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/dismissals@
-- 
-- Dismiss a review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDismissPullReview
  :: (Consumes RepoDismissPullReview contentType, MimeRender contentType DismissPullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> DismissPullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoDismissPullReview contentType PullReview MimeJSON
repoDismissPullReview _ body (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/dismissals"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDismissPullReview 
instance HasBodyParam RepoDismissPullReview DismissPullReviewOptions 

-- | @application/json@
instance Consumes RepoDismissPullReview MimeJSON
-- | @text/plain@
instance Consumes RepoDismissPullReview MimePlainText

-- | @application/json@
instance Produces RepoDismissPullReview MimeJSON


-- *** repoDownloadCommitDiffOrPatch

-- | @GET \/repos\/{owner}\/{repo}\/git\/commits\/{sha}.{diffType}@
-- 
-- Get a commit's diff or patch
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDownloadCommitDiffOrPatch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  SHA of the commit to get
  -> DiffType -- ^ "diffType" -  whether the output is diff or patch
  -> GiteaRequest RepoDownloadCommitDiffOrPatch MimeNoContent Text MimePlainText
repoDownloadCommitDiffOrPatch (Owner owner) (Repo repo) (Sha sha) (DiffType diffType) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/commits/",toPath sha,".",toPath diffType]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDownloadCommitDiffOrPatch  
-- | @text/plain@
instance Produces RepoDownloadCommitDiffOrPatch MimePlainText


-- *** repoDownloadPullDiffOrPatch

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}.{diffType}@
-- 
-- Get a pull request diff or patch
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDownloadPullDiffOrPatch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> DiffType -- ^ "diffType" -  whether the output is diff or patch
  -> GiteaRequest RepoDownloadPullDiffOrPatch MimeNoContent Text MimePlainText
repoDownloadPullDiffOrPatch (Owner owner) (Repo repo) (Index index) (DiffType diffType) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,".",toPath diffType]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDownloadPullDiffOrPatch  

-- | /Optional Param/ "binary" - whether to include binary file changes. if true, the diff is applicable with `git apply`
instance HasOptionalParam RepoDownloadPullDiffOrPatch ParamBinary where
  applyOptionalParam req (ParamBinary xs) =
    req `addQuery` toQuery ("binary", Just xs)
-- | @text/plain@
instance Produces RepoDownloadPullDiffOrPatch MimePlainText


-- *** repoEdit

-- | @PATCH \/repos\/{owner}\/{repo}@
-- 
-- Edit a repository's properties. Only fields that are set will be changed.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEdit
  :: (Consumes RepoEdit contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to edit
  -> Repo -- ^ "repo" -  name of the repo to edit
  -> GiteaRequest RepoEdit contentType Repository MimeJSON
repoEdit _ (Owner owner) (Repo repo) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEdit 

-- | /Body Param/ "body" - Properties of a repo that you can edit
instance HasBodyParam RepoEdit EditRepoOption 

-- | @application/json@
instance Consumes RepoEdit MimeJSON
-- | @text/plain@
instance Consumes RepoEdit MimePlainText

-- | @application/json@
instance Produces RepoEdit MimeJSON


-- *** repoEditBranchProtection

-- | @PATCH \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Edit a branch protections for a repository. Only fields that are set will be changed
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditBranchProtection
  :: (Consumes RepoEditBranchProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoEditBranchProtection MimeJSON BranchProtection MimeJSON
repoEditBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditBranchProtection 
instance HasBodyParam RepoEditBranchProtection EditBranchProtectionOption 

-- | @application/json@
instance Consumes RepoEditBranchProtection MimeJSON

-- | @application/json@
instance Produces RepoEditBranchProtection MimeJSON


-- *** repoEditGitHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Edit a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditGitHook
  :: (Consumes RepoEditGitHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoEditGitHook contentType GitHook MimeJSON
repoEditGitHook _ (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditGitHook 
instance HasBodyParam RepoEditGitHook EditGitHookOption 

-- | @application/json@
instance Consumes RepoEditGitHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditGitHook MimePlainText

-- | @application/json@
instance Produces RepoEditGitHook MimeJSON


-- *** repoEditHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Edit a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditHook
  :: (Consumes RepoEditHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  index of the hook
  -> GiteaRequest RepoEditHook contentType Hook MimeJSON
repoEditHook _ (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditHook 
instance HasBodyParam RepoEditHook EditHookOption 

-- | @application/json@
instance Consumes RepoEditHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditHook MimePlainText

-- | @application/json@
instance Produces RepoEditHook MimeJSON


-- *** repoEditPullRequest

-- | @PATCH \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditPullRequest
  :: (Consumes RepoEditPullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to edit
  -> GiteaRequest RepoEditPullRequest MimeJSON PullRequest MimeJSON
repoEditPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditPullRequest 
instance HasBodyParam RepoEditPullRequest EditPullRequestOption 

-- | @application/json@
instance Consumes RepoEditPullRequest MimeJSON

-- | @application/json@
instance Produces RepoEditPullRequest MimeJSON


-- *** repoEditRelease

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Update a release
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditRelease
  :: (Consumes RepoEditRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to edit
  -> GiteaRequest RepoEditRelease MimeJSON Release MimeJSON
repoEditRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditRelease 
instance HasBodyParam RepoEditRelease EditReleaseOption 

-- | @application/json@
instance Consumes RepoEditRelease MimeJSON

-- | @application/json@
instance Produces RepoEditRelease MimeJSON


-- *** repoEditReleaseAttachment

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Edit a release attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditReleaseAttachment
  :: (Consumes RepoEditReleaseAttachment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to edit
  -> GiteaRequest RepoEditReleaseAttachment MimeJSON Attachment MimeJSON
repoEditReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditReleaseAttachment 
instance HasBodyParam RepoEditReleaseAttachment EditAttachmentOptions 

-- | @application/json@
instance Consumes RepoEditReleaseAttachment MimeJSON

-- | @application/json@
instance Produces RepoEditReleaseAttachment MimeJSON


-- *** repoEditTagProtection

-- | @PATCH \/repos\/{owner}\/{repo}\/tag_protections\/{id}@
-- 
-- Edit a tag protections for a repository. Only fields that are set will be changed
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditTagProtection
  :: (Consumes RepoEditTagProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdInt -- ^ "id" -  id of protected tag
  -> GiteaRequest RepoEditTagProtection MimeJSON TagProtection MimeJSON
repoEditTagProtection (Owner owner) (Repo repo) (IdInt id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/tag_protections/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditTagProtection 
instance HasBodyParam RepoEditTagProtection EditTagProtectionOption 

-- | @application/json@
instance Consumes RepoEditTagProtection MimeJSON

-- | @application/json@
instance Produces RepoEditTagProtection MimeJSON


-- *** repoEditWikiPage

-- | @PATCH \/repos\/{owner}\/{repo}\/wiki\/page\/{pageName}@
-- 
-- Edit a wiki page
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditWikiPage
  :: (Consumes RepoEditWikiPage MimeJSON)
  => Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> PageName -- ^ "pageName" -  name of the page
  -> GiteaRequest RepoEditWikiPage MimeJSON WikiPage accept
repoEditWikiPage  _ (Owner owner) (Repo repo) (PageName pageName) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/wiki/page/",toPath pageName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditWikiPage 
instance HasBodyParam RepoEditWikiPage CreateWikiPageOptions 

-- | @application/json@
instance Consumes RepoEditWikiPage MimeJSON

-- | @text/html@
instance Produces RepoEditWikiPage MimeTextHtml
-- | @application/json@
instance Produces RepoEditWikiPage MimeJSON


-- *** repoGet

-- | @GET \/repos\/{owner}\/{repo}@
-- 
-- Get a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGet
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGet MimeNoContent Repository MimeJSON
repoGet (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGet  
-- | @application/json@
instance Produces RepoGet MimeJSON


-- *** repoGetAllCommits

-- | @GET \/repos\/{owner}\/{repo}\/commits@
-- 
-- Get a list of all commits from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetAllCommits
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetAllCommits MimeNoContent [Commit] MimeJSON
repoGetAllCommits (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetAllCommits  

-- | /Optional Param/ "sha" - SHA or branch to start listing commits from (usually 'master')
instance HasOptionalParam RepoGetAllCommits Sha where
  applyOptionalParam req (Sha xs) =
    req `addQuery` toQuery ("sha", Just xs)

-- | /Optional Param/ "path" - filepath of a file/dir
instance HasOptionalParam RepoGetAllCommits Path where
  applyOptionalParam req (Path xs) =
    req `addQuery` toQuery ("path", Just xs)

-- | /Optional Param/ "stat" - include diff stats for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetAllCommits Stat where
  applyOptionalParam req (Stat xs) =
    req `addQuery` toQuery ("stat", Just xs)

-- | /Optional Param/ "verification" - include verification for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetAllCommits Verification where
  applyOptionalParam req (Verification xs) =
    req `addQuery` toQuery ("verification", Just xs)

-- | /Optional Param/ "files" - include a list of affected files for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetAllCommits Files where
  applyOptionalParam req (Files xs) =
    req `addQuery` toQuery ("files", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetAllCommits Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results (ignored if used with 'path')
instance HasOptionalParam RepoGetAllCommits Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "not" - commits that match the given specifier will not be listed.
instance HasOptionalParam RepoGetAllCommits Not where
  applyOptionalParam req (Not xs) =
    req `addQuery` toQuery ("not", Just xs)
-- | @application/json@
instance Produces RepoGetAllCommits MimeJSON


-- *** repoGetArchive

-- | @GET \/repos\/{owner}\/{repo}\/archive\/{archive}@
-- 
-- Get an archive of a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetArchive
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Archive -- ^ "archive" -  the git reference for download with attached archive format (e.g. master.zip)
  -> GiteaRequest RepoGetArchive MimeNoContent NoContent MimeNoContent
repoGetArchive (Owner owner) (Repo repo) (Archive archive) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/archive/",toPath archive]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetArchive  
instance Produces RepoGetArchive MimeNoContent


-- *** repoGetAssignees

-- | @GET \/repos\/{owner}\/{repo}\/assignees@
-- 
-- Return all users that have write access and can be assigned to issues
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetAssignees
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetAssignees MimeNoContent [User] MimeJSON
repoGetAssignees (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/assignees"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetAssignees  
-- | @application/json@
instance Produces RepoGetAssignees MimeJSON


-- *** repoGetBranch

-- | @GET \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Retrieve a specific branch from a repository, including its effective branch protection
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetBranch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  branch to get
  -> GiteaRequest RepoGetBranch MimeNoContent Branch MimeJSON
repoGetBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetBranch  
-- | @application/json@
instance Produces RepoGetBranch MimeJSON


-- *** repoGetBranchProtection

-- | @GET \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Get a specific branch protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetBranchProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoGetBranchProtection MimeNoContent BranchProtection MimeJSON
repoGetBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetBranchProtection  
-- | @application/json@
instance Produces RepoGetBranchProtection MimeJSON


-- *** repoGetByID

-- | @GET \/repositories\/{id}@
-- 
-- Get a repository by id
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetByID
  :: Id -- ^ "id" -  id of the repo to get
  -> GiteaRequest RepoGetByID MimeNoContent Repository MimeJSON
repoGetByID (Id id) =
  _mkRequest "GET" ["/repositories/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetByID  
-- | @application/json@
instance Produces RepoGetByID MimeJSON


-- *** repoGetCombinedStatusByRef

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{ref}\/status@
-- 
-- Get a commit's combined status, by branch/tag/commit reference
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetCombinedStatusByRef
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  name of branch/tag/commit
  -> GiteaRequest RepoGetCombinedStatusByRef MimeNoContent CombinedStatus MimeJSON
repoGetCombinedStatusByRef (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath ref,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetCombinedStatusByRef  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetCombinedStatusByRef Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetCombinedStatusByRef Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetCombinedStatusByRef MimeJSON


-- *** repoGetCommitPullRequest

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{sha}\/pull@
-- 
-- Get the merged pull request of the commit
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetCommitPullRequest
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  SHA of the commit to get
  -> GiteaRequest RepoGetCommitPullRequest MimeNoContent PullRequest MimeJSON
repoGetCommitPullRequest (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath sha,"/pull"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetCommitPullRequest  
-- | @application/json@
instance Produces RepoGetCommitPullRequest MimeJSON


-- *** repoGetContents

-- | @GET \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetContents
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the dir, file, symlink or submodule in the repo
  -> GiteaRequest RepoGetContents MimeNoContent ContentsResponse MimeJSON
repoGetContents (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContents  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repository’s default branch (usually master)
instance HasOptionalParam RepoGetContents Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContents MimeJSON


-- *** repoGetContentsList

-- | @GET \/repos\/{owner}\/{repo}\/contents@
-- 
-- Gets the metadata of all the entries of the root dir
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetContentsList
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetContentsList MimeNoContent [ContentsResponse] MimeJSON
repoGetContentsList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContentsList  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repository’s default branch (usually master)
instance HasOptionalParam RepoGetContentsList Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContentsList MimeJSON


-- *** repoGetEditorConfig

-- | @GET \/repos\/{owner}\/{repo}\/editorconfig\/{filepath}@
-- 
-- Get the EditorConfig definitions of a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetEditorConfig
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  filepath of file to get
  -> GiteaRequest RepoGetEditorConfig MimeNoContent NoContent MimeNoContent
repoGetEditorConfig (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/editorconfig/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetEditorConfig  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repository’s default branch (usually master)
instance HasOptionalParam RepoGetEditorConfig Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
instance Produces RepoGetEditorConfig MimeNoContent


-- *** repoGetGitHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Get a Git hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetGitHook
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetGitHook MimeNoContent GitHook MimeJSON
repoGetGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetGitHook  
-- | @application/json@
instance Produces RepoGetGitHook MimeJSON


-- *** repoGetHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetHook
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetHook MimeNoContent Hook MimeJSON
repoGetHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetHook  
-- | @application/json@
instance Produces RepoGetHook MimeJSON


-- *** repoGetIssueConfig

-- | @GET \/repos\/{owner}\/{repo}\/issue_config@
-- 
-- Returns the issue config for a repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetIssueConfig
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetIssueConfig MimeNoContent IssueConfig MimeJSON
repoGetIssueConfig (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issue_config"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetIssueConfig  
-- | @application/json@
instance Produces RepoGetIssueConfig MimeJSON


-- *** repoGetIssueTemplates

-- | @GET \/repos\/{owner}\/{repo}\/issue_templates@
-- 
-- Get available issue templates for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetIssueTemplates
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetIssueTemplates MimeNoContent [IssueTemplate] MimeJSON
repoGetIssueTemplates (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issue_templates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetIssueTemplates  
-- | @application/json@
instance Produces RepoGetIssueTemplates MimeJSON


-- *** repoGetKey

-- | @GET \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Get a repository's key by id
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetKey
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to get
  -> GiteaRequest RepoGetKey MimeNoContent DeployKey MimeJSON
repoGetKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetKey  
-- | @application/json@
instance Produces RepoGetKey MimeJSON


-- *** repoGetLanguages

-- | @GET \/repos\/{owner}\/{repo}\/languages@
-- 
-- Get languages and number of bytes of code written
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetLanguages
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetLanguages MimeNoContent ((Map.Map String Integer)) MimeJSON
repoGetLanguages (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/languages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetLanguages  
-- | @application/json@
instance Produces RepoGetLanguages MimeJSON


-- *** repoGetLatestRelease

-- | @GET \/repos\/{owner}\/{repo}\/releases\/latest@
-- 
-- Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetLatestRelease
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetLatestRelease MimeNoContent Release MimeJSON
repoGetLatestRelease (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/latest"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetLatestRelease  
-- | @application/json@
instance Produces RepoGetLatestRelease MimeJSON


-- *** repoGetLicenses

-- | @GET \/repos\/{owner}\/{repo}\/licenses@
-- 
-- Get repo licenses
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetLicenses
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetLicenses MimeNoContent [Text] MimeJSON
repoGetLicenses (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/licenses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetLicenses  
-- | @application/json@
instance Produces RepoGetLicenses MimeJSON


-- *** repoGetNote

-- | @GET \/repos\/{owner}\/{repo}\/git\/notes\/{sha}@
-- 
-- Get a note corresponding to a single commit from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetNote
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  a git ref or commit sha
  -> GiteaRequest RepoGetNote MimeNoContent Note MimeJSON
repoGetNote (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/notes/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetNote  

-- | /Optional Param/ "verification" - include verification for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetNote Verification where
  applyOptionalParam req (Verification xs) =
    req `addQuery` toQuery ("verification", Just xs)

-- | /Optional Param/ "files" - include a list of affected files for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetNote Files where
  applyOptionalParam req (Files xs) =
    req `addQuery` toQuery ("files", Just xs)
-- | @application/json@
instance Produces RepoGetNote MimeJSON


-- *** repoGetPullRequest

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Get a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullRequest
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequest MimeNoContent PullRequest MimeJSON
repoGetPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequest  
-- | @application/json@
instance Produces RepoGetPullRequest MimeJSON


-- *** repoGetPullRequestByBaseHead

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{base}\/{head}@
-- 
-- Get a pull request by base and head
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullRequestByBaseHead
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Base -- ^ "base" -  base of the pull request to get
  -> Head -- ^ "head" -  head of the pull request to get
  -> GiteaRequest RepoGetPullRequestByBaseHead MimeNoContent PullRequest MimeJSON
repoGetPullRequestByBaseHead (Owner owner) (Repo repo) (Base base) (Head head) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath base,"/",toPath head]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequestByBaseHead  
-- | @application/json@
instance Produces RepoGetPullRequestByBaseHead MimeJSON


-- *** repoGetPullRequestCommits

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/commits@
-- 
-- Get commits for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullRequestCommits
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequestCommits MimeNoContent [Commit] MimeJSON
repoGetPullRequestCommits (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/commits"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequestCommits  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetPullRequestCommits Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetPullRequestCommits Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "verification" - include verification for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetPullRequestCommits Verification where
  applyOptionalParam req (Verification xs) =
    req `addQuery` toQuery ("verification", Just xs)

-- | /Optional Param/ "files" - include a list of affected files for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetPullRequestCommits Files where
  applyOptionalParam req (Files xs) =
    req `addQuery` toQuery ("files", Just xs)
-- | @application/json@
instance Produces RepoGetPullRequestCommits MimeJSON


-- *** repoGetPullRequestFiles

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/files@
-- 
-- Get changed files for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullRequestFiles
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequestFiles MimeNoContent [ChangedFile] MimeJSON
repoGetPullRequestFiles (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/files"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequestFiles  

-- | /Optional Param/ "skip-to" - skip to given file
instance HasOptionalParam RepoGetPullRequestFiles SkipTo where
  applyOptionalParam req (SkipTo xs) =
    req `addQuery` toQuery ("skip-to", Just xs)

-- | /Optional Param/ "whitespace" - whitespace behavior
instance HasOptionalParam RepoGetPullRequestFiles Whitespace where
  applyOptionalParam req (Whitespace xs) =
    req `addQuery` toQuery ("whitespace", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetPullRequestFiles Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetPullRequestFiles Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetPullRequestFiles MimeJSON


-- *** repoGetPullReview

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Get a specific review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullReview
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoGetPullReview MimeNoContent PullReview MimeJSON
repoGetPullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullReview  
-- | @application/json@
instance Produces RepoGetPullReview MimeJSON


-- *** repoGetPullReviewComments

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/comments@
-- 
-- Get a specific review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullReviewComments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoGetPullReviewComments MimeNoContent [PullReviewComment] MimeJSON
repoGetPullReviewComments (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullReviewComments  
-- | @application/json@
instance Produces RepoGetPullReviewComments MimeJSON


-- *** repoGetPushMirrorByRemoteName

-- | @GET \/repos\/{owner}\/{repo}\/push_mirrors\/{name}@
-- 
-- Get push mirror of the repository by remoteName
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPushMirrorByRemoteName
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  remote name of push mirror
  -> GiteaRequest RepoGetPushMirrorByRemoteName MimeNoContent PushMirror MimeJSON
repoGetPushMirrorByRemoteName (Owner owner) (Repo repo) (Name name) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/push_mirrors/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPushMirrorByRemoteName  
-- | @application/json@
instance Produces RepoGetPushMirrorByRemoteName MimeJSON


-- *** repoGetRawFile

-- | @GET \/repos\/{owner}\/{repo}\/raw\/{filepath}@
-- 
-- Get a file from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRawFile
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to get, it should be \"{ref}/{filepath}\". If there is no ref could be inferred, it will be treated as the default branch
  -> GiteaRequest RepoGetRawFile MimeNoContent FilePath MimeOctetStream
repoGetRawFile (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/raw/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRawFile  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repository’s default branch
instance HasOptionalParam RepoGetRawFile Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
-- | @application/octet-stream@
instance Produces RepoGetRawFile MimeOctetStream


-- *** repoGetRawFileOrLFS

-- | @GET \/repos\/{owner}\/{repo}\/media\/{filepath}@
-- 
-- Get a file or it's LFS object from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRawFileOrLFS
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to get, it should be \"{ref}/{filepath}\". If there is no ref could be inferred, it will be treated as the default branch
  -> GiteaRequest RepoGetRawFileOrLFS MimeNoContent FilePath MimeOctetStream
repoGetRawFileOrLFS (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/media/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRawFileOrLFS  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repository’s default branch
instance HasOptionalParam RepoGetRawFileOrLFS Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
-- | @application/octet-stream@
instance Produces RepoGetRawFileOrLFS MimeOctetStream


-- *** repoGetRelease

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Get a release
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRelease
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to get
  -> GiteaRequest RepoGetRelease MimeNoContent Release MimeJSON
repoGetRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRelease  
-- | @application/json@
instance Produces RepoGetRelease MimeJSON


-- *** repoGetReleaseAttachment

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Get a release attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetReleaseAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to get
  -> GiteaRequest RepoGetReleaseAttachment MimeNoContent Attachment MimeJSON
repoGetReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReleaseAttachment  
-- | @application/json@
instance Produces RepoGetReleaseAttachment MimeJSON


-- *** repoGetReleaseByTag

-- | @GET \/repos\/{owner}\/{repo}\/releases\/tags\/{tag}@
-- 
-- Get a release by tag name
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetReleaseByTag
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  tag name of the release to get
  -> GiteaRequest RepoGetReleaseByTag MimeNoContent Release MimeJSON
repoGetReleaseByTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReleaseByTag  
-- | @application/json@
instance Produces RepoGetReleaseByTag MimeJSON


-- *** repoGetRepoPermissions

-- | @GET \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}\/permission@
-- 
-- Get repository permissions for a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRepoPermissions
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator
  -> GiteaRequest RepoGetRepoPermissions MimeNoContent RepoCollaboratorPermission MimeJSON
repoGetRepoPermissions (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator,"/permission"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRepoPermissions  
-- | @application/json@
instance Produces RepoGetRepoPermissions MimeJSON


-- *** repoGetReviewers

-- | @GET \/repos\/{owner}\/{repo}\/reviewers@
-- 
-- Return all users that can be requested to review in this repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetReviewers
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetReviewers MimeNoContent [User] MimeJSON
repoGetReviewers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReviewers  
-- | @application/json@
instance Produces RepoGetReviewers MimeJSON


-- *** repoGetRunnerRegistrationToken

-- | @GET \/repos\/{owner}\/{repo}\/actions\/runners\/registration-token@
-- 
-- Get a repository's actions runner registration token
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRunnerRegistrationToken
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetRunnerRegistrationToken MimeNoContent NoContent MimeNoContent
repoGetRunnerRegistrationToken (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/actions/runners/registration-token"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRunnerRegistrationToken  
instance Produces RepoGetRunnerRegistrationToken MimeNoContent


-- *** repoGetSingleCommit

-- | @GET \/repos\/{owner}\/{repo}\/git\/commits\/{sha}@
-- 
-- Get a single commit from a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetSingleCommit
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  a git ref or commit sha
  -> GiteaRequest RepoGetSingleCommit MimeNoContent Commit MimeJSON
repoGetSingleCommit (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/commits/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetSingleCommit  

-- | /Optional Param/ "stat" - include diff stats for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetSingleCommit Stat where
  applyOptionalParam req (Stat xs) =
    req `addQuery` toQuery ("stat", Just xs)

-- | /Optional Param/ "verification" - include verification for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetSingleCommit Verification where
  applyOptionalParam req (Verification xs) =
    req `addQuery` toQuery ("verification", Just xs)

-- | /Optional Param/ "files" - include a list of affected files for every commit (disable for speedup, default 'true')
instance HasOptionalParam RepoGetSingleCommit Files where
  applyOptionalParam req (Files xs) =
    req `addQuery` toQuery ("files", Just xs)
-- | @application/json@
instance Produces RepoGetSingleCommit MimeJSON


-- *** repoGetTag

-- | @GET \/repos\/{owner}\/{repo}\/tags\/{tag}@
-- 
-- Get the tag of a repository by tag name
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetTag
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  name of tag
  -> GiteaRequest RepoGetTag MimeNoContent Tag MimeJSON
repoGetTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetTag  
-- | @application/json@
instance Produces RepoGetTag MimeJSON


-- *** repoGetTagProtection

-- | @GET \/repos\/{owner}\/{repo}\/tag_protections\/{id}@
-- 
-- Get a specific tag protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetTagProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdInt -- ^ "id" -  id of the tag protect to get
  -> GiteaRequest RepoGetTagProtection MimeNoContent TagProtection MimeJSON
repoGetTagProtection (Owner owner) (Repo repo) (IdInt id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tag_protections/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetTagProtection  
-- | @application/json@
instance Produces RepoGetTagProtection MimeJSON


-- *** repoGetWikiPage

-- | @GET \/repos\/{owner}\/{repo}\/wiki\/page\/{pageName}@
-- 
-- Get a wiki page
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetWikiPage
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> PageName -- ^ "pageName" -  name of the page
  -> GiteaRequest RepoGetWikiPage MimeNoContent WikiPage MimeJSON
repoGetWikiPage (Owner owner) (Repo repo) (PageName pageName) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/wiki/page/",toPath pageName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetWikiPage  
-- | @application/json@
instance Produces RepoGetWikiPage MimeJSON


-- *** repoGetWikiPageRevisions

-- | @GET \/repos\/{owner}\/{repo}\/wiki\/revisions\/{pageName}@
-- 
-- Get revisions of a wiki page
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetWikiPageRevisions
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> PageName -- ^ "pageName" -  name of the page
  -> GiteaRequest RepoGetWikiPageRevisions MimeNoContent WikiCommitList MimeJSON
repoGetWikiPageRevisions (Owner owner) (Repo repo) (PageName pageName) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/wiki/revisions/",toPath pageName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetWikiPageRevisions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetWikiPageRevisions Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)
-- | @application/json@
instance Produces RepoGetWikiPageRevisions MimeJSON


-- *** repoGetWikiPages

-- | @GET \/repos\/{owner}\/{repo}\/wiki\/pages@
-- 
-- Get all wiki pages
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetWikiPages
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetWikiPages MimeNoContent [WikiPageMetaData] MimeJSON
repoGetWikiPages (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/wiki/pages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetWikiPages  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetWikiPages Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetWikiPages Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetWikiPages MimeJSON


-- *** repoListActionsSecrets

-- | @GET \/repos\/{owner}\/{repo}\/actions\/secrets@
-- 
-- List an repo's actions secrets
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListActionsSecrets
  :: Owner -- ^ "owner" -  owner of the repository
  -> Repo -- ^ "repo" -  name of the repository
  -> GiteaRequest RepoListActionsSecrets MimeNoContent [Secret] MimeJSON
repoListActionsSecrets (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/actions/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListActionsSecrets  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListActionsSecrets Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListActionsSecrets Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListActionsSecrets MimeJSON


-- *** repoListActivityFeeds

-- | @GET \/repos\/{owner}\/{repo}\/activities\/feeds@
-- 
-- List a repository's activity feeds
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListActivityFeeds
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListActivityFeeds MimeNoContent [Activity] MimeJSON
repoListActivityFeeds (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/activities/feeds"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListActivityFeeds  

-- | /Optional Param/ "date" - the date of the activities to be found
instance HasOptionalParam RepoListActivityFeeds ParamDate where
  applyOptionalParam req (ParamDate xs) =
    req `addQuery` toQuery ("date", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListActivityFeeds Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListActivityFeeds Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListActivityFeeds MimeJSON


-- *** repoListAllGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListAllGitRefs
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListAllGitRefs MimeNoContent [Reference] MimeJSON
repoListAllGitRefs (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListAllGitRefs  
-- | @application/json@
instance Produces RepoListAllGitRefs MimeJSON


-- *** repoListBranchProtection

-- | @GET \/repos\/{owner}\/{repo}\/branch_protections@
-- 
-- List branch protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListBranchProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListBranchProtection MimeNoContent [BranchProtection] MimeJSON
repoListBranchProtection (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListBranchProtection  
-- | @application/json@
instance Produces RepoListBranchProtection MimeJSON


-- *** repoListBranches

-- | @GET \/repos\/{owner}\/{repo}\/branches@
-- 
-- List a repository's branches
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListBranches
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListBranches MimeNoContent [Branch] MimeJSON
repoListBranches (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListBranches  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListBranches Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListBranches Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListBranches MimeJSON


-- *** repoListCollaborators

-- | @GET \/repos\/{owner}\/{repo}\/collaborators@
-- 
-- List a repository's collaborators
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListCollaborators
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListCollaborators MimeNoContent [User] MimeJSON
repoListCollaborators (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListCollaborators  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListCollaborators Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListCollaborators Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListCollaborators MimeJSON


-- *** repoListGitHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git@
-- 
-- List the Git hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListGitHooks
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListGitHooks MimeNoContent [GitHook] MimeJSON
repoListGitHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitHooks  
-- | @application/json@
instance Produces RepoListGitHooks MimeJSON


-- *** repoListGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs\/{ref}@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListGitRefs
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  part or full name of the ref
  -> GiteaRequest RepoListGitRefs MimeNoContent [Reference] MimeJSON
repoListGitRefs (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs/",toPath ref]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitRefs  
-- | @application/json@
instance Produces RepoListGitRefs MimeJSON


-- *** repoListHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks@
-- 
-- List the hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListHooks
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListHooks MimeNoContent [Hook] MimeJSON
repoListHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListHooks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListHooks MimeJSON


-- *** repoListKeys

-- | @GET \/repos\/{owner}\/{repo}\/keys@
-- 
-- List a repository's keys
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListKeys
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListKeys MimeNoContent [DeployKey] MimeJSON
repoListKeys (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListKeys  

-- | /Optional Param/ "key_id" - the key_id to search for
instance HasOptionalParam RepoListKeys KeyId where
  applyOptionalParam req (KeyId xs) =
    req `addQuery` toQuery ("key_id", Just xs)

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam RepoListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `addQuery` toQuery ("fingerprint", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListKeys Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListKeys MimeJSON


-- *** repoListPinnedIssues

-- | @GET \/repos\/{owner}\/{repo}\/issues\/pinned@
-- 
-- List a repo's pinned issues
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPinnedIssues
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListPinnedIssues MimeNoContent [Issue] MimeJSON
repoListPinnedIssues (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/pinned"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPinnedIssues  
-- | @application/json@
instance Produces RepoListPinnedIssues MimeJSON


-- *** repoListPinnedPullRequests

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/pinned@
-- 
-- List a repo's pinned pull requests
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPinnedPullRequests
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListPinnedPullRequests MimeNoContent [PullRequest] MimeJSON
repoListPinnedPullRequests (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/pinned"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPinnedPullRequests  
-- | @application/json@
instance Produces RepoListPinnedPullRequests MimeJSON


-- *** repoListPullRequests

-- | @GET \/repos\/{owner}\/{repo}\/pulls@
-- 
-- List a repo's pull requests
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPullRequests
  :: Owner -- ^ "owner" -  Owner of the repo
  -> Repo -- ^ "repo" -  Name of the repo
  -> GiteaRequest RepoListPullRequests MimeNoContent [PullRequest] MimeJSON
repoListPullRequests (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPullRequests  

-- | /Optional Param/ "state" - State of pull request
instance HasOptionalParam RepoListPullRequests State where
  applyOptionalParam req (State xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "sort" - Type of sort
instance HasOptionalParam RepoListPullRequests Sort3 where
  applyOptionalParam req (Sort3 xs) =
    req `addQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "milestone" - ID of the milestone
instance HasOptionalParam RepoListPullRequests Milestone2 where
  applyOptionalParam req (Milestone2 xs) =
    req `addQuery` toQuery ("milestone", Just xs)

-- | /Optional Param/ "labels" - Label IDs
instance HasOptionalParam RepoListPullRequests LabelsInteger where
  applyOptionalParam req (LabelsInteger xs) =
    req `addQuery` toQueryColl MultiParamArray ("labels", Just xs)

-- | /Optional Param/ "poster" - Filter by pull request author
instance HasOptionalParam RepoListPullRequests Poster where
  applyOptionalParam req (Poster xs) =
    req `addQuery` toQuery ("poster", Just xs)

-- | /Optional Param/ "page" - Page number of results to return (1-based)
instance HasOptionalParam RepoListPullRequests Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - Page size of results
instance HasOptionalParam RepoListPullRequests Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListPullRequests MimeJSON


-- *** repoListPullReviews

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews@
-- 
-- List all reviews for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPullReviews
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoListPullReviews MimeNoContent [PullReview] MimeJSON
repoListPullReviews (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPullReviews  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListPullReviews Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListPullReviews Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListPullReviews MimeJSON


-- *** repoListPushMirrors

-- | @GET \/repos\/{owner}\/{repo}\/push_mirrors@
-- 
-- Get all push mirrors of the repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPushMirrors
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListPushMirrors MimeNoContent [PushMirror] MimeJSON
repoListPushMirrors (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/push_mirrors"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPushMirrors  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListPushMirrors Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListPushMirrors Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListPushMirrors MimeJSON


-- *** repoListReleaseAttachments

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- List release's attachments
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListReleaseAttachments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoListReleaseAttachments MimeNoContent [Attachment] MimeJSON
repoListReleaseAttachments (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleaseAttachments  
-- | @application/json@
instance Produces RepoListReleaseAttachments MimeJSON


-- *** repoListReleases

-- | @GET \/repos\/{owner}\/{repo}\/releases@
-- 
-- List a repo's releases
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListReleases
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListReleases MimeNoContent [Release] MimeJSON
repoListReleases (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleases  

-- | /Optional Param/ "draft" - filter (exclude / include) drafts, if you dont have repo write access none will show
instance HasOptionalParam RepoListReleases Draft where
  applyOptionalParam req (Draft xs) =
    req `addQuery` toQuery ("draft", Just xs)

-- | /Optional Param/ "pre-release" - filter (exclude / include) pre-releases
instance HasOptionalParam RepoListReleases PreRelease where
  applyOptionalParam req (PreRelease xs) =
    req `addQuery` toQuery ("pre-release", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListReleases Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListReleases Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListReleases MimeJSON


-- *** repoListStargazers

-- | @GET \/repos\/{owner}\/{repo}\/stargazers@
-- 
-- List a repo's stargazers
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListStargazers
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListStargazers MimeNoContent [User] MimeJSON
repoListStargazers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/stargazers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStargazers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStargazers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStargazers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStargazers MimeJSON


-- *** repoListStatuses

-- | @GET \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Get a commit's statuses
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListStatuses
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoListStatuses MimeNoContent [CommitStatus] MimeJSON
repoListStatuses (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStatuses  

-- | /Optional Param/ "sort" - type of sort
instance HasOptionalParam RepoListStatuses Sort2 where
  applyOptionalParam req (Sort2 xs) =
    req `addQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "state" - type of state
instance HasOptionalParam RepoListStatuses State2 where
  applyOptionalParam req (State2 xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStatuses Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStatuses Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStatuses MimeJSON


-- *** repoListStatusesByRef

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{ref}\/statuses@
-- 
-- Get a commit's statuses, by branch/tag/commit reference
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListStatusesByRef
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  name of branch/tag/commit
  -> GiteaRequest RepoListStatusesByRef MimeNoContent [CommitStatus] MimeJSON
repoListStatusesByRef (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath ref,"/statuses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStatusesByRef  

-- | /Optional Param/ "sort" - type of sort
instance HasOptionalParam RepoListStatusesByRef Sort2 where
  applyOptionalParam req (Sort2 xs) =
    req `addQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "state" - type of state
instance HasOptionalParam RepoListStatusesByRef State2 where
  applyOptionalParam req (State2 xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStatusesByRef Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStatusesByRef Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStatusesByRef MimeJSON


-- *** repoListSubscribers

-- | @GET \/repos\/{owner}\/{repo}\/subscribers@
-- 
-- List a repo's watchers
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListSubscribers
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListSubscribers MimeNoContent [User] MimeJSON
repoListSubscribers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscribers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListSubscribers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListSubscribers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListSubscribers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListSubscribers MimeJSON


-- *** repoListTagProtection

-- | @GET \/repos\/{owner}\/{repo}\/tag_protections@
-- 
-- List tag protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTagProtection
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTagProtection MimeNoContent [TagProtection] MimeJSON
repoListTagProtection (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tag_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTagProtection  
-- | @application/json@
instance Produces RepoListTagProtection MimeJSON


-- *** repoListTags

-- | @GET \/repos\/{owner}\/{repo}\/tags@
-- 
-- List a repository's tags
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTags
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTags MimeNoContent [Tag] MimeJSON
repoListTags (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tags"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTags  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListTags Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results, default maximum page size is 50
instance HasOptionalParam RepoListTags Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListTags MimeJSON


-- *** repoListTeams

-- | @GET \/repos\/{owner}\/{repo}\/teams@
-- 
-- List a repository's teams
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTeams
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTeams MimeNoContent [Team] MimeJSON
repoListTeams (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTeams  
-- | @application/json@
instance Produces RepoListTeams MimeJSON


-- *** repoListTopics

-- | @GET \/repos\/{owner}\/{repo}\/topics@
-- 
-- Get list of topics that a repository has
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTopics
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTopics MimeNoContent TopicName MimeJSON
repoListTopics (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTopics  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListTopics Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListTopics Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListTopics MimeJSON


-- *** repoMergePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Merge a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMergePullRequest
  :: (Consumes RepoMergePullRequest contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to merge
  -> GiteaRequest RepoMergePullRequest contentType NoContent MimeNoContent
repoMergePullRequest _ (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMergePullRequest 
instance HasBodyParam RepoMergePullRequest MergePullRequestOption 

-- | @application/json@
instance Consumes RepoMergePullRequest MimeJSON
-- | @text/plain@
instance Consumes RepoMergePullRequest MimePlainText

instance Produces RepoMergePullRequest MimeNoContent


-- *** repoMergeUpstream

-- | @POST \/repos\/{owner}\/{repo}\/merge-upstream@
-- 
-- Merge a branch from upstream
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMergeUpstream
  :: (Consumes RepoMergeUpstream contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoMergeUpstream contentType MergeUpstreamResponse MimeJSON
repoMergeUpstream _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/merge-upstream"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMergeUpstream 
instance HasBodyParam RepoMergeUpstream MergeUpstreamRequest 

-- | @application/json@
instance Consumes RepoMergeUpstream MimeJSON
-- | @text/plain@
instance Consumes RepoMergeUpstream MimePlainText

-- | @application/json@
instance Produces RepoMergeUpstream MimeJSON


-- *** repoMigrate

-- | @POST \/repos\/migrate@
-- 
-- Migrate a remote git repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMigrate
  :: (Consumes RepoMigrate MimeJSON)
  => GiteaRequest RepoMigrate MimeJSON Repository MimeJSON
repoMigrate =
  _mkRequest "POST" ["/repos/migrate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMigrate 
instance HasBodyParam RepoMigrate MigrateRepoOptions 

-- | @application/json@
instance Consumes RepoMigrate MimeJSON

-- | @application/json@
instance Produces RepoMigrate MimeJSON


-- *** repoMirrorSync

-- | @POST \/repos\/{owner}\/{repo}\/mirror-sync@
-- 
-- Sync a mirrored repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMirrorSync
  :: Owner -- ^ "owner" -  owner of the repo to sync
  -> Repo -- ^ "repo" -  name of the repo to sync
  -> GiteaRequest RepoMirrorSync MimeNoContent NoContent MimeNoContent
repoMirrorSync (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/mirror-sync"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMirrorSync  
instance Produces RepoMirrorSync MimeNoContent


-- *** repoNewPinAllowed

-- | @GET \/repos\/{owner}\/{repo}\/new_pin_allowed@
-- 
-- Returns if new Issue Pins are allowed
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoNewPinAllowed
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoNewPinAllowed MimeNoContent NewIssuePinsAllowed MimeJSON
repoNewPinAllowed (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/new_pin_allowed"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoNewPinAllowed  
-- | @application/json@
instance Produces RepoNewPinAllowed MimeJSON


-- *** repoPullRequestIsMerged

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Check if a pull request has been merged
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoPullRequestIsMerged
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoPullRequestIsMerged MimeNoContent NoContent MimeNoContent
repoPullRequestIsMerged (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoPullRequestIsMerged  
instance Produces RepoPullRequestIsMerged MimeNoContent


-- *** repoPushMirrorSync

-- | @POST \/repos\/{owner}\/{repo}\/push_mirrors-sync@
-- 
-- Sync all push mirrored repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoPushMirrorSync
  :: Owner -- ^ "owner" -  owner of the repo to sync
  -> Repo -- ^ "repo" -  name of the repo to sync
  -> GiteaRequest RepoPushMirrorSync MimeNoContent NoContent MimeNoContent
repoPushMirrorSync (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/push_mirrors-sync"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoPushMirrorSync  
instance Produces RepoPushMirrorSync MimeNoContent


-- *** repoSearch

-- | @GET \/repos\/search@
-- 
-- Search for repositories
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoSearch
  :: GiteaRequest RepoSearch MimeNoContent SearchResults MimeJSON
repoSearch =
  _mkRequest "GET" ["/repos/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSearch  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam RepoSearch Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "topic" - Limit search to repositories with keyword as topic
instance HasOptionalParam RepoSearch Topic where
  applyOptionalParam req (Topic xs) =
    req `addQuery` toQuery ("topic", Just xs)

-- | /Optional Param/ "includeDesc" - include search of keyword within repository description
instance HasOptionalParam RepoSearch IncludeDesc where
  applyOptionalParam req (IncludeDesc xs) =
    req `addQuery` toQuery ("includeDesc", Just xs)

-- | /Optional Param/ "uid" - search only for repos that the user with the given id owns or contributes to
instance HasOptionalParam RepoSearch Uid where
  applyOptionalParam req (Uid xs) =
    req `addQuery` toQuery ("uid", Just xs)

-- | /Optional Param/ "priority_owner_id" - repo owner to prioritize in the results
instance HasOptionalParam RepoSearch PriorityOwnerId where
  applyOptionalParam req (PriorityOwnerId xs) =
    req `addQuery` toQuery ("priority_owner_id", Just xs)

-- | /Optional Param/ "team_id" - search only for repos that belong to the given team id
instance HasOptionalParam RepoSearch TeamId where
  applyOptionalParam req (TeamId xs) =
    req `addQuery` toQuery ("team_id", Just xs)

-- | /Optional Param/ "starredBy" - search only for repos that the user with the given id has starred
instance HasOptionalParam RepoSearch StarredBy where
  applyOptionalParam req (StarredBy xs) =
    req `addQuery` toQuery ("starredBy", Just xs)

-- | /Optional Param/ "private" - include private repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Private where
  applyOptionalParam req (Private xs) =
    req `addQuery` toQuery ("private", Just xs)

-- | /Optional Param/ "is_private" - show only pubic, private or all repositories (defaults to all)
instance HasOptionalParam RepoSearch IsPrivate where
  applyOptionalParam req (IsPrivate xs) =
    req `addQuery` toQuery ("is_private", Just xs)

-- | /Optional Param/ "template" - include template repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Template where
  applyOptionalParam req (Template xs) =
    req `addQuery` toQuery ("template", Just xs)

-- | /Optional Param/ "archived" - show only archived, non-archived or all repositories (defaults to all)
instance HasOptionalParam RepoSearch Archived where
  applyOptionalParam req (Archived xs) =
    req `addQuery` toQuery ("archived", Just xs)

-- | /Optional Param/ "mode" - type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
instance HasOptionalParam RepoSearch Mode where
  applyOptionalParam req (Mode xs) =
    req `addQuery` toQuery ("mode", Just xs)

-- | /Optional Param/ "exclusive" - if `uid` is given, search only for repos that the user owns
instance HasOptionalParam RepoSearch Exclusive where
  applyOptionalParam req (Exclusive xs) =
    req `addQuery` toQuery ("exclusive", Just xs)

-- | /Optional Param/ "sort" - sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", \"git_size\", \"lfs_size\", \"stars\", \"forks\" and \"id\". Default is \"alpha\"
instance HasOptionalParam RepoSearch Sort where
  applyOptionalParam req (Sort xs) =
    req `addQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "order" - sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
instance HasOptionalParam RepoSearch Order where
  applyOptionalParam req (Order xs) =
    req `addQuery` toQuery ("order", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoSearch Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoSearch MimeJSON


-- *** repoSigningKey

-- | @GET \/repos\/{owner}\/{repo}\/signing-key.gpg@
-- 
-- Get signing-key.gpg for given repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoSigningKey
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoSigningKey MimeNoContent Text MimePlainText
repoSigningKey (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/signing-key.gpg"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSigningKey  
-- | @text/plain@
instance Produces RepoSigningKey MimePlainText


-- *** repoSubmitPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Submit a pending review to an pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoSubmitPullReview
  :: (Consumes RepoSubmitPullReview contentType, MimeRender contentType SubmitPullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> SubmitPullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoSubmitPullReview contentType PullReview MimeJSON
repoSubmitPullReview _ body (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoSubmitPullReview 
instance HasBodyParam RepoSubmitPullReview SubmitPullReviewOptions 

-- | @application/json@
instance Consumes RepoSubmitPullReview MimeJSON
-- | @text/plain@
instance Consumes RepoSubmitPullReview MimePlainText

-- | @application/json@
instance Produces RepoSubmitPullReview MimeJSON


-- *** repoTestHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks\/{id}\/tests@
-- 
-- Test a push webhook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoTestHook
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to test
  -> GiteaRequest RepoTestHook MimeNoContent NoContent MimeNoContent
repoTestHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id,"/tests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTestHook  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
instance HasOptionalParam RepoTestHook Ref where
  applyOptionalParam req (Ref xs) =
    req `addQuery` toQuery ("ref", Just xs)
instance Produces RepoTestHook MimeNoContent


-- *** repoTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times@
-- 
-- List a repo's tracked times
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoTrackedTimes
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoTrackedTimes MimeNoContent [TrackedTime] MimeJSON
repoTrackedTimes (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTrackedTimes  

-- | /Optional Param/ "user" - optional filter by user (available for issue managers)
instance HasOptionalParam RepoTrackedTimes User2 where
  applyOptionalParam req (User2 xs) =
    req `addQuery` toQuery ("user", Just xs)

-- | /Optional Param/ "since" - Only show times updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam RepoTrackedTimes Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show times updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam RepoTrackedTimes Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoTrackedTimes Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoTrackedTimes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoTrackedTimes MimeJSON


-- *** repoTransfer0

-- | @POST \/repos\/{owner}\/{repo}\/transfer@
-- 
-- Transfer a repo ownership
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoTransfer0
  :: (Consumes RepoTransfer0 contentType, MimeRender contentType TransferRepoOption)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> TransferRepoOption -- ^ "body" -  Transfer Options
  -> Owner -- ^ "owner" -  owner of the repo to transfer
  -> Repo -- ^ "repo" -  name of the repo to transfer
  -> GiteaRequest RepoTransfer0 contentType Repository MimeJSON
repoTransfer0 _ body (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/transfer"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoTransfer0 

-- | /Body Param/ "body" - Transfer Options
instance HasBodyParam RepoTransfer0 TransferRepoOption 

-- | @application/json@
instance Consumes RepoTransfer0 MimeJSON
-- | @text/plain@
instance Consumes RepoTransfer0 MimePlainText

-- | @application/json@
instance Produces RepoTransfer0 MimeJSON


-- *** repoUnDismissPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/undismissals@
-- 
-- Cancel to dismiss a review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUnDismissPullReview
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoUnDismissPullReview MimeNoContent PullReview MimeJSON
repoUnDismissPullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/undismissals"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUnDismissPullReview  
-- | @application/json@
instance Produces RepoUnDismissPullReview MimeJSON


-- *** repoUpdateAvatar

-- | @POST \/repos\/{owner}\/{repo}\/avatar@
-- 
-- Update avatar
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateAvatar
  :: (Consumes RepoUpdateAvatar contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoUpdateAvatar contentType NoContent MimeNoContent
repoUpdateAvatar _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/avatar"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateAvatar 
instance HasBodyParam RepoUpdateAvatar UpdateRepoAvatarOption 

-- | @application/json@
instance Consumes RepoUpdateAvatar MimeJSON
-- | @text/plain@
instance Consumes RepoUpdateAvatar MimePlainText

instance Produces RepoUpdateAvatar MimeNoContent


-- *** repoUpdateBranch

-- | @PATCH \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Update a branch
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateBranch
  :: (Consumes RepoUpdateBranch MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  name of the branch
  -> GiteaRequest RepoUpdateBranch MimeJSON NoContent MimeNoContent
repoUpdateBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateBranch 
instance HasBodyParam RepoUpdateBranch UpdateBranchRepoOption 

-- | @application/json@
instance Consumes RepoUpdateBranch MimeJSON

instance Produces RepoUpdateBranch MimeNoContent


-- *** repoUpdateBranchProtectionPriories

-- | @POST \/repos\/{owner}\/{repo}\/branch_protections\/priority@
-- 
-- Update the priorities of branch protections for a repository.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateBranchProtectionPriories
  :: (Consumes RepoUpdateBranchProtectionPriories MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoUpdateBranchProtectionPriories MimeJSON NoContent MimeNoContent
repoUpdateBranchProtectionPriories (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/priority"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateBranchProtectionPriories 
instance HasBodyParam RepoUpdateBranchProtectionPriories UpdateBranchProtectionPriories 

-- | @application/json@
instance Consumes RepoUpdateBranchProtectionPriories MimeJSON

instance Produces RepoUpdateBranchProtectionPriories MimeNoContent


-- *** repoUpdateFile

-- | @PUT \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Update a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateFile
  :: (Consumes RepoUpdateFile MimeJSON, MimeRender MimeJSON UpdateFileOptions)
  => UpdateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to update
  -> GiteaRequest RepoUpdateFile MimeJSON FileResponse MimeJSON
repoUpdateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoUpdateFile 
instance HasBodyParam RepoUpdateFile UpdateFileOptions 

-- | @application/json@
instance Consumes RepoUpdateFile MimeJSON

-- | @application/json@
instance Produces RepoUpdateFile MimeJSON


-- *** repoUpdatePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/update@
-- 
-- Merge PR's baseBranch into headBranch
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdatePullRequest
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoUpdatePullRequest MimeNoContent NoContent MimeNoContent
repoUpdatePullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/update"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdatePullRequest  

-- | /Optional Param/ "style" - how to update pull request
instance HasOptionalParam RepoUpdatePullRequest Style where
  applyOptionalParam req (Style xs) =
    req `addQuery` toQuery ("style", Just xs)
instance Produces RepoUpdatePullRequest MimeNoContent


-- *** repoUpdateTopics

-- | @PUT \/repos\/{owner}\/{repo}\/topics@
-- 
-- Replace list of topics for a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateTopics
  :: (Consumes RepoUpdateTopics contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoUpdateTopics contentType NoContent MimeNoContent
repoUpdateTopics _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateTopics 
instance HasBodyParam RepoUpdateTopics RepoTopicOptions 

-- | @application/json@
instance Consumes RepoUpdateTopics MimeJSON
-- | @text/plain@
instance Consumes RepoUpdateTopics MimePlainText

instance Produces RepoUpdateTopics MimeNoContent


-- *** repoValidateIssueConfig

-- | @GET \/repos\/{owner}\/{repo}\/issue_config\/validate@
-- 
-- Returns the validation information for a issue config
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoValidateIssueConfig
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoValidateIssueConfig MimeNoContent IssueConfigValidation MimeJSON
repoValidateIssueConfig (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issue_config/validate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoValidateIssueConfig  
-- | @application/json@
instance Produces RepoValidateIssueConfig MimeJSON


-- *** topicSearch

-- | @GET \/topics\/search@
-- 
-- search topics via keyword
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
topicSearch
  :: Q -- ^ "q" -  keywords to search
  -> GiteaRequest TopicSearch MimeNoContent [TopicResponse] MimeJSON
topicSearch (Q q) =
  _mkRequest "GET" ["/topics/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `addQuery` toQuery ("q", Just q)

data TopicSearch  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam TopicSearch Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam TopicSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces TopicSearch MimeJSON


-- *** updateRepoSecret

-- | @PUT \/repos\/{owner}\/{repo}\/actions\/secrets\/{secretname}@
-- 
-- Create or Update a secret value in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
updateRepoSecret
  :: (Consumes UpdateRepoSecret MimeJSON)
  => Owner -- ^ "owner" -  owner of the repository
  -> Repo -- ^ "repo" -  name of the repository
  -> Secretname -- ^ "secretname" -  name of the secret
  -> GiteaRequest UpdateRepoSecret MimeJSON NoContent MimeNoContent
updateRepoSecret (Owner owner) (Repo repo) (Secretname secretname) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/actions/secrets/",toPath secretname]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UpdateRepoSecret 
instance HasBodyParam UpdateRepoSecret CreateOrUpdateSecretOption 

-- | @application/json@
instance Consumes UpdateRepoSecret MimeJSON

instance Produces UpdateRepoSecret MimeNoContent


-- *** updateRepoVariable

-- | @PUT \/repos\/{owner}\/{repo}\/actions\/variables\/{variablename}@
-- 
-- Update a repo-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
updateRepoVariable
  :: (Consumes UpdateRepoVariable contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  name of the owner
  -> Repo -- ^ "repo" -  name of the repository
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest UpdateRepoVariable contentType NoContent MimeNoContent
updateRepoVariable _ (Owner owner) (Repo repo) (Variablename variablename) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UpdateRepoVariable 
instance HasBodyParam UpdateRepoVariable UpdateVariableOption 

-- | @application/json@
instance Consumes UpdateRepoVariable MimeJSON
-- | @text/plain@
instance Consumes UpdateRepoVariable MimePlainText

instance Produces UpdateRepoVariable MimeNoContent


-- *** userCurrentCheckSubscription

-- | @GET \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Check if the current user is watching a repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckSubscription
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentCheckSubscription MimeNoContent WatchInfo accept
userCurrentCheckSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckSubscription  
-- | @text/html@
instance Produces UserCurrentCheckSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentCheckSubscription MimeJSON


-- *** userCurrentDeleteSubscription

-- | @DELETE \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Unwatch a repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteSubscription
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentDeleteSubscription MimeNoContent NoContent MimeNoContent
userCurrentDeleteSubscription (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteSubscription  
instance Produces UserCurrentDeleteSubscription MimeNoContent


-- *** userCurrentPutSubscription

-- | @PUT \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Watch a repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutSubscription
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentPutSubscription MimeNoContent WatchInfo accept
userCurrentPutSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutSubscription  
-- | @text/html@
instance Produces UserCurrentPutSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentPutSubscription MimeJSON


-- *** userTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times\/{user}@
-- 
-- List a user's tracked times in a repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userTrackedTimes
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> User2 -- ^ "user" -  username of user
  -> GiteaRequest UserTrackedTimes MimeNoContent [TrackedTime] MimeJSON
userTrackedTimes (Owner owner) (Repo repo) (User2 user) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED userTrackedTimes "" #-}

data UserTrackedTimes  
-- | @application/json@
instance Produces UserTrackedTimes MimeJSON

