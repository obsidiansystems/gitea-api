{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.1.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Repository
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Repository where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Repository

-- *** createCurrentUserRepo

-- | @POST \/user\/repos@
-- 
-- Create a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createCurrentUserRepo 
  :: (Consumes CreateCurrentUserRepo MimeJSON)
  => GiteaRequest CreateCurrentUserRepo MimeJSON Repository MimeJSON
createCurrentUserRepo =
  _mkRequest "POST" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateCurrentUserRepo 
instance HasBodyParam CreateCurrentUserRepo CreateRepoOption 

-- | @application/json@
instance Consumes CreateCurrentUserRepo MimeJSON

-- | @application/json@
instance Produces CreateCurrentUserRepo MimeJSON


-- *** createFork

-- | @POST \/repos\/{owner}\/{repo}\/forks@
-- 
-- Fork a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createFork 
  :: (Consumes CreateFork contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to fork
  -> Repo -- ^ "repo" -  name of the repo to fork
  -> GiteaRequest CreateFork contentType Repository MimeJSON
createFork _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateFork 
instance HasBodyParam CreateFork CreateForkOption 

-- | @application/json@
instance Consumes CreateFork MimeJSON
-- | @text/plain@
instance Consumes CreateFork MimePlainText

-- | @application/json@
instance Produces CreateFork MimeJSON


-- *** getBlob

-- | @GET \/repos\/{owner}\/{repo}\/git\/blobs\/{sha}@
-- 
-- Gets the blob of a repository.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getBlob 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetBlob MimeNoContent GitBlobResponse MimeJSON
getBlob (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/blobs/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetBlob  
-- | @application/json@
instance Produces GetBlob MimeJSON


-- *** getTag

-- | @GET \/repos\/{owner}\/{repo}\/git\/tags\/{sha}@
-- 
-- Gets the tag object of an annotated tag (not lightweight tags)
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
  -> GiteaRequest GetTag MimeNoContent AnnotatedTag MimeJSON
getTag (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/tags/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetTag  
-- | @application/json@
instance Produces GetTag MimeJSON


-- *** getTree

-- | @GET \/repos\/{owner}\/{repo}\/git\/trees\/{sha}@
-- 
-- Gets the tree of a repository.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getTree 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetTree MimeNoContent GitTreeResponse MimeJSON
getTree (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/trees/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetTree  

-- | /Optional Param/ "recursive" - show all directories and files
instance HasOptionalParam GetTree Recursive where
  applyOptionalParam req (Recursive xs) =
    req `setQuery` toQuery ("recursive", Just xs)

-- | /Optional Param/ "page" - page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
instance HasOptionalParam GetTree Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "per_page" - number of items per page; default is 1000 or what is set in app.ini as DEFAULT_GIT_TREES_PER_PAGE
instance HasOptionalParam GetTree PerPage where
  applyOptionalParam req (PerPage xs) =
    req `setQuery` toQuery ("per_page", Just xs)
-- | @application/json@
instance Produces GetTree MimeJSON


-- *** listForks

-- | @GET \/repos\/{owner}\/{repo}\/forks@
-- 
-- List a repository's forks
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
listForks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest ListForks MimeNoContent [Repository] MimeJSON
listForks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data ListForks  
-- | @application/json@
instance Produces ListForks MimeJSON


-- *** repoAddCollaborator

-- | @PUT \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Add a collaborator to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddCollaborator 
  :: (Consumes RepoAddCollaborator contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to add
  -> GiteaRequest RepoAddCollaborator contentType NoContent MimeNoContent
repoAddCollaborator _ (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddCollaborator 
instance HasBodyParam RepoAddCollaborator AddCollaboratorOption 

-- | @application/json@
instance Consumes RepoAddCollaborator MimeJSON
-- | @text/plain@
instance Consumes RepoAddCollaborator MimePlainText

instance Produces RepoAddCollaborator MimeNoContent


-- *** repoAddTopc

-- | @PUT \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Add a topic to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoAddTopc 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to add
  -> GiteaRequest RepoAddTopc MimeNoContent NoContent MimeNoContent
repoAddTopc (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddTopc  
instance Produces RepoAddTopc MimeNoContent


-- *** repoCheckCollaborator

-- | @GET \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Check if a user is a collaborator of a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCheckCollaborator 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator
  -> GiteaRequest RepoCheckCollaborator MimeNoContent NoContent MimeNoContent
repoCheckCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCheckCollaborator  
instance Produces RepoCheckCollaborator MimeNoContent


-- *** repoCreateFile

-- | @POST \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Create a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateFile 
  :: (Consumes RepoCreateFile MimeJSON, MimeRender MimeJSON CreateFileOptions)
  => CreateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to create
  -> GiteaRequest RepoCreateFile MimeJSON FileResponse MimeJSON
repoCreateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreateFile 
instance HasBodyParam RepoCreateFile CreateFileOptions 

-- | @application/json@
instance Consumes RepoCreateFile MimeJSON

-- | @application/json@
instance Produces RepoCreateFile MimeJSON


-- *** repoCreateHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateHook 
  :: (Consumes RepoCreateHook MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateHook MimeJSON Hook MimeJSON
repoCreateHook (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateHook 
instance HasBodyParam RepoCreateHook CreateHookOption 

-- | @application/json@
instance Consumes RepoCreateHook MimeJSON

-- | @application/json@
instance Produces RepoCreateHook MimeJSON


-- *** repoCreateKey

-- | @POST \/repos\/{owner}\/{repo}\/keys@
-- 
-- Add a key to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateKey 
  :: (Consumes RepoCreateKey MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateKey MimeJSON DeployKey MimeJSON
repoCreateKey (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateKey 
instance HasBodyParam RepoCreateKey CreateKeyOption 

-- | @application/json@
instance Consumes RepoCreateKey MimeJSON

-- | @application/json@
instance Produces RepoCreateKey MimeJSON


-- *** repoCreatePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls@
-- 
-- Create a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreatePullRequest 
  :: (Consumes RepoCreatePullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreatePullRequest MimeJSON PullRequest MimeJSON
repoCreatePullRequest (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreatePullRequest 
instance HasBodyParam RepoCreatePullRequest CreatePullRequestOption 

-- | @application/json@
instance Consumes RepoCreatePullRequest MimeJSON

-- | @application/json@
instance Produces RepoCreatePullRequest MimeJSON


-- *** repoCreateRelease

-- | @POST \/repos\/{owner}\/{repo}\/releases@
-- 
-- Create a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateRelease 
  :: (Consumes RepoCreateRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateRelease MimeJSON Release MimeJSON
repoCreateRelease (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateRelease 
instance HasBodyParam RepoCreateRelease CreateReleaseOption 

-- | @application/json@
instance Consumes RepoCreateRelease MimeJSON

-- | @application/json@
instance Produces RepoCreateRelease MimeJSON


-- *** repoCreateReleaseAttachment

-- | @POST \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- Create a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateReleaseAttachment 
  :: (Consumes RepoCreateReleaseAttachment MimeMultipartFormData)
  => Attachment2 -- ^ "attachment" -  attachment to upload
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoCreateReleaseAttachment MimeMultipartFormData Attachment MimeJSON
repoCreateReleaseAttachment (Attachment2 attachment) (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `_addMultiFormPart` NH.partFileSource "attachment" attachment

data RepoCreateReleaseAttachment  

-- | /Optional Param/ "name" - name of the attachment
instance HasOptionalParam RepoCreateReleaseAttachment Name where
  applyOptionalParam req (Name xs) =
    req `setQuery` toQuery ("name", Just xs)

-- | @multipart/form-data@
instance Consumes RepoCreateReleaseAttachment MimeMultipartFormData

-- | @application/json@
instance Produces RepoCreateReleaseAttachment MimeJSON


-- *** repoCreateStatus

-- | @POST \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Create a commit status
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoCreateStatus 
  :: (Consumes RepoCreateStatus contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoCreateStatus contentType Status MimeJSON
repoCreateStatus _ (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateStatus 
instance HasBodyParam RepoCreateStatus CreateStatusOption 

-- | @application/json@
instance Consumes RepoCreateStatus MimeJSON
-- | @text/plain@
instance Consumes RepoCreateStatus MimePlainText

-- | @application/json@
instance Produces RepoCreateStatus MimeJSON


-- *** repoDelete

-- | @DELETE \/repos\/{owner}\/{repo}@
-- 
-- Delete a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDelete 
  :: Owner -- ^ "owner" -  owner of the repo to delete
  -> Repo -- ^ "repo" -  name of the repo to delete
  -> GiteaRequest RepoDelete MimeNoContent NoContent MimeNoContent
repoDelete (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDelete  
instance Produces RepoDelete MimeNoContent


-- *** repoDeleteCollaborator

-- | @DELETE \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Delete a collaborator from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteCollaborator 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to delete
  -> GiteaRequest RepoDeleteCollaborator MimeNoContent NoContent MimeNoContent
repoDeleteCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteCollaborator  
instance Produces RepoDeleteCollaborator MimeNoContent


-- *** repoDeleteFile

-- | @DELETE \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Delete a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteFile 
  :: (Consumes RepoDeleteFile MimeJSON, MimeRender MimeJSON DeleteFileOptions)
  => DeleteFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to delete
  -> GiteaRequest RepoDeleteFile MimeJSON FileDeleteResponse MimeJSON
repoDeleteFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDeleteFile 
instance HasBodyParam RepoDeleteFile DeleteFileOptions 

-- | @application/json@
instance Consumes RepoDeleteFile MimeJSON

-- | @application/json@
instance Produces RepoDeleteFile MimeJSON


-- *** repoDeleteGitHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Delete a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteGitHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoDeleteGitHook MimeNoContent NoContent MimeNoContent
repoDeleteGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteGitHook  
instance Produces RepoDeleteGitHook MimeNoContent


-- *** repoDeleteHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Delete a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest RepoDeleteHook MimeNoContent NoContent MimeNoContent
repoDeleteHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteHook  
instance Produces RepoDeleteHook MimeNoContent


-- *** repoDeleteKey

-- | @DELETE \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Delete a key from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to delete
  -> GiteaRequest RepoDeleteKey MimeNoContent NoContent MimeNoContent
repoDeleteKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteKey  
instance Produces RepoDeleteKey MimeNoContent


-- *** repoDeleteRelease

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Delete a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteRelease 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to delete
  -> GiteaRequest RepoDeleteRelease MimeNoContent NoContent MimeNoContent
repoDeleteRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteRelease  
instance Produces RepoDeleteRelease MimeNoContent


-- *** repoDeleteReleaseAttachment

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Delete a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteReleaseAttachment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to delete
  -> GiteaRequest RepoDeleteReleaseAttachment MimeNoContent NoContent MimeNoContent
repoDeleteReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteReleaseAttachment  
instance Produces RepoDeleteReleaseAttachment MimeNoContent


-- *** repoDeleteTopic

-- | @DELETE \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Delete a topic from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoDeleteTopic 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to delete
  -> GiteaRequest RepoDeleteTopic MimeNoContent NoContent MimeNoContent
repoDeleteTopic (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTopic  
instance Produces RepoDeleteTopic MimeNoContent


-- *** repoEdit

-- | @PATCH \/repos\/{owner}\/{repo}@
-- 
-- Edit a repository's properties. Only fields that are set will be changed.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEdit 
  :: (Consumes RepoEdit contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to edit
  -> Repo -- ^ "repo" -  name of the repo to edit
  -> GiteaRequest RepoEdit contentType Repository MimeJSON
repoEdit _ (Owner owner) (Repo repo) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEdit 

-- | /Body Param/ "body" - Properties of a repo that you can edit
instance HasBodyParam RepoEdit EditRepoOption 

-- | @application/json@
instance Consumes RepoEdit MimeJSON
-- | @text/plain@
instance Consumes RepoEdit MimePlainText

-- | @application/json@
instance Produces RepoEdit MimeJSON


-- *** repoEditGitHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Edit a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditGitHook 
  :: (Consumes RepoEditGitHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoEditGitHook contentType GitHook MimeJSON
repoEditGitHook _ (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditGitHook 
instance HasBodyParam RepoEditGitHook EditGitHookOption 

-- | @application/json@
instance Consumes RepoEditGitHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditGitHook MimePlainText

-- | @application/json@
instance Produces RepoEditGitHook MimeJSON


-- *** repoEditHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Edit a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditHook 
  :: (Consumes RepoEditHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  index of the hook
  -> GiteaRequest RepoEditHook contentType Hook MimeJSON
repoEditHook _ (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditHook 
instance HasBodyParam RepoEditHook EditHookOption 

-- | @application/json@
instance Consumes RepoEditHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditHook MimePlainText

-- | @application/json@
instance Produces RepoEditHook MimeJSON


-- *** repoEditPullRequest

-- | @PATCH \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditPullRequest 
  :: (Consumes RepoEditPullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to edit
  -> GiteaRequest RepoEditPullRequest MimeJSON PullRequest MimeJSON
repoEditPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditPullRequest 
instance HasBodyParam RepoEditPullRequest EditPullRequestOption 

-- | @application/json@
instance Consumes RepoEditPullRequest MimeJSON

-- | @application/json@
instance Produces RepoEditPullRequest MimeJSON


-- *** repoEditRelease

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Update a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditRelease 
  :: (Consumes RepoEditRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to edit
  -> GiteaRequest RepoEditRelease MimeJSON Release MimeJSON
repoEditRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditRelease 
instance HasBodyParam RepoEditRelease EditReleaseOption 

-- | @application/json@
instance Consumes RepoEditRelease MimeJSON

-- | @application/json@
instance Produces RepoEditRelease MimeJSON


-- *** repoEditReleaseAttachment

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Edit a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoEditReleaseAttachment 
  :: (Consumes RepoEditReleaseAttachment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to edit
  -> GiteaRequest RepoEditReleaseAttachment MimeJSON Attachment MimeJSON
repoEditReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditReleaseAttachment 
instance HasBodyParam RepoEditReleaseAttachment EditAttachmentOptions 

-- | @application/json@
instance Consumes RepoEditReleaseAttachment MimeJSON

-- | @application/json@
instance Produces RepoEditReleaseAttachment MimeJSON


-- *** repoGet

-- | @GET \/repos\/{owner}\/{repo}@
-- 
-- Get a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGet 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGet MimeNoContent Repository MimeJSON
repoGet (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGet  
-- | @application/json@
instance Produces RepoGet MimeJSON


-- *** repoGetAllCommits

-- | @GET \/repos\/{owner}\/{repo}\/commits@
-- 
-- Get a list of all commits from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetAllCommits 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetAllCommits MimeNoContent [Commit] MimeJSON
repoGetAllCommits (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetAllCommits  

-- | /Optional Param/ "sha" - SHA or branch to start listing commits from (usually 'master')
instance HasOptionalParam RepoGetAllCommits Sha where
  applyOptionalParam req (Sha xs) =
    req `setQuery` toQuery ("sha", Just xs)

-- | /Optional Param/ "page" - page number of requested commits
instance HasOptionalParam RepoGetAllCommits Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)
-- | @application/json@
instance Produces RepoGetAllCommits MimeJSON


-- *** repoGetArchive

-- | @GET \/repos\/{owner}\/{repo}\/archive\/{archive}@
-- 
-- Get an archive of a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetArchive 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Archive -- ^ "archive" -  archive to download, consisting of a git reference and archive
  -> GiteaRequest RepoGetArchive MimeNoContent NoContent MimeNoContent
repoGetArchive (Owner owner) (Repo repo) (Archive archive) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/archive/",toPath archive]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetArchive  
instance Produces RepoGetArchive MimeNoContent


-- *** repoGetBranch

-- | @GET \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Retrieve a specific branch from a repository, including its effective branch protection
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetBranch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  branch to get
  -> GiteaRequest RepoGetBranch MimeNoContent Branch MimeJSON
repoGetBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetBranch  
-- | @application/json@
instance Produces RepoGetBranch MimeJSON


-- *** repoGetByID

-- | @GET \/repositories\/{id}@
-- 
-- Get a repository by id
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetByID 
  :: Id -- ^ "id" -  id of the repo to get
  -> GiteaRequest RepoGetByID MimeNoContent Repository MimeJSON
repoGetByID (Id id) =
  _mkRequest "GET" ["/repositories/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetByID  
-- | @application/json@
instance Produces RepoGetByID MimeJSON


-- *** repoGetCombinedStatusByRef

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{ref}\/statuses@
-- 
-- Get a commit's combined status, by branch/tag/commit reference
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetCombinedStatusByRef 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  name of branch/tag/commit
  -> GiteaRequest RepoGetCombinedStatusByRef MimeNoContent Status MimeJSON
repoGetCombinedStatusByRef (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath ref,"/statuses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetCombinedStatusByRef  

-- | /Optional Param/ "page" - page number of results
instance HasOptionalParam RepoGetCombinedStatusByRef Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)
-- | @application/json@
instance Produces RepoGetCombinedStatusByRef MimeJSON


-- *** repoGetContents

-- | @GET \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetContents 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the dir, file, symlink or submodule in the repo
  -> GiteaRequest RepoGetContents MimeNoContent ContentsResponse MimeJSON
repoGetContents (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContents  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repositoryâ€™s default branch (usually master)
instance HasOptionalParam RepoGetContents Ref where
  applyOptionalParam req (Ref xs) =
    req `setQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContents MimeJSON


-- *** repoGetContentsList

-- | @GET \/repos\/{owner}\/{repo}\/contents@
-- 
-- Gets the metadata of all the entries of the root dir
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetContentsList 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetContentsList MimeNoContent [ContentsResponse] MimeJSON
repoGetContentsList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContentsList  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repositoryâ€™s default branch (usually master)
instance HasOptionalParam RepoGetContentsList Ref where
  applyOptionalParam req (Ref xs) =
    req `setQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContentsList MimeJSON


-- *** repoGetEditorConfig

-- | @GET \/repos\/{owner}\/{repo}\/editorconfig\/{filepath}@
-- 
-- Get the EditorConfig definitions of a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetEditorConfig 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  filepath of file to get
  -> GiteaRequest RepoGetEditorConfig MimeNoContent NoContent MimeNoContent
repoGetEditorConfig (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/editorconfig/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetEditorConfig  
instance Produces RepoGetEditorConfig MimeNoContent


-- *** repoGetGitHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Get a Git hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetGitHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetGitHook MimeNoContent GitHook MimeJSON
repoGetGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetGitHook  
-- | @application/json@
instance Produces RepoGetGitHook MimeJSON


-- *** repoGetHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetHook MimeNoContent Hook MimeJSON
repoGetHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetHook  
-- | @application/json@
instance Produces RepoGetHook MimeJSON


-- *** repoGetKey

-- | @GET \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Get a repository's key by id
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to get
  -> GiteaRequest RepoGetKey MimeNoContent DeployKey MimeJSON
repoGetKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetKey  
-- | @application/json@
instance Produces RepoGetKey MimeJSON


-- *** repoGetPullRequest

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Get a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetPullRequest 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequest MimeNoContent PullRequest MimeJSON
repoGetPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequest  
-- | @application/json@
instance Produces RepoGetPullRequest MimeJSON


-- *** repoGetRawFile

-- | @GET \/repos\/{owner}\/{repo}\/raw\/{filepath}@
-- 
-- Get a file from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRawFile 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  filepath of the file to get
  -> GiteaRequest RepoGetRawFile MimeNoContent NoContent MimeNoContent
repoGetRawFile (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/raw/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRawFile  
instance Produces RepoGetRawFile MimeNoContent


-- *** repoGetRelease

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Get a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetRelease 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to get
  -> GiteaRequest RepoGetRelease MimeNoContent Release MimeJSON
repoGetRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRelease  
-- | @application/json@
instance Produces RepoGetRelease MimeJSON


-- *** repoGetReleaseAttachment

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Get a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetReleaseAttachment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to get
  -> GiteaRequest RepoGetReleaseAttachment MimeNoContent Attachment MimeJSON
repoGetReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReleaseAttachment  
-- | @application/json@
instance Produces RepoGetReleaseAttachment MimeJSON


-- *** repoGetSingleCommit

-- | @GET \/repos\/{owner}\/{repo}\/git\/commits\/{sha}@
-- 
-- Get a single commit from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoGetSingleCommit 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  the commit hash
  -> GiteaRequest RepoGetSingleCommit MimeNoContent Commit MimeJSON
repoGetSingleCommit (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/commits/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetSingleCommit  
-- | @application/json@
instance Produces RepoGetSingleCommit MimeJSON


-- *** repoListAllGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListAllGitRefs 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListAllGitRefs MimeNoContent [Reference] MimeJSON
repoListAllGitRefs (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListAllGitRefs  
-- | @application/json@
instance Produces RepoListAllGitRefs MimeJSON


-- *** repoListBranches

-- | @GET \/repos\/{owner}\/{repo}\/branches@
-- 
-- List a repository's branches
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListBranches 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListBranches MimeNoContent [Branch] MimeJSON
repoListBranches (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListBranches  
-- | @application/json@
instance Produces RepoListBranches MimeJSON


-- *** repoListCollaborators

-- | @GET \/repos\/{owner}\/{repo}\/collaborators@
-- 
-- List a repository's collaborators
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListCollaborators 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListCollaborators MimeNoContent [User] MimeJSON
repoListCollaborators (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListCollaborators  
-- | @application/json@
instance Produces RepoListCollaborators MimeJSON


-- *** repoListGitHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git@
-- 
-- List the Git hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListGitHooks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListGitHooks MimeNoContent [GitHook] MimeJSON
repoListGitHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitHooks  
-- | @application/json@
instance Produces RepoListGitHooks MimeJSON


-- *** repoListGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs\/{ref}@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListGitRefs 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  part or full name of the ref
  -> GiteaRequest RepoListGitRefs MimeNoContent [Reference] MimeJSON
repoListGitRefs (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs/",toPath ref]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitRefs  
-- | @application/json@
instance Produces RepoListGitRefs MimeJSON


-- *** repoListHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks@
-- 
-- List the hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListHooks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListHooks MimeNoContent [Hook] MimeJSON
repoListHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListHooks  
-- | @application/json@
instance Produces RepoListHooks MimeJSON


-- *** repoListKeys

-- | @GET \/repos\/{owner}\/{repo}\/keys@
-- 
-- List a repository's keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListKeys 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListKeys MimeNoContent [DeployKey] MimeJSON
repoListKeys (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListKeys  

-- | /Optional Param/ "key_id" - the key_id to search for
instance HasOptionalParam RepoListKeys KeyId where
  applyOptionalParam req (KeyId xs) =
    req `setQuery` toQuery ("key_id", Just xs)

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam RepoListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `setQuery` toQuery ("fingerprint", Just xs)
-- | @application/json@
instance Produces RepoListKeys MimeJSON


-- *** repoListPullRequests

-- | @GET \/repos\/{owner}\/{repo}\/pulls@
-- 
-- List a repo's pull requests
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListPullRequests 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListPullRequests MimeNoContent [PullRequest] MimeJSON
repoListPullRequests (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPullRequests  

-- | /Optional Param/ "page" - Page number
instance HasOptionalParam RepoListPullRequests Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "state" - State of pull request: open or closed (optional)
instance HasOptionalParam RepoListPullRequests State2 where
  applyOptionalParam req (State2 xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "sort" - Type of sort
instance HasOptionalParam RepoListPullRequests Sort2 where
  applyOptionalParam req (Sort2 xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "milestone" - ID of the milestone
instance HasOptionalParam RepoListPullRequests Milestone2 where
  applyOptionalParam req (Milestone2 xs) =
    req `setQuery` toQuery ("milestone", Just xs)

-- | /Optional Param/ "labels" - Label IDs
instance HasOptionalParam RepoListPullRequests LabelsInteger where
  applyOptionalParam req (LabelsInteger xs) =
    req `setQuery` toQueryColl MultiParamArray ("labels", Just xs)
-- | @application/json@
instance Produces RepoListPullRequests MimeJSON


-- *** repoListReleaseAttachments

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- List release's attachments
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListReleaseAttachments 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoListReleaseAttachments MimeNoContent [Attachment] MimeJSON
repoListReleaseAttachments (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleaseAttachments  
-- | @application/json@
instance Produces RepoListReleaseAttachments MimeJSON


-- *** repoListReleases

-- | @GET \/repos\/{owner}\/{repo}\/releases@
-- 
-- List a repo's releases
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListReleases 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListReleases MimeNoContent [Release] MimeJSON
repoListReleases (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleases  

-- | /Optional Param/ "page" - page wants to load
instance HasOptionalParam RepoListReleases Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "per_page" - items count every page wants to load
instance HasOptionalParam RepoListReleases PerPage where
  applyOptionalParam req (PerPage xs) =
    req `setQuery` toQuery ("per_page", Just xs)
-- | @application/json@
instance Produces RepoListReleases MimeJSON


-- *** repoListStargazers

-- | @GET \/repos\/{owner}\/{repo}\/stargazers@
-- 
-- List a repo's stargazers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListStargazers 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListStargazers MimeNoContent [User] MimeJSON
repoListStargazers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/stargazers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStargazers  
-- | @application/json@
instance Produces RepoListStargazers MimeJSON


-- *** repoListStatuses

-- | @GET \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Get a commit's statuses
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListStatuses 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoListStatuses MimeNoContent [Status] MimeJSON
repoListStatuses (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStatuses  

-- | /Optional Param/ "page" - page number of results
instance HasOptionalParam RepoListStatuses Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "sort" - type of sort
instance HasOptionalParam RepoListStatuses Sort3 where
  applyOptionalParam req (Sort3 xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "state" - type of state
instance HasOptionalParam RepoListStatuses State3 where
  applyOptionalParam req (State3 xs) =
    req `setQuery` toQuery ("state", Just xs)
-- | @application/json@
instance Produces RepoListStatuses MimeJSON


-- *** repoListSubscribers

-- | @GET \/repos\/{owner}\/{repo}\/subscribers@
-- 
-- List a repo's watchers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListSubscribers 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListSubscribers MimeNoContent [User] MimeJSON
repoListSubscribers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscribers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListSubscribers  
-- | @application/json@
instance Produces RepoListSubscribers MimeJSON


-- *** repoListTags

-- | @GET \/repos\/{owner}\/{repo}\/tags@
-- 
-- List a repository's tags
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTags 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTags MimeNoContent [Tag] MimeJSON
repoListTags (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tags"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTags  
-- | @application/json@
instance Produces RepoListTags MimeJSON


-- *** repoListTopics

-- | @GET \/repos\/{owner}\/{repo}\/topics@
-- 
-- Get list of topics that a repository has
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoListTopics 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTopics MimeNoContent TopicName MimeJSON
repoListTopics (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTopics  
-- | @application/json@
instance Produces RepoListTopics MimeJSON


-- *** repoMergePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Merge a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMergePullRequest 
  :: (Consumes RepoMergePullRequest contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to merge
  -> GiteaRequest RepoMergePullRequest contentType NoContent MimeNoContent
repoMergePullRequest _ (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMergePullRequest 
instance HasBodyParam RepoMergePullRequest MergePullRequestOption 

-- | @application/json@
instance Consumes RepoMergePullRequest MimeJSON
-- | @text/plain@
instance Consumes RepoMergePullRequest MimePlainText

instance Produces RepoMergePullRequest MimeNoContent


-- *** repoMigrate

-- | @POST \/repos\/migrate@
-- 
-- Migrate a remote git repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMigrate 
  :: (Consumes RepoMigrate MimeJSON)
  => GiteaRequest RepoMigrate MimeJSON Repository MimeJSON
repoMigrate =
  _mkRequest "POST" ["/repos/migrate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMigrate 
instance HasBodyParam RepoMigrate MigrateRepoForm 

-- | @application/json@
instance Consumes RepoMigrate MimeJSON

-- | @application/json@
instance Produces RepoMigrate MimeJSON


-- *** repoMirrorSync

-- | @POST \/repos\/{owner}\/{repo}\/mirror-sync@
-- 
-- Sync a mirrored repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoMirrorSync 
  :: Owner -- ^ "owner" -  owner of the repo to sync
  -> Repo -- ^ "repo" -  name of the repo to sync
  -> GiteaRequest RepoMirrorSync MimeNoContent NoContent MimeNoContent
repoMirrorSync (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/mirror-sync"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMirrorSync  
instance Produces RepoMirrorSync MimeNoContent


-- *** repoPullRequestIsMerged

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Check if a pull request has been merged
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoPullRequestIsMerged 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoPullRequestIsMerged MimeNoContent NoContent MimeNoContent
repoPullRequestIsMerged (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoPullRequestIsMerged  
instance Produces RepoPullRequestIsMerged MimeNoContent


-- *** repoSearch

-- | @GET \/repos\/search@
-- 
-- Search for repositories
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoSearch 
  :: GiteaRequest RepoSearch MimeNoContent SearchResults MimeJSON
repoSearch =
  _mkRequest "GET" ["/repos/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSearch  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam RepoSearch Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "topic" - Limit search to repositories with keyword as topic
instance HasOptionalParam RepoSearch Topic where
  applyOptionalParam req (Topic xs) =
    req `setQuery` toQuery ("topic", Just xs)

-- | /Optional Param/ "includeDesc" - include search of keyword within repository description
instance HasOptionalParam RepoSearch IncludeDesc where
  applyOptionalParam req (IncludeDesc xs) =
    req `setQuery` toQuery ("includeDesc", Just xs)

-- | /Optional Param/ "uid" - search only for repos that the user with the given id owns or contributes to
instance HasOptionalParam RepoSearch Uid where
  applyOptionalParam req (Uid xs) =
    req `setQuery` toQuery ("uid", Just xs)

-- | /Optional Param/ "priority_owner_id" - repo owner to prioritize in the results
instance HasOptionalParam RepoSearch PriorityOwnerId where
  applyOptionalParam req (PriorityOwnerId xs) =
    req `setQuery` toQuery ("priority_owner_id", Just xs)

-- | /Optional Param/ "starredBy" - search only for repos that the user with the given id has starred
instance HasOptionalParam RepoSearch StarredBy where
  applyOptionalParam req (StarredBy xs) =
    req `setQuery` toQuery ("starredBy", Just xs)

-- | /Optional Param/ "private" - include private repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Private where
  applyOptionalParam req (Private xs) =
    req `setQuery` toQuery ("private", Just xs)

-- | /Optional Param/ "template" - include template repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Template where
  applyOptionalParam req (Template xs) =
    req `setQuery` toQuery ("template", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoSearch Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results, maximum page size is 50
instance HasOptionalParam RepoSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "mode" - type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
instance HasOptionalParam RepoSearch Mode where
  applyOptionalParam req (Mode xs) =
    req `setQuery` toQuery ("mode", Just xs)

-- | /Optional Param/ "exclusive" - if `uid` is given, search only for repos that the user owns
instance HasOptionalParam RepoSearch Exclusive where
  applyOptionalParam req (Exclusive xs) =
    req `setQuery` toQuery ("exclusive", Just xs)

-- | /Optional Param/ "sort" - sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
instance HasOptionalParam RepoSearch Sort where
  applyOptionalParam req (Sort xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "order" - sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
instance HasOptionalParam RepoSearch Order where
  applyOptionalParam req (Order xs) =
    req `setQuery` toQuery ("order", Just xs)
-- | @application/json@
instance Produces RepoSearch MimeJSON


-- *** repoSigningKey

-- | @GET \/repos\/{owner}\/{repo}\/signing-key.gpg@
-- 
-- Get signing-key.gpg for given repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoSigningKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoSigningKey MimeNoContent Text MimePlainText
repoSigningKey (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/signing-key.gpg"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSigningKey  
-- | @text/plain@
instance Produces RepoSigningKey MimePlainText


-- *** repoTestHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks\/{id}\/tests@
-- 
-- Test a push webhook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoTestHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to test
  -> GiteaRequest RepoTestHook MimeNoContent NoContent MimeNoContent
repoTestHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id,"/tests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTestHook  
instance Produces RepoTestHook MimeNoContent


-- *** repoTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times@
-- 
-- List a repo's tracked times
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoTrackedTimes 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoTrackedTimes MimeNoContent [TrackedTime] MimeJSON
repoTrackedTimes (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTrackedTimes  
-- | @application/json@
instance Produces RepoTrackedTimes MimeJSON


-- *** repoUpdateFile

-- | @PUT \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Update a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateFile 
  :: (Consumes RepoUpdateFile MimeJSON, MimeRender MimeJSON UpdateFileOptions)
  => UpdateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to update
  -> GiteaRequest RepoUpdateFile MimeJSON FileResponse MimeJSON
repoUpdateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoUpdateFile 
instance HasBodyParam RepoUpdateFile UpdateFileOptions 

-- | @application/json@
instance Consumes RepoUpdateFile MimeJSON

-- | @application/json@
instance Produces RepoUpdateFile MimeJSON


-- *** repoUpdateTopics

-- | @PUT \/repos\/{owner}\/{repo}\/topics@
-- 
-- Replace list of topics for a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
repoUpdateTopics 
  :: (Consumes RepoUpdateTopics contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoUpdateTopics contentType NoContent MimeNoContent
repoUpdateTopics _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateTopics 
instance HasBodyParam RepoUpdateTopics RepoTopicOptions 

-- | @application/json@
instance Consumes RepoUpdateTopics MimeJSON
-- | @text/plain@
instance Consumes RepoUpdateTopics MimePlainText

instance Produces RepoUpdateTopics MimeNoContent


-- *** topicSearch

-- | @GET \/topics\/search@
-- 
-- search topics via keyword
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
topicSearch 
  :: Q -- ^ "q" -  keywords to search
  -> GiteaRequest TopicSearch MimeNoContent [TopicResponse] MimeJSON
topicSearch (Q q) =
  _mkRequest "GET" ["/topics/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setQuery` toQuery ("q", Just q)

data TopicSearch  
-- | @application/json@
instance Produces TopicSearch MimeJSON


-- *** userCurrentCheckSubscription

-- | @GET \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Check if the current user is watching a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckSubscription 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentCheckSubscription MimeNoContent WatchInfo accept
userCurrentCheckSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckSubscription  
-- | @text/html@
instance Produces UserCurrentCheckSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentCheckSubscription MimeJSON


-- *** userCurrentDeleteSubscription

-- | @DELETE \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Unwatch a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteSubscription 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentDeleteSubscription MimeNoContent NoContent MimeNoContent
userCurrentDeleteSubscription (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteSubscription  
instance Produces UserCurrentDeleteSubscription MimeNoContent


-- *** userCurrentPutSubscription

-- | @PUT \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Watch a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutSubscription 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentPutSubscription MimeNoContent WatchInfo accept
userCurrentPutSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutSubscription  
-- | @text/html@
instance Produces UserCurrentPutSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentPutSubscription MimeJSON

