{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.15.9
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Repository
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Repository where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Repository

-- *** createCurrentUserRepo

-- | @POST \/user\/repos@
-- 
-- Create a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
createCurrentUserRepo 
  :: (Consumes CreateCurrentUserRepo MimeJSON)
  => GiteaRequest CreateCurrentUserRepo MimeJSON Repository MimeJSON
createCurrentUserRepo =
  _mkRequest "POST" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateCurrentUserRepo 
instance HasBodyParam CreateCurrentUserRepo CreateRepoOption 

-- | @application/json@
instance Consumes CreateCurrentUserRepo MimeJSON

-- | @application/json@
instance Produces CreateCurrentUserRepo MimeJSON


-- *** createFork

-- | @POST \/repos\/{owner}\/{repo}\/forks@
-- 
-- Fork a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
createFork 
  :: (Consumes CreateFork contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to fork
  -> Repo -- ^ "repo" -  name of the repo to fork
  -> GiteaRequest CreateFork contentType Repository MimeJSON
createFork _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateFork 
instance HasBodyParam CreateFork CreateForkOption 

-- | @application/json@
instance Consumes CreateFork MimeJSON
-- | @text/plain@
instance Consumes CreateFork MimePlainText

-- | @application/json@
instance Produces CreateFork MimeJSON


-- *** generateRepo

-- | @POST \/repos\/{template_owner}\/{template_repo}\/generate@
-- 
-- Create a repository using a template
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
generateRepo 
  :: (Consumes GenerateRepo MimeJSON)
  => TemplateOwner -- ^ "templateOwner" -  name of the template repository owner
  -> TemplateRepo -- ^ "templateRepo" -  name of the template repository
  -> GiteaRequest GenerateRepo MimeJSON Repository MimeJSON
generateRepo (TemplateOwner templateOwner) (TemplateRepo templateRepo) =
  _mkRequest "POST" ["/repos/",toPath templateOwner,"/",toPath templateRepo,"/generate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GenerateRepo 
instance HasBodyParam GenerateRepo GenerateRepoOption 

-- | @application/json@
instance Consumes GenerateRepo MimeJSON

-- | @application/json@
instance Produces GenerateRepo MimeJSON


-- *** getAnnotatedTag

-- | @GET \/repos\/{owner}\/{repo}\/git\/tags\/{sha}@
-- 
-- Gets the tag object of an annotated tag (not lightweight tags)
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
getAnnotatedTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
  -> GiteaRequest GetAnnotatedTag MimeNoContent AnnotatedTag MimeJSON
getAnnotatedTag (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/tags/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetAnnotatedTag  
-- | @application/json@
instance Produces GetAnnotatedTag MimeJSON


-- *** getBlob

-- | @GET \/repos\/{owner}\/{repo}\/git\/blobs\/{sha}@
-- 
-- Gets the blob of a repository.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
getBlob 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetBlob MimeNoContent GitBlobResponse MimeJSON
getBlob (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/blobs/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetBlob  
-- | @application/json@
instance Produces GetBlob MimeJSON


-- *** getTree

-- | @GET \/repos\/{owner}\/{repo}\/git\/trees\/{sha}@
-- 
-- Gets the tree of a repository.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
getTree 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest GetTree MimeNoContent GitTreeResponse MimeJSON
getTree (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/trees/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetTree  

-- | /Optional Param/ "recursive" - show all directories and files
instance HasOptionalParam GetTree Recursive where
  applyOptionalParam req (Recursive xs) =
    req `setQuery` toQuery ("recursive", Just xs)

-- | /Optional Param/ "page" - page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
instance HasOptionalParam GetTree Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "per_page" - number of items per page
instance HasOptionalParam GetTree PerPage where
  applyOptionalParam req (PerPage xs) =
    req `setQuery` toQuery ("per_page", Just xs)
-- | @application/json@
instance Produces GetTree MimeJSON


-- *** listForks

-- | @GET \/repos\/{owner}\/{repo}\/forks@
-- 
-- List a repository's forks
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
listForks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest ListForks MimeNoContent [Repository] MimeJSON
listForks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/forks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data ListForks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam ListForks Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam ListForks Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListForks MimeJSON


-- *** repoAddCollaborator

-- | @PUT \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Add a collaborator to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoAddCollaborator 
  :: (Consumes RepoAddCollaborator contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to add
  -> GiteaRequest RepoAddCollaborator contentType NoContent MimeNoContent
repoAddCollaborator _ (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddCollaborator 
instance HasBodyParam RepoAddCollaborator AddCollaboratorOption 

-- | @application/json@
instance Consumes RepoAddCollaborator MimeJSON
-- | @text/plain@
instance Consumes RepoAddCollaborator MimePlainText

instance Produces RepoAddCollaborator MimeNoContent


-- *** repoAddTeam

-- | @PUT \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Add a team to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoAddTeam 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoAddTeam MimeNoContent NoContent MimeNoContent
repoAddTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddTeam  
instance Produces RepoAddTeam MimeNoContent


-- *** repoAddTopc

-- | @PUT \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Add a topic to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoAddTopc 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to add
  -> GiteaRequest RepoAddTopc MimeNoContent NoContent MimeNoContent
repoAddTopc (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoAddTopc  
instance Produces RepoAddTopc MimeNoContent


-- *** repoCheckCollaborator

-- | @GET \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Check if a user is a collaborator of a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCheckCollaborator 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator
  -> GiteaRequest RepoCheckCollaborator MimeNoContent NoContent MimeNoContent
repoCheckCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCheckCollaborator  
instance Produces RepoCheckCollaborator MimeNoContent


-- *** repoCheckTeam

-- | @GET \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Check if a team is assigned to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCheckTeam 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoCheckTeam MimeNoContent Team MimeJSON
repoCheckTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCheckTeam  
-- | @application/json@
instance Produces RepoCheckTeam MimeJSON


-- *** repoCreateBranch

-- | @POST \/repos\/{owner}\/{repo}\/branches@
-- 
-- Create a branch
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateBranch 
  :: (Consumes RepoCreateBranch MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateBranch MimeJSON Branch MimeJSON
repoCreateBranch (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/branches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateBranch 
instance HasBodyParam RepoCreateBranch CreateBranchRepoOption 

-- | @application/json@
instance Consumes RepoCreateBranch MimeJSON

-- | @application/json@
instance Produces RepoCreateBranch MimeJSON


-- *** repoCreateBranchProtection

-- | @POST \/repos\/{owner}\/{repo}\/branch_protections@
-- 
-- Create a branch protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateBranchProtection 
  :: (Consumes RepoCreateBranchProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateBranchProtection MimeJSON BranchProtection MimeJSON
repoCreateBranchProtection (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateBranchProtection 
instance HasBodyParam RepoCreateBranchProtection CreateBranchProtectionOption 

-- | @application/json@
instance Consumes RepoCreateBranchProtection MimeJSON

-- | @application/json@
instance Produces RepoCreateBranchProtection MimeJSON


-- *** repoCreateFile

-- | @POST \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Create a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateFile 
  :: (Consumes RepoCreateFile MimeJSON, MimeRender MimeJSON CreateFileOptions)
  => CreateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to create
  -> GiteaRequest RepoCreateFile MimeJSON FileResponse MimeJSON
repoCreateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreateFile 
instance HasBodyParam RepoCreateFile CreateFileOptions 

-- | @application/json@
instance Consumes RepoCreateFile MimeJSON

-- | @application/json@
instance Produces RepoCreateFile MimeJSON


-- *** repoCreateHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateHook 
  :: (Consumes RepoCreateHook MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateHook MimeJSON Hook MimeJSON
repoCreateHook (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateHook 
instance HasBodyParam RepoCreateHook CreateHookOption 

-- | @application/json@
instance Consumes RepoCreateHook MimeJSON

-- | @application/json@
instance Produces RepoCreateHook MimeJSON


-- *** repoCreateKey

-- | @POST \/repos\/{owner}\/{repo}\/keys@
-- 
-- Add a key to a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateKey 
  :: (Consumes RepoCreateKey MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateKey MimeJSON DeployKey MimeJSON
repoCreateKey (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateKey 
instance HasBodyParam RepoCreateKey CreateKeyOption 

-- | @application/json@
instance Consumes RepoCreateKey MimeJSON

-- | @application/json@
instance Produces RepoCreateKey MimeJSON


-- *** repoCreatePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls@
-- 
-- Create a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreatePullRequest 
  :: (Consumes RepoCreatePullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreatePullRequest MimeJSON PullRequest MimeJSON
repoCreatePullRequest (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreatePullRequest 
instance HasBodyParam RepoCreatePullRequest CreatePullRequestOption 

-- | @application/json@
instance Consumes RepoCreatePullRequest MimeJSON

-- | @application/json@
instance Produces RepoCreatePullRequest MimeJSON


-- *** repoCreatePullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews@
-- 
-- Create a review to an pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreatePullReview 
  :: (Consumes RepoCreatePullReview contentType, MimeRender contentType CreatePullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> CreatePullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoCreatePullReview contentType PullReview MimeJSON
repoCreatePullReview _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreatePullReview 
instance HasBodyParam RepoCreatePullReview CreatePullReviewOptions 

-- | @application/json@
instance Consumes RepoCreatePullReview MimeJSON
-- | @text/plain@
instance Consumes RepoCreatePullReview MimePlainText

-- | @application/json@
instance Produces RepoCreatePullReview MimeJSON


-- *** repoCreatePullReviewRequests

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/requested_reviewers@
-- 
-- create review requests for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreatePullReviewRequests 
  :: (Consumes RepoCreatePullReviewRequests contentType, MimeRender contentType PullReviewRequestOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> PullReviewRequestOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoCreatePullReviewRequests contentType [PullReview] MimeJSON
repoCreatePullReviewRequests _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/requested_reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoCreatePullReviewRequests 
instance HasBodyParam RepoCreatePullReviewRequests PullReviewRequestOptions 

-- | @application/json@
instance Consumes RepoCreatePullReviewRequests MimeJSON
-- | @text/plain@
instance Consumes RepoCreatePullReviewRequests MimePlainText

-- | @application/json@
instance Produces RepoCreatePullReviewRequests MimeJSON


-- *** repoCreateRelease

-- | @POST \/repos\/{owner}\/{repo}\/releases@
-- 
-- Create a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateRelease 
  :: (Consumes RepoCreateRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateRelease MimeJSON Release MimeJSON
repoCreateRelease (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateRelease 
instance HasBodyParam RepoCreateRelease CreateReleaseOption 

-- | @application/json@
instance Consumes RepoCreateRelease MimeJSON

-- | @application/json@
instance Produces RepoCreateRelease MimeJSON


-- *** repoCreateReleaseAttachment

-- | @POST \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- Create a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateReleaseAttachment 
  :: (Consumes RepoCreateReleaseAttachment MimeMultipartFormData)
  => Attachment2 -- ^ "attachment" -  attachment to upload
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoCreateReleaseAttachment MimeMultipartFormData Attachment MimeJSON
repoCreateReleaseAttachment (Attachment2 attachment) (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `_addMultiFormPart` NH.partFileSource "attachment" attachment

data RepoCreateReleaseAttachment  

-- | /Optional Param/ "name" - name of the attachment
instance HasOptionalParam RepoCreateReleaseAttachment Name where
  applyOptionalParam req (Name xs) =
    req `setQuery` toQuery ("name", Just xs)

-- | @multipart/form-data@
instance Consumes RepoCreateReleaseAttachment MimeMultipartFormData

-- | @application/json@
instance Produces RepoCreateReleaseAttachment MimeJSON


-- *** repoCreateStatus

-- | @POST \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Create a commit status
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateStatus 
  :: (Consumes RepoCreateStatus contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoCreateStatus contentType CommitStatus MimeJSON
repoCreateStatus _ (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateStatus 
instance HasBodyParam RepoCreateStatus CreateStatusOption 

-- | @application/json@
instance Consumes RepoCreateStatus MimeJSON
-- | @text/plain@
instance Consumes RepoCreateStatus MimePlainText

-- | @application/json@
instance Produces RepoCreateStatus MimeJSON


-- *** repoCreateTag

-- | @POST \/repos\/{owner}\/{repo}\/tags@
-- 
-- Create a new git tag in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoCreateTag 
  :: (Consumes RepoCreateTag contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoCreateTag contentType Tag MimeJSON
repoCreateTag _ (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/tags"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoCreateTag 
instance HasBodyParam RepoCreateTag CreateTagOption 

-- | @application/json@
instance Consumes RepoCreateTag MimeJSON
-- | @text/plain@
instance Consumes RepoCreateTag MimePlainText

-- | @application/json@
instance Produces RepoCreateTag MimeJSON


-- *** repoDelete

-- | @DELETE \/repos\/{owner}\/{repo}@
-- 
-- Delete a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDelete 
  :: Owner -- ^ "owner" -  owner of the repo to delete
  -> Repo -- ^ "repo" -  name of the repo to delete
  -> GiteaRequest RepoDelete MimeNoContent NoContent MimeNoContent
repoDelete (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDelete  
instance Produces RepoDelete MimeNoContent


-- *** repoDeleteBranch

-- | @DELETE \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Delete a specific branch from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteBranch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  branch to delete
  -> GiteaRequest RepoDeleteBranch MimeNoContent NoContent MimeNoContent
repoDeleteBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteBranch  
instance Produces RepoDeleteBranch MimeNoContent


-- *** repoDeleteBranchProtection

-- | @DELETE \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Delete a specific branch protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteBranchProtection 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoDeleteBranchProtection MimeNoContent NoContent MimeNoContent
repoDeleteBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteBranchProtection  
instance Produces RepoDeleteBranchProtection MimeNoContent


-- *** repoDeleteCollaborator

-- | @DELETE \/repos\/{owner}\/{repo}\/collaborators\/{collaborator}@
-- 
-- Delete a collaborator from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteCollaborator 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Collaborator -- ^ "collaborator" -  username of the collaborator to delete
  -> GiteaRequest RepoDeleteCollaborator MimeNoContent NoContent MimeNoContent
repoDeleteCollaborator (Owner owner) (Repo repo) (Collaborator collaborator) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/collaborators/",toPath collaborator]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteCollaborator  
instance Produces RepoDeleteCollaborator MimeNoContent


-- *** repoDeleteFile

-- | @DELETE \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Delete a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteFile 
  :: (Consumes RepoDeleteFile MimeJSON, MimeRender MimeJSON DeleteFileOptions)
  => DeleteFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to delete
  -> GiteaRequest RepoDeleteFile MimeJSON FileDeleteResponse MimeJSON
repoDeleteFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDeleteFile 
instance HasBodyParam RepoDeleteFile DeleteFileOptions 

-- | @application/json@
instance Consumes RepoDeleteFile MimeJSON

-- | @application/json@
instance Produces RepoDeleteFile MimeJSON


-- *** repoDeleteGitHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Delete a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteGitHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoDeleteGitHook MimeNoContent NoContent MimeNoContent
repoDeleteGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteGitHook  
instance Produces RepoDeleteGitHook MimeNoContent


-- *** repoDeleteHook

-- | @DELETE \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Delete a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest RepoDeleteHook MimeNoContent NoContent MimeNoContent
repoDeleteHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteHook  
instance Produces RepoDeleteHook MimeNoContent


-- *** repoDeleteKey

-- | @DELETE \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Delete a key from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to delete
  -> GiteaRequest RepoDeleteKey MimeNoContent NoContent MimeNoContent
repoDeleteKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteKey  
instance Produces RepoDeleteKey MimeNoContent


-- *** repoDeletePullReview

-- | @DELETE \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Delete a specific review from a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeletePullReview 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoDeletePullReview MimeNoContent NoContent MimeNoContent
repoDeletePullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeletePullReview  
instance Produces RepoDeletePullReview MimeNoContent


-- *** repoDeletePullReviewRequests

-- | @DELETE \/repos\/{owner}\/{repo}\/pulls\/{index}\/requested_reviewers@
-- 
-- cancel review requests for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeletePullReviewRequests 
  :: (Consumes RepoDeletePullReviewRequests contentType, MimeRender contentType PullReviewRequestOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> PullReviewRequestOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoDeletePullReviewRequests contentType NoContent MimeNoContent
repoDeletePullReviewRequests _ body (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/requested_reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDeletePullReviewRequests 
instance HasBodyParam RepoDeletePullReviewRequests PullReviewRequestOptions 

-- | @application/json@
instance Consumes RepoDeletePullReviewRequests MimeJSON
-- | @text/plain@
instance Consumes RepoDeletePullReviewRequests MimePlainText

instance Produces RepoDeletePullReviewRequests MimeNoContent


-- *** repoDeleteRelease

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Delete a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteRelease 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to delete
  -> GiteaRequest RepoDeleteRelease MimeNoContent NoContent MimeNoContent
repoDeleteRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteRelease  
instance Produces RepoDeleteRelease MimeNoContent


-- *** repoDeleteReleaseAttachment

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Delete a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteReleaseAttachment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to delete
  -> GiteaRequest RepoDeleteReleaseAttachment MimeNoContent NoContent MimeNoContent
repoDeleteReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteReleaseAttachment  
instance Produces RepoDeleteReleaseAttachment MimeNoContent


-- *** repoDeleteReleaseByTag

-- | @DELETE \/repos\/{owner}\/{repo}\/releases\/tags\/{tag}@
-- 
-- Delete a release by tag name
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteReleaseByTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  tag name of the release to delete
  -> GiteaRequest RepoDeleteReleaseByTag MimeNoContent NoContent MimeNoContent
repoDeleteReleaseByTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/releases/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteReleaseByTag  
instance Produces RepoDeleteReleaseByTag MimeNoContent


-- *** repoDeleteTag

-- | @DELETE \/repos\/{owner}\/{repo}\/tags\/{tag}@
-- 
-- Delete a repository's tag by name
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  name of tag to delete
  -> GiteaRequest RepoDeleteTag MimeNoContent NoContent MimeNoContent
repoDeleteTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTag  
instance Produces RepoDeleteTag MimeNoContent


-- *** repoDeleteTeam

-- | @DELETE \/repos\/{owner}\/{repo}\/teams\/{team}@
-- 
-- Delete a team from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteTeam 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Team2 -- ^ "team" -  team name
  -> GiteaRequest RepoDeleteTeam MimeNoContent NoContent MimeNoContent
repoDeleteTeam (Owner owner) (Repo repo) (Team2 team) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/teams/",toPath team]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTeam  
instance Produces RepoDeleteTeam MimeNoContent


-- *** repoDeleteTopic

-- | @DELETE \/repos\/{owner}\/{repo}\/topics\/{topic}@
-- 
-- Delete a topic from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDeleteTopic 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> TopicText -- ^ "topic" -  name of the topic to delete
  -> GiteaRequest RepoDeleteTopic MimeNoContent NoContent MimeNoContent
repoDeleteTopic (Owner owner) (Repo repo) (TopicText topic) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/topics/",toPath topic]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDeleteTopic  
instance Produces RepoDeleteTopic MimeNoContent


-- *** repoDismissPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/dismissals@
-- 
-- Dismiss a review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDismissPullReview 
  :: (Consumes RepoDismissPullReview contentType, MimeRender contentType DismissPullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> DismissPullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoDismissPullReview contentType PullReview MimeJSON
repoDismissPullReview _ body (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/dismissals"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoDismissPullReview 
instance HasBodyParam RepoDismissPullReview DismissPullReviewOptions 

-- | @application/json@
instance Consumes RepoDismissPullReview MimeJSON
-- | @text/plain@
instance Consumes RepoDismissPullReview MimePlainText

-- | @application/json@
instance Produces RepoDismissPullReview MimeJSON


-- *** repoDownloadPullDiff

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}.diff@
-- 
-- Get a pull request diff
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDownloadPullDiff 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoDownloadPullDiff MimeNoContent Text MimePlainText
repoDownloadPullDiff (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,".diff"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDownloadPullDiff  
-- | @text/plain@
instance Produces RepoDownloadPullDiff MimePlainText


-- *** repoDownloadPullPatch

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}.patch@
-- 
-- Get a pull request patch file
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoDownloadPullPatch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoDownloadPullPatch MimeNoContent Text MimePlainText
repoDownloadPullPatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,".patch"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoDownloadPullPatch  
-- | @text/plain@
instance Produces RepoDownloadPullPatch MimePlainText


-- *** repoEdit

-- | @PATCH \/repos\/{owner}\/{repo}@
-- 
-- Edit a repository's properties. Only fields that are set will be changed.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEdit 
  :: (Consumes RepoEdit contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo to edit
  -> Repo -- ^ "repo" -  name of the repo to edit
  -> GiteaRequest RepoEdit contentType Repository MimeJSON
repoEdit _ (Owner owner) (Repo repo) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEdit 

-- | /Body Param/ "body" - Properties of a repo that you can edit
instance HasBodyParam RepoEdit EditRepoOption 

-- | @application/json@
instance Consumes RepoEdit MimeJSON
-- | @text/plain@
instance Consumes RepoEdit MimePlainText

-- | @application/json@
instance Produces RepoEdit MimeJSON


-- *** repoEditBranchProtection

-- | @PATCH \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Edit a branch protections for a repository. Only fields that are set will be changed
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditBranchProtection 
  :: (Consumes RepoEditBranchProtection MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoEditBranchProtection MimeJSON BranchProtection MimeJSON
repoEditBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditBranchProtection 
instance HasBodyParam RepoEditBranchProtection EditBranchProtectionOption 

-- | @application/json@
instance Consumes RepoEditBranchProtection MimeJSON

-- | @application/json@
instance Produces RepoEditBranchProtection MimeJSON


-- *** repoEditGitHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Edit a Git hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditGitHook 
  :: (Consumes RepoEditGitHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoEditGitHook contentType GitHook MimeJSON
repoEditGitHook _ (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditGitHook 
instance HasBodyParam RepoEditGitHook EditGitHookOption 

-- | @application/json@
instance Consumes RepoEditGitHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditGitHook MimePlainText

-- | @application/json@
instance Produces RepoEditGitHook MimeJSON


-- *** repoEditHook

-- | @PATCH \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Edit a hook in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditHook 
  :: (Consumes RepoEditHook contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  index of the hook
  -> GiteaRequest RepoEditHook contentType Hook MimeJSON
repoEditHook _ (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditHook 
instance HasBodyParam RepoEditHook EditHookOption 

-- | @application/json@
instance Consumes RepoEditHook MimeJSON
-- | @text/plain@
instance Consumes RepoEditHook MimePlainText

-- | @application/json@
instance Produces RepoEditHook MimeJSON


-- *** repoEditPullRequest

-- | @PATCH \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditPullRequest 
  :: (Consumes RepoEditPullRequest MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to edit
  -> GiteaRequest RepoEditPullRequest MimeJSON PullRequest MimeJSON
repoEditPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditPullRequest 
instance HasBodyParam RepoEditPullRequest EditPullRequestOption 

-- | @application/json@
instance Consumes RepoEditPullRequest MimeJSON

-- | @application/json@
instance Produces RepoEditPullRequest MimeJSON


-- *** repoEditRelease

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Update a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditRelease 
  :: (Consumes RepoEditRelease MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to edit
  -> GiteaRequest RepoEditRelease MimeJSON Release MimeJSON
repoEditRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditRelease 
instance HasBodyParam RepoEditRelease EditReleaseOption 

-- | @application/json@
instance Consumes RepoEditRelease MimeJSON

-- | @application/json@
instance Produces RepoEditRelease MimeJSON


-- *** repoEditReleaseAttachment

-- | @PATCH \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Edit a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoEditReleaseAttachment 
  :: (Consumes RepoEditReleaseAttachment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to edit
  -> GiteaRequest RepoEditReleaseAttachment MimeJSON Attachment MimeJSON
repoEditReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoEditReleaseAttachment 
instance HasBodyParam RepoEditReleaseAttachment EditAttachmentOptions 

-- | @application/json@
instance Consumes RepoEditReleaseAttachment MimeJSON

-- | @application/json@
instance Produces RepoEditReleaseAttachment MimeJSON


-- *** repoGet

-- | @GET \/repos\/{owner}\/{repo}@
-- 
-- Get a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGet 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGet MimeNoContent Repository MimeJSON
repoGet (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGet  
-- | @application/json@
instance Produces RepoGet MimeJSON


-- *** repoGetAllCommits

-- | @GET \/repos\/{owner}\/{repo}\/commits@
-- 
-- Get a list of all commits from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetAllCommits 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetAllCommits MimeNoContent [Commit] MimeJSON
repoGetAllCommits (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetAllCommits  

-- | /Optional Param/ "sha" - SHA or branch to start listing commits from (usually 'master')
instance HasOptionalParam RepoGetAllCommits Sha where
  applyOptionalParam req (Sha xs) =
    req `setQuery` toQuery ("sha", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetAllCommits Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetAllCommits Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetAllCommits MimeJSON


-- *** repoGetArchive

-- | @GET \/repos\/{owner}\/{repo}\/archive\/{archive}@
-- 
-- Get an archive of a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetArchive 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Archive -- ^ "archive" -  the git reference for download with attached archive format (e.g. master.zip)
  -> GiteaRequest RepoGetArchive MimeNoContent NoContent MimeNoContent
repoGetArchive (Owner owner) (Repo repo) (Archive archive) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/archive/",toPath archive]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetArchive  
instance Produces RepoGetArchive MimeNoContent


-- *** repoGetAssignees

-- | @GET \/repos\/{owner}\/{repo}\/assignees@
-- 
-- Return all users that have write access and can be assigned to issues
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetAssignees 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetAssignees MimeNoContent [User] MimeJSON
repoGetAssignees (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/assignees"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetAssignees  
-- | @application/json@
instance Produces RepoGetAssignees MimeJSON


-- *** repoGetBranch

-- | @GET \/repos\/{owner}\/{repo}\/branches\/{branch}@
-- 
-- Retrieve a specific branch from a repository, including its effective branch protection
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetBranch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Branch2 -- ^ "branch" -  branch to get
  -> GiteaRequest RepoGetBranch MimeNoContent Branch MimeJSON
repoGetBranch (Owner owner) (Repo repo) (Branch2 branch) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches/",toPath branch]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetBranch  
-- | @application/json@
instance Produces RepoGetBranch MimeJSON


-- *** repoGetBranchProtection

-- | @GET \/repos\/{owner}\/{repo}\/branch_protections\/{name}@
-- 
-- Get a specific branch protection for the repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetBranchProtection 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Name -- ^ "name" -  name of protected branch
  -> GiteaRequest RepoGetBranchProtection MimeNoContent BranchProtection MimeJSON
repoGetBranchProtection (Owner owner) (Repo repo) (Name name) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetBranchProtection  
-- | @application/json@
instance Produces RepoGetBranchProtection MimeJSON


-- *** repoGetByID

-- | @GET \/repositories\/{id}@
-- 
-- Get a repository by id
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetByID 
  :: Id -- ^ "id" -  id of the repo to get
  -> GiteaRequest RepoGetByID MimeNoContent Repository MimeJSON
repoGetByID (Id id) =
  _mkRequest "GET" ["/repositories/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetByID  
-- | @application/json@
instance Produces RepoGetByID MimeJSON


-- *** repoGetCombinedStatusByRef

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{ref}\/status@
-- 
-- Get a commit's combined status, by branch/tag/commit reference
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetCombinedStatusByRef 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  name of branch/tag/commit
  -> GiteaRequest RepoGetCombinedStatusByRef MimeNoContent CombinedStatus MimeJSON
repoGetCombinedStatusByRef (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath ref,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetCombinedStatusByRef  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetCombinedStatusByRef Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetCombinedStatusByRef Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetCombinedStatusByRef MimeJSON


-- *** repoGetContents

-- | @GET \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetContents 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the dir, file, symlink or submodule in the repo
  -> GiteaRequest RepoGetContents MimeNoContent ContentsResponse MimeJSON
repoGetContents (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContents  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repositorys default branch (usually master)
instance HasOptionalParam RepoGetContents Ref where
  applyOptionalParam req (Ref xs) =
    req `setQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContents MimeJSON


-- *** repoGetContentsList

-- | @GET \/repos\/{owner}\/{repo}\/contents@
-- 
-- Gets the metadata of all the entries of the root dir
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetContentsList 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetContentsList MimeNoContent [ContentsResponse] MimeJSON
repoGetContentsList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/contents"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetContentsList  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repositorys default branch (usually master)
instance HasOptionalParam RepoGetContentsList Ref where
  applyOptionalParam req (Ref xs) =
    req `setQuery` toQuery ("ref", Just xs)
-- | @application/json@
instance Produces RepoGetContentsList MimeJSON


-- *** repoGetEditorConfig

-- | @GET \/repos\/{owner}\/{repo}\/editorconfig\/{filepath}@
-- 
-- Get the EditorConfig definitions of a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetEditorConfig 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  filepath of file to get
  -> GiteaRequest RepoGetEditorConfig MimeNoContent NoContent MimeNoContent
repoGetEditorConfig (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/editorconfig/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetEditorConfig  
instance Produces RepoGetEditorConfig MimeNoContent


-- *** repoGetGitHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git\/{id}@
-- 
-- Get a Git hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetGitHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetGitHook MimeNoContent GitHook MimeJSON
repoGetGitHook (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetGitHook  
-- | @application/json@
instance Produces RepoGetGitHook MimeJSON


-- *** repoGetHook

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest RepoGetHook MimeNoContent Hook MimeJSON
repoGetHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetHook  
-- | @application/json@
instance Produces RepoGetHook MimeJSON


-- *** repoGetIssueTemplates

-- | @GET \/repos\/{owner}\/{repo}\/issue_templates@
-- 
-- Get available issue templates for a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetIssueTemplates 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetIssueTemplates MimeNoContent [IssueTemplate] MimeJSON
repoGetIssueTemplates (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issue_templates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetIssueTemplates  
-- | @application/json@
instance Produces RepoGetIssueTemplates MimeJSON


-- *** repoGetKey

-- | @GET \/repos\/{owner}\/{repo}\/keys\/{id}@
-- 
-- Get a repository's key by id
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the key to get
  -> GiteaRequest RepoGetKey MimeNoContent DeployKey MimeJSON
repoGetKey (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetKey  
-- | @application/json@
instance Produces RepoGetKey MimeJSON


-- *** repoGetLanguages

-- | @GET \/repos\/{owner}\/{repo}\/languages@
-- 
-- Get languages and number of bytes of code written
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetLanguages 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetLanguages MimeNoContent ((Map.Map String Integer)) MimeJSON
repoGetLanguages (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/languages"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetLanguages  
-- | @application/json@
instance Produces RepoGetLanguages MimeJSON


-- *** repoGetPullRequest

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}@
-- 
-- Get a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetPullRequest 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequest MimeNoContent PullRequest MimeJSON
repoGetPullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequest  
-- | @application/json@
instance Produces RepoGetPullRequest MimeJSON


-- *** repoGetPullRequestCommits

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/commits@
-- 
-- Get commits for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetPullRequestCommits 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoGetPullRequestCommits MimeNoContent [Commit] MimeJSON
repoGetPullRequestCommits (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/commits"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullRequestCommits  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoGetPullRequestCommits Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoGetPullRequestCommits Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoGetPullRequestCommits MimeJSON


-- *** repoGetPullReview

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Get a specific review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetPullReview 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoGetPullReview MimeNoContent PullReview MimeJSON
repoGetPullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullReview  
-- | @application/json@
instance Produces RepoGetPullReview MimeJSON


-- *** repoGetPullReviewComments

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/comments@
-- 
-- Get a specific review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetPullReviewComments 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoGetPullReviewComments MimeNoContent [PullReviewComment] MimeJSON
repoGetPullReviewComments (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetPullReviewComments  
-- | @application/json@
instance Produces RepoGetPullReviewComments MimeJSON


-- *** repoGetRawFile

-- | @GET \/repos\/{owner}\/{repo}\/raw\/{filepath}@
-- 
-- Get a file from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetRawFile 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  filepath of the file to get
  -> GiteaRequest RepoGetRawFile MimeNoContent NoContent MimeNoContent
repoGetRawFile (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/raw/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRawFile  

-- | /Optional Param/ "ref" - The name of the commit/branch/tag. Default the repositorys default branch (usually master)
instance HasOptionalParam RepoGetRawFile Ref where
  applyOptionalParam req (Ref xs) =
    req `setQuery` toQuery ("ref", Just xs)
instance Produces RepoGetRawFile MimeNoContent


-- *** repoGetRelease

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}@
-- 
-- Get a release
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetRelease 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release to get
  -> GiteaRequest RepoGetRelease MimeNoContent Release MimeJSON
repoGetRelease (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetRelease  
-- | @application/json@
instance Produces RepoGetRelease MimeJSON


-- *** repoGetReleaseAttachment

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets\/{attachment_id}@
-- 
-- Get a release attachment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetReleaseAttachment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to get
  -> GiteaRequest RepoGetReleaseAttachment MimeNoContent Attachment MimeJSON
repoGetReleaseAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReleaseAttachment  
-- | @application/json@
instance Produces RepoGetReleaseAttachment MimeJSON


-- *** repoGetReleaseByTag

-- | @GET \/repos\/{owner}\/{repo}\/releases\/tags\/{tag}@
-- 
-- Get a release by tag name
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetReleaseByTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  tag name of the release to get
  -> GiteaRequest RepoGetReleaseByTag MimeNoContent Release MimeJSON
repoGetReleaseByTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReleaseByTag  
-- | @application/json@
instance Produces RepoGetReleaseByTag MimeJSON


-- *** repoGetReviewers

-- | @GET \/repos\/{owner}\/{repo}\/reviewers@
-- 
-- Return all users that can be requested to review in this repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetReviewers 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoGetReviewers MimeNoContent [User] MimeJSON
repoGetReviewers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/reviewers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetReviewers  
-- | @application/json@
instance Produces RepoGetReviewers MimeJSON


-- *** repoGetSingleCommit

-- | @GET \/repos\/{owner}\/{repo}\/git\/commits\/{sha}@
-- 
-- Get a single commit from a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetSingleCommit 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  a git ref or commit sha
  -> GiteaRequest RepoGetSingleCommit MimeNoContent Commit MimeJSON
repoGetSingleCommit (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/commits/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetSingleCommit  
-- | @application/json@
instance Produces RepoGetSingleCommit MimeJSON


-- *** repoGetTag

-- | @GET \/repos\/{owner}\/{repo}\/tags\/{tag}@
-- 
-- Get the tag of a repository by tag name
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoGetTag 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Tag2 -- ^ "tag" -  name of tag
  -> GiteaRequest RepoGetTag MimeNoContent Tag MimeJSON
repoGetTag (Owner owner) (Repo repo) (Tag2 tag) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tags/",toPath tag]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoGetTag  
-- | @application/json@
instance Produces RepoGetTag MimeJSON


-- *** repoListAllGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListAllGitRefs 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListAllGitRefs MimeNoContent [Reference] MimeJSON
repoListAllGitRefs (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListAllGitRefs  
-- | @application/json@
instance Produces RepoListAllGitRefs MimeJSON


-- *** repoListBranchProtection

-- | @GET \/repos\/{owner}\/{repo}\/branch_protections@
-- 
-- List branch protections for a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListBranchProtection 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListBranchProtection MimeNoContent [BranchProtection] MimeJSON
repoListBranchProtection (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branch_protections"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListBranchProtection  
-- | @application/json@
instance Produces RepoListBranchProtection MimeJSON


-- *** repoListBranches

-- | @GET \/repos\/{owner}\/{repo}\/branches@
-- 
-- List a repository's branches
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListBranches 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListBranches MimeNoContent [Branch] MimeJSON
repoListBranches (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/branches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListBranches  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListBranches Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListBranches Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListBranches MimeJSON


-- *** repoListCollaborators

-- | @GET \/repos\/{owner}\/{repo}\/collaborators@
-- 
-- List a repository's collaborators
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListCollaborators 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListCollaborators MimeNoContent [User] MimeJSON
repoListCollaborators (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/collaborators"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListCollaborators  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListCollaborators Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListCollaborators Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListCollaborators MimeJSON


-- *** repoListGitHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks\/git@
-- 
-- List the Git hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListGitHooks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListGitHooks MimeNoContent [GitHook] MimeJSON
repoListGitHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks/git"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitHooks  
-- | @application/json@
instance Produces RepoListGitHooks MimeJSON


-- *** repoListGitRefs

-- | @GET \/repos\/{owner}\/{repo}\/git\/refs\/{ref}@
-- 
-- Get specified ref or filtered repository's refs
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListGitRefs 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  part or full name of the ref
  -> GiteaRequest RepoListGitRefs MimeNoContent [Reference] MimeJSON
repoListGitRefs (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/git/refs/",toPath ref]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListGitRefs  
-- | @application/json@
instance Produces RepoListGitRefs MimeJSON


-- *** repoListHooks

-- | @GET \/repos\/{owner}\/{repo}\/hooks@
-- 
-- List the hooks in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListHooks 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListHooks MimeNoContent [Hook] MimeJSON
repoListHooks (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListHooks Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListHooks MimeJSON


-- *** repoListKeys

-- | @GET \/repos\/{owner}\/{repo}\/keys@
-- 
-- List a repository's keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListKeys 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListKeys MimeNoContent [DeployKey] MimeJSON
repoListKeys (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListKeys  

-- | /Optional Param/ "key_id" - the key_id to search for
instance HasOptionalParam RepoListKeys KeyId where
  applyOptionalParam req (KeyId xs) =
    req `setQuery` toQuery ("key_id", Just xs)

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam RepoListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `setQuery` toQuery ("fingerprint", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListKeys Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListKeys MimeJSON


-- *** repoListPullRequests

-- | @GET \/repos\/{owner}\/{repo}\/pulls@
-- 
-- List a repo's pull requests
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListPullRequests 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListPullRequests MimeNoContent [PullRequest] MimeJSON
repoListPullRequests (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPullRequests  

-- | /Optional Param/ "state" - State of pull request: open or closed (optional)
instance HasOptionalParam RepoListPullRequests State3 where
  applyOptionalParam req (State3 xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "sort" - Type of sort
instance HasOptionalParam RepoListPullRequests Sort3 where
  applyOptionalParam req (Sort3 xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "milestone" - ID of the milestone
instance HasOptionalParam RepoListPullRequests Milestone2 where
  applyOptionalParam req (Milestone2 xs) =
    req `setQuery` toQuery ("milestone", Just xs)

-- | /Optional Param/ "labels" - Label IDs
instance HasOptionalParam RepoListPullRequests LabelsInteger where
  applyOptionalParam req (LabelsInteger xs) =
    req `setQuery` toQueryColl MultiParamArray ("labels", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListPullRequests Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListPullRequests Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListPullRequests MimeJSON


-- *** repoListPullReviews

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews@
-- 
-- List all reviews for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListPullReviews 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoListPullReviews MimeNoContent [PullReview] MimeJSON
repoListPullReviews (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListPullReviews  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListPullReviews Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListPullReviews Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListPullReviews MimeJSON


-- *** repoListReleaseAttachments

-- | @GET \/repos\/{owner}\/{repo}\/releases\/{id}\/assets@
-- 
-- List release's attachments
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListReleaseAttachments 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the release
  -> GiteaRequest RepoListReleaseAttachments MimeNoContent [Attachment] MimeJSON
repoListReleaseAttachments (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleaseAttachments  
-- | @application/json@
instance Produces RepoListReleaseAttachments MimeJSON


-- *** repoListReleases

-- | @GET \/repos\/{owner}\/{repo}\/releases@
-- 
-- List a repo's releases
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListReleases 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListReleases MimeNoContent [Release] MimeJSON
repoListReleases (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/releases"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListReleases  

-- | /Optional Param/ "draft" - filter (exclude / include) drafts, if you dont have repo write access none will show
instance HasOptionalParam RepoListReleases Draft where
  applyOptionalParam req (Draft xs) =
    req `setQuery` toQuery ("draft", Just xs)

-- | /Optional Param/ "pre-release" - filter (exclude / include) pre-releases
instance HasOptionalParam RepoListReleases PreRelease where
  applyOptionalParam req (PreRelease xs) =
    req `setQuery` toQuery ("pre-release", Just xs)

-- | /Optional Param/ "per_page" - page size of results, deprecated - use limit
instance HasOptionalParam RepoListReleases PerPage where
  applyOptionalParam req (PerPage xs) =
    req `setQuery` toQuery ("per_page", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListReleases Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListReleases Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListReleases MimeJSON


-- *** repoListStargazers

-- | @GET \/repos\/{owner}\/{repo}\/stargazers@
-- 
-- List a repo's stargazers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListStargazers 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListStargazers MimeNoContent [User] MimeJSON
repoListStargazers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/stargazers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStargazers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStargazers Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStargazers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStargazers MimeJSON


-- *** repoListStatuses

-- | @GET \/repos\/{owner}\/{repo}\/statuses\/{sha}@
-- 
-- Get a commit's statuses
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListStatuses 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Sha -- ^ "sha" -  sha of the commit
  -> GiteaRequest RepoListStatuses MimeNoContent [CommitStatus] MimeJSON
repoListStatuses (Owner owner) (Repo repo) (Sha sha) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/statuses/",toPath sha]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStatuses  

-- | /Optional Param/ "sort" - type of sort
instance HasOptionalParam RepoListStatuses Sort2 where
  applyOptionalParam req (Sort2 xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "state" - type of state
instance HasOptionalParam RepoListStatuses State2 where
  applyOptionalParam req (State2 xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStatuses Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStatuses Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStatuses MimeJSON


-- *** repoListStatusesByRef

-- | @GET \/repos\/{owner}\/{repo}\/commits\/{ref}\/statuses@
-- 
-- Get a commit's statuses, by branch/tag/commit reference
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListStatusesByRef 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Ref -- ^ "ref" -  name of branch/tag/commit
  -> GiteaRequest RepoListStatusesByRef MimeNoContent [CommitStatus] MimeJSON
repoListStatusesByRef (Owner owner) (Repo repo) (Ref ref) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/commits/",toPath ref,"/statuses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListStatusesByRef  

-- | /Optional Param/ "sort" - type of sort
instance HasOptionalParam RepoListStatusesByRef Sort2 where
  applyOptionalParam req (Sort2 xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "state" - type of state
instance HasOptionalParam RepoListStatusesByRef State2 where
  applyOptionalParam req (State2 xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListStatusesByRef Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListStatusesByRef Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListStatusesByRef MimeJSON


-- *** repoListSubscribers

-- | @GET \/repos\/{owner}\/{repo}\/subscribers@
-- 
-- List a repo's watchers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListSubscribers 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListSubscribers MimeNoContent [User] MimeJSON
repoListSubscribers (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscribers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListSubscribers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListSubscribers Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListSubscribers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListSubscribers MimeJSON


-- *** repoListTags

-- | @GET \/repos\/{owner}\/{repo}\/tags@
-- 
-- List a repository's tags
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListTags 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTags MimeNoContent [Tag] MimeJSON
repoListTags (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/tags"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTags  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListTags Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results, default maximum page size is 50
instance HasOptionalParam RepoListTags Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListTags MimeJSON


-- *** repoListTeams

-- | @GET \/repos\/{owner}\/{repo}\/teams@
-- 
-- List a repository's teams
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListTeams 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTeams MimeNoContent [Team] MimeJSON
repoListTeams (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTeams  
-- | @application/json@
instance Produces RepoListTeams MimeJSON


-- *** repoListTopics

-- | @GET \/repos\/{owner}\/{repo}\/topics@
-- 
-- Get list of topics that a repository has
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoListTopics 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoListTopics MimeNoContent TopicName MimeJSON
repoListTopics (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoListTopics  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoListTopics Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoListTopics Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoListTopics MimeJSON


-- *** repoMergePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Merge a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoMergePullRequest 
  :: (Consumes RepoMergePullRequest contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to merge
  -> GiteaRequest RepoMergePullRequest contentType NoContent MimeNoContent
repoMergePullRequest _ (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMergePullRequest 
instance HasBodyParam RepoMergePullRequest MergePullRequestOption 

-- | @application/json@
instance Consumes RepoMergePullRequest MimeJSON
-- | @text/plain@
instance Consumes RepoMergePullRequest MimePlainText

instance Produces RepoMergePullRequest MimeNoContent


-- *** repoMigrate

-- | @POST \/repos\/migrate@
-- 
-- Migrate a remote git repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoMigrate 
  :: (Consumes RepoMigrate MimeJSON)
  => GiteaRequest RepoMigrate MimeJSON Repository MimeJSON
repoMigrate =
  _mkRequest "POST" ["/repos/migrate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMigrate 
instance HasBodyParam RepoMigrate MigrateRepoOptions 

-- | @application/json@
instance Consumes RepoMigrate MimeJSON

-- | @application/json@
instance Produces RepoMigrate MimeJSON


-- *** repoMirrorSync

-- | @POST \/repos\/{owner}\/{repo}\/mirror-sync@
-- 
-- Sync a mirrored repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoMirrorSync 
  :: Owner -- ^ "owner" -  owner of the repo to sync
  -> Repo -- ^ "repo" -  name of the repo to sync
  -> GiteaRequest RepoMirrorSync MimeNoContent NoContent MimeNoContent
repoMirrorSync (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/mirror-sync"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoMirrorSync  
instance Produces RepoMirrorSync MimeNoContent


-- *** repoPullRequestIsMerged

-- | @GET \/repos\/{owner}\/{repo}\/pulls\/{index}\/merge@
-- 
-- Check if a pull request has been merged
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoPullRequestIsMerged 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> GiteaRequest RepoPullRequestIsMerged MimeNoContent NoContent MimeNoContent
repoPullRequestIsMerged (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/merge"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoPullRequestIsMerged  
instance Produces RepoPullRequestIsMerged MimeNoContent


-- *** repoSearch

-- | @GET \/repos\/search@
-- 
-- Search for repositories
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoSearch 
  :: GiteaRequest RepoSearch MimeNoContent SearchResults MimeJSON
repoSearch =
  _mkRequest "GET" ["/repos/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSearch  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam RepoSearch Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "topic" - Limit search to repositories with keyword as topic
instance HasOptionalParam RepoSearch Topic where
  applyOptionalParam req (Topic xs) =
    req `setQuery` toQuery ("topic", Just xs)

-- | /Optional Param/ "includeDesc" - include search of keyword within repository description
instance HasOptionalParam RepoSearch IncludeDesc where
  applyOptionalParam req (IncludeDesc xs) =
    req `setQuery` toQuery ("includeDesc", Just xs)

-- | /Optional Param/ "uid" - search only for repos that the user with the given id owns or contributes to
instance HasOptionalParam RepoSearch Uid where
  applyOptionalParam req (Uid xs) =
    req `setQuery` toQuery ("uid", Just xs)

-- | /Optional Param/ "priority_owner_id" - repo owner to prioritize in the results
instance HasOptionalParam RepoSearch PriorityOwnerId where
  applyOptionalParam req (PriorityOwnerId xs) =
    req `setQuery` toQuery ("priority_owner_id", Just xs)

-- | /Optional Param/ "team_id" - search only for repos that belong to the given team id
instance HasOptionalParam RepoSearch TeamId where
  applyOptionalParam req (TeamId xs) =
    req `setQuery` toQuery ("team_id", Just xs)

-- | /Optional Param/ "starredBy" - search only for repos that the user with the given id has starred
instance HasOptionalParam RepoSearch StarredBy where
  applyOptionalParam req (StarredBy xs) =
    req `setQuery` toQuery ("starredBy", Just xs)

-- | /Optional Param/ "private" - include private repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Private where
  applyOptionalParam req (Private xs) =
    req `setQuery` toQuery ("private", Just xs)

-- | /Optional Param/ "is_private" - show only pubic, private or all repositories (defaults to all)
instance HasOptionalParam RepoSearch IsPrivate where
  applyOptionalParam req (IsPrivate xs) =
    req `setQuery` toQuery ("is_private", Just xs)

-- | /Optional Param/ "template" - include template repositories this user has access to (defaults to true)
instance HasOptionalParam RepoSearch Template where
  applyOptionalParam req (Template xs) =
    req `setQuery` toQuery ("template", Just xs)

-- | /Optional Param/ "archived" - show only archived, non-archived or all repositories (defaults to all)
instance HasOptionalParam RepoSearch Archived where
  applyOptionalParam req (Archived xs) =
    req `setQuery` toQuery ("archived", Just xs)

-- | /Optional Param/ "mode" - type of repository to search for. Supported values are \"fork\", \"source\", \"mirror\" and \"collaborative\"
instance HasOptionalParam RepoSearch Mode where
  applyOptionalParam req (Mode xs) =
    req `setQuery` toQuery ("mode", Just xs)

-- | /Optional Param/ "exclusive" - if `uid` is given, search only for repos that the user owns
instance HasOptionalParam RepoSearch Exclusive where
  applyOptionalParam req (Exclusive xs) =
    req `setQuery` toQuery ("exclusive", Just xs)

-- | /Optional Param/ "sort" - sort repos by attribute. Supported values are \"alpha\", \"created\", \"updated\", \"size\", and \"id\". Default is \"alpha\"
instance HasOptionalParam RepoSearch Sort where
  applyOptionalParam req (Sort xs) =
    req `setQuery` toQuery ("sort", Just xs)

-- | /Optional Param/ "order" - sort order, either \"asc\" (ascending) or \"desc\" (descending). Default is \"asc\", ignored if \"sort\" is not specified.
instance HasOptionalParam RepoSearch Order where
  applyOptionalParam req (Order xs) =
    req `setQuery` toQuery ("order", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoSearch Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoSearch MimeJSON


-- *** repoSigningKey

-- | @GET \/repos\/{owner}\/{repo}\/signing-key.gpg@
-- 
-- Get signing-key.gpg for given repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoSigningKey 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoSigningKey MimeNoContent Text MimePlainText
repoSigningKey (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/signing-key.gpg"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoSigningKey  
-- | @text/plain@
instance Produces RepoSigningKey MimePlainText


-- *** repoSubmitPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}@
-- 
-- Submit a pending review to an pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoSubmitPullReview 
  :: (Consumes RepoSubmitPullReview contentType, MimeRender contentType SubmitPullReviewOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> SubmitPullReviewOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoSubmitPullReview contentType PullReview MimeJSON
repoSubmitPullReview _ body (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoSubmitPullReview 
instance HasBodyParam RepoSubmitPullReview SubmitPullReviewOptions 

-- | @application/json@
instance Consumes RepoSubmitPullReview MimeJSON
-- | @text/plain@
instance Consumes RepoSubmitPullReview MimePlainText

-- | @application/json@
instance Produces RepoSubmitPullReview MimeJSON


-- *** repoTestHook

-- | @POST \/repos\/{owner}\/{repo}\/hooks\/{id}\/tests@
-- 
-- Test a push webhook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoTestHook 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the hook to test
  -> GiteaRequest RepoTestHook MimeNoContent NoContent MimeNoContent
repoTestHook (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/hooks/",toPath id,"/tests"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTestHook  
instance Produces RepoTestHook MimeNoContent


-- *** repoTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times@
-- 
-- List a repo's tracked times
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoTrackedTimes 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoTrackedTimes MimeNoContent [TrackedTime] MimeJSON
repoTrackedTimes (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoTrackedTimes  

-- | /Optional Param/ "user" - optional filter by user (available for issue managers)
instance HasOptionalParam RepoTrackedTimes User2 where
  applyOptionalParam req (User2 xs) =
    req `setQuery` toQuery ("user", Just xs)

-- | /Optional Param/ "since" - Only show times updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam RepoTrackedTimes Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show times updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam RepoTrackedTimes Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam RepoTrackedTimes Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam RepoTrackedTimes Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces RepoTrackedTimes MimeJSON


-- *** repoTransfer

-- | @POST \/repos\/{owner}\/{repo}\/transfer@
-- 
-- Transfer a repo ownership
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoTransfer 
  :: (Consumes RepoTransfer contentType, MimeRender contentType TransferRepoOption)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> TransferRepoOption -- ^ "body" -  Transfer Options
  -> Owner -- ^ "owner" -  owner of the repo to transfer
  -> Repo -- ^ "repo" -  name of the repo to transfer
  -> GiteaRequest RepoTransfer contentType Repository MimeJSON
repoTransfer _ body (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/transfer"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoTransfer 

-- | /Body Param/ "body" - Transfer Options
instance HasBodyParam RepoTransfer TransferRepoOption 

-- | @application/json@
instance Consumes RepoTransfer MimeJSON
-- | @text/plain@
instance Consumes RepoTransfer MimePlainText

-- | @application/json@
instance Produces RepoTransfer MimeJSON


-- *** repoUnDismissPullReview

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/reviews\/{id}\/undismissals@
-- 
-- Cancel to dismiss a review for a pull request
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoUnDismissPullReview 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request
  -> Id -- ^ "id" -  id of the review
  -> GiteaRequest RepoUnDismissPullReview MimeNoContent PullReview MimeJSON
repoUnDismissPullReview (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/reviews/",toPath id,"/undismissals"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUnDismissPullReview  
-- | @application/json@
instance Produces RepoUnDismissPullReview MimeJSON


-- *** repoUpdateFile

-- | @PUT \/repos\/{owner}\/{repo}\/contents\/{filepath}@
-- 
-- Update a file in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoUpdateFile 
  :: (Consumes RepoUpdateFile MimeJSON, MimeRender MimeJSON UpdateFileOptions)
  => UpdateFileOptions -- ^ "body"
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Filepath -- ^ "filepath" -  path of the file to update
  -> GiteaRequest RepoUpdateFile MimeJSON FileResponse MimeJSON
repoUpdateFile body (Owner owner) (Repo repo) (Filepath filepath) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/contents/",toPath filepath]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data RepoUpdateFile 
instance HasBodyParam RepoUpdateFile UpdateFileOptions 

-- | @application/json@
instance Consumes RepoUpdateFile MimeJSON

-- | @application/json@
instance Produces RepoUpdateFile MimeJSON


-- *** repoUpdatePullRequest

-- | @POST \/repos\/{owner}\/{repo}\/pulls\/{index}\/update@
-- 
-- Merge PR's baseBranch into headBranch
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoUpdatePullRequest 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the pull request to get
  -> GiteaRequest RepoUpdatePullRequest MimeNoContent NoContent MimeNoContent
repoUpdatePullRequest (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/pulls/",toPath index,"/update"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdatePullRequest  
instance Produces RepoUpdatePullRequest MimeNoContent


-- *** repoUpdateTopics

-- | @PUT \/repos\/{owner}\/{repo}\/topics@
-- 
-- Replace list of topics for a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
repoUpdateTopics 
  :: (Consumes RepoUpdateTopics contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest RepoUpdateTopics contentType NoContent MimeNoContent
repoUpdateTopics _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/topics"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data RepoUpdateTopics 
instance HasBodyParam RepoUpdateTopics RepoTopicOptions 

-- | @application/json@
instance Consumes RepoUpdateTopics MimeJSON
-- | @text/plain@
instance Consumes RepoUpdateTopics MimePlainText

instance Produces RepoUpdateTopics MimeNoContent


-- *** topicSearch

-- | @GET \/topics\/search@
-- 
-- search topics via keyword
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
topicSearch 
  :: Q -- ^ "q" -  keywords to search
  -> GiteaRequest TopicSearch MimeNoContent [TopicResponse] MimeJSON
topicSearch (Q q) =
  _mkRequest "GET" ["/topics/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setQuery` toQuery ("q", Just q)

data TopicSearch  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam TopicSearch Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam TopicSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces TopicSearch MimeJSON


-- *** userCurrentCheckSubscription

-- | @GET \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Check if the current user is watching a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
userCurrentCheckSubscription 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentCheckSubscription MimeNoContent WatchInfo accept
userCurrentCheckSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckSubscription  
-- | @text/html@
instance Produces UserCurrentCheckSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentCheckSubscription MimeJSON


-- *** userCurrentDeleteSubscription

-- | @DELETE \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Unwatch a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
userCurrentDeleteSubscription 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentDeleteSubscription MimeNoContent NoContent MimeNoContent
userCurrentDeleteSubscription (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteSubscription  
instance Produces UserCurrentDeleteSubscription MimeNoContent


-- *** userCurrentPutSubscription

-- | @PUT \/repos\/{owner}\/{repo}\/subscription@
-- 
-- Watch a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
userCurrentPutSubscription 
  :: Accept accept -- ^ request accept ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentPutSubscription MimeNoContent WatchInfo accept
userCurrentPutSubscription  _ (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/subscription"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutSubscription  
-- | @text/html@
instance Produces UserCurrentPutSubscription MimeTextHtml
-- | @application/json@
instance Produces UserCurrentPutSubscription MimeJSON


-- *** userTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times\/{user}@
-- 
-- List a user's tracked times in a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
userTrackedTimes 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> User2 -- ^ "user" -  username of user
  -> GiteaRequest UserTrackedTimes MimeNoContent [TrackedTime] MimeJSON
userTrackedTimes (Owner owner) (Repo repo) (User2 user) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED userTrackedTimes "" #-}

data UserTrackedTimes  
-- | @application/json@
instance Produces UserTrackedTimes MimeJSON

