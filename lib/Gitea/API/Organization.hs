{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.15.9
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Organization
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Organization where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Organization

-- *** createOrgRepo

-- | @POST \/orgs\/{org}\/repos@
-- 
-- Create a repository in an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
createOrgRepo 
  :: (Consumes CreateOrgRepo MimeJSON)
  => Org -- ^ "org" -  name of organization
  -> GiteaRequest CreateOrgRepo MimeJSON Repository MimeJSON
createOrgRepo (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateOrgRepo 
instance HasBodyParam CreateOrgRepo CreateRepoOption 

-- | @application/json@
instance Consumes CreateOrgRepo MimeJSON

-- | @application/json@
instance Produces CreateOrgRepo MimeJSON


-- *** createOrgRepoDeprecated

-- | @POST \/org\/{org}\/repos@
-- 
-- Create a repository in an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
createOrgRepoDeprecated 
  :: (Consumes CreateOrgRepoDeprecated MimeJSON)
  => Org -- ^ "org" -  name of organization
  -> GiteaRequest CreateOrgRepoDeprecated MimeJSON Repository MimeJSON
createOrgRepoDeprecated (Org org) =
  _mkRequest "POST" ["/org/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED createOrgRepoDeprecated "" #-}

data CreateOrgRepoDeprecated 
instance HasBodyParam CreateOrgRepoDeprecated CreateRepoOption 

-- | @application/json@
instance Consumes CreateOrgRepoDeprecated MimeJSON

-- | @application/json@
instance Produces CreateOrgRepoDeprecated MimeJSON


-- *** orgAddTeamMember

-- | @PUT \/teams\/{id}\/members\/{username}@
-- 
-- Add a team member
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgAddTeamMember 
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the user to add
  -> GiteaRequest OrgAddTeamMember MimeNoContent NoContent MimeNoContent
orgAddTeamMember (Id id) (Username username) =
  _mkRequest "PUT" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgAddTeamMember  
instance Produces OrgAddTeamMember MimeNoContent


-- *** orgAddTeamRepository

-- | @PUT \/teams\/{id}\/repos\/{org}\/{repo}@
-- 
-- Add a repository to a team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgAddTeamRepository 
  :: Id -- ^ "id" -  id of the team
  -> Org -- ^ "org" -  organization that owns the repo to add
  -> Repo -- ^ "repo" -  name of the repo to add
  -> GiteaRequest OrgAddTeamRepository MimeNoContent NoContent MimeNoContent
orgAddTeamRepository (Id id) (Org org) (Repo repo) =
  _mkRequest "PUT" ["/teams/",toPath id,"/repos/",toPath org,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgAddTeamRepository  
instance Produces OrgAddTeamRepository MimeNoContent


-- *** orgConcealMember

-- | @DELETE \/orgs\/{org}\/public_members\/{username}@
-- 
-- Conceal a user's membership
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgConcealMember 
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgConcealMember MimeNoContent NoContent MimeNoContent
orgConcealMember (Org org) (Username username) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgConcealMember  
instance Produces OrgConcealMember MimeNoContent


-- *** orgCreate

-- | @POST \/orgs@
-- 
-- Create an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgCreate 
  :: (Consumes OrgCreate MimeJSON, MimeRender MimeJSON CreateOrgOption)
  => CreateOrgOption -- ^ "organization"
  -> GiteaRequest OrgCreate MimeJSON Organization MimeJSON
orgCreate organization =
  _mkRequest "POST" ["/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` organization

data OrgCreate 
instance HasBodyParam OrgCreate CreateOrgOption 

-- | @application/json@
instance Consumes OrgCreate MimeJSON

-- | @application/json@
instance Produces OrgCreate MimeJSON


-- *** orgCreateHook

-- | @POST \/orgs\/{org}\/hooks\/@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgCreateHook 
  :: (Consumes OrgCreateHook MimeJSON, MimeRender MimeJSON CreateHookOption)
  => CreateHookOption -- ^ "body"
  -> Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateHook MimeJSON Hook MimeJSON
orgCreateHook body (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/hooks/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data OrgCreateHook 
instance HasBodyParam OrgCreateHook CreateHookOption 

-- | @application/json@
instance Consumes OrgCreateHook MimeJSON

-- | @application/json@
instance Produces OrgCreateHook MimeJSON


-- *** orgCreateLabel

-- | @POST \/orgs\/{org}\/labels@
-- 
-- Create a label for an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgCreateLabel 
  :: (Consumes OrgCreateLabel MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateLabel MimeJSON Label MimeJSON
orgCreateLabel (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgCreateLabel 
instance HasBodyParam OrgCreateLabel CreateLabelOption 

-- | @application/json@
instance Consumes OrgCreateLabel MimeJSON

-- | @application/json@
instance Produces OrgCreateLabel MimeJSON


-- *** orgCreateTeam

-- | @POST \/orgs\/{org}\/teams@
-- 
-- Create a team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgCreateTeam 
  :: (Consumes OrgCreateTeam MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateTeam MimeJSON Team MimeJSON
orgCreateTeam (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgCreateTeam 
instance HasBodyParam OrgCreateTeam CreateTeamOption 

-- | @application/json@
instance Consumes OrgCreateTeam MimeJSON

-- | @application/json@
instance Produces OrgCreateTeam MimeJSON


-- *** orgDelete

-- | @DELETE \/orgs\/{org}@
-- 
-- Delete an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgDelete 
  :: Org -- ^ "org" -  organization that is to be deleted
  -> GiteaRequest OrgDelete MimeNoContent NoContent MimeNoContent
orgDelete (Org org) =
  _mkRequest "DELETE" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDelete  
instance Produces OrgDelete MimeNoContent


-- *** orgDeleteHook

-- | @DELETE \/orgs\/{org}\/hooks\/{id}@
-- 
-- Delete a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgDeleteHook 
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest OrgDeleteHook MimeNoContent NoContent MimeNoContent
orgDeleteHook (Org org) (Id id) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteHook  
instance Produces OrgDeleteHook MimeNoContent


-- *** orgDeleteLabel

-- | @DELETE \/orgs\/{org}\/labels\/{id}@
-- 
-- Delete a label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgDeleteLabel 
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to delete
  -> GiteaRequest OrgDeleteLabel MimeNoContent NoContent MimeNoContent
orgDeleteLabel (Org org) (Id id) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteLabel  
instance Produces OrgDeleteLabel MimeNoContent


-- *** orgDeleteMember

-- | @DELETE \/orgs\/{org}\/members\/{username}@
-- 
-- Remove a member from an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgDeleteMember 
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgDeleteMember MimeNoContent NoContent MimeNoContent
orgDeleteMember (Org org) (Username username) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteMember  
instance Produces OrgDeleteMember MimeNoContent


-- *** orgDeleteTeam

-- | @DELETE \/teams\/{id}@
-- 
-- Delete a team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgDeleteTeam 
  :: Id -- ^ "id" -  id of the team to delete
  -> GiteaRequest OrgDeleteTeam MimeNoContent NoContent MimeNoContent
orgDeleteTeam (Id id) =
  _mkRequest "DELETE" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteTeam  
instance Produces OrgDeleteTeam MimeNoContent


-- *** orgEdit

-- | @PATCH \/orgs\/{org}@
-- 
-- Edit an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgEdit 
  :: (Consumes OrgEdit MimeJSON, MimeRender MimeJSON EditOrgOption)
  => EditOrgOption -- ^ "body"
  -> Org -- ^ "org" -  name of the organization to edit
  -> GiteaRequest OrgEdit MimeJSON Organization MimeJSON
orgEdit body (Org org) =
  _mkRequest "PATCH" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data OrgEdit 
instance HasBodyParam OrgEdit EditOrgOption 

-- | @application/json@
instance Consumes OrgEdit MimeJSON

-- | @application/json@
instance Produces OrgEdit MimeJSON


-- *** orgEditHook

-- | @PATCH \/orgs\/{org}\/hooks\/{id}@
-- 
-- Update a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgEditHook 
  :: (Consumes OrgEditHook MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to update
  -> GiteaRequest OrgEditHook MimeJSON Hook MimeJSON
orgEditHook (Org org) (Id id) =
  _mkRequest "PATCH" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditHook 
instance HasBodyParam OrgEditHook EditHookOption 

-- | @application/json@
instance Consumes OrgEditHook MimeJSON

-- | @application/json@
instance Produces OrgEditHook MimeJSON


-- *** orgEditLabel

-- | @PATCH \/orgs\/{org}\/labels\/{id}@
-- 
-- Update a label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgEditLabel 
  :: (Consumes OrgEditLabel MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to edit
  -> GiteaRequest OrgEditLabel MimeJSON Label MimeJSON
orgEditLabel (Org org) (Id id) =
  _mkRequest "PATCH" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditLabel 
instance HasBodyParam OrgEditLabel EditLabelOption 

-- | @application/json@
instance Consumes OrgEditLabel MimeJSON

-- | @application/json@
instance Produces OrgEditLabel MimeJSON


-- *** orgEditTeam

-- | @PATCH \/teams\/{id}@
-- 
-- Edit a team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgEditTeam 
  :: (Consumes OrgEditTeam MimeJSON)
  => IdInt -- ^ "id" -  id of the team to edit
  -> GiteaRequest OrgEditTeam MimeJSON Team MimeJSON
orgEditTeam (IdInt id) =
  _mkRequest "PATCH" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditTeam 
instance HasBodyParam OrgEditTeam EditTeamOption 

-- | @application/json@
instance Consumes OrgEditTeam MimeJSON

-- | @application/json@
instance Produces OrgEditTeam MimeJSON


-- *** orgGet

-- | @GET \/orgs\/{org}@
-- 
-- Get an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgGet 
  :: Org -- ^ "org" -  name of the organization to get
  -> GiteaRequest OrgGet MimeNoContent Organization MimeJSON
orgGet (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGet  
-- | @application/json@
instance Produces OrgGet MimeJSON


-- *** orgGetAll

-- | @GET \/orgs@
-- 
-- Get list of organizations
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgGetAll 
  :: GiteaRequest OrgGetAll MimeNoContent [Organization] MimeJSON
orgGetAll =
  _mkRequest "GET" ["/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetAll  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgGetAll Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgGetAll Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgGetAll MimeJSON


-- *** orgGetHook

-- | @GET \/orgs\/{org}\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgGetHook 
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest OrgGetHook MimeNoContent Hook MimeJSON
orgGetHook (Org org) (Id id) =
  _mkRequest "GET" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetHook  
-- | @application/json@
instance Produces OrgGetHook MimeJSON


-- *** orgGetLabel

-- | @GET \/orgs\/{org}\/labels\/{id}@
-- 
-- Get a single label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgGetLabel 
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to get
  -> GiteaRequest OrgGetLabel MimeNoContent Label MimeJSON
orgGetLabel (Org org) (Id id) =
  _mkRequest "GET" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetLabel  
-- | @application/json@
instance Produces OrgGetLabel MimeJSON


-- *** orgGetTeam

-- | @GET \/teams\/{id}@
-- 
-- Get a team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgGetTeam 
  :: Id -- ^ "id" -  id of the team to get
  -> GiteaRequest OrgGetTeam MimeNoContent Team MimeJSON
orgGetTeam (Id id) =
  _mkRequest "GET" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetTeam  
-- | @application/json@
instance Produces OrgGetTeam MimeJSON


-- *** orgIsMember

-- | @GET \/orgs\/{org}\/members\/{username}@
-- 
-- Check if a user is a member of an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgIsMember 
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgIsMember MimeNoContent NoContent MimeNoContent
orgIsMember (Org org) (Username username) =
  _mkRequest "GET" ["/orgs/",toPath org,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgIsMember  
instance Produces OrgIsMember MimeNoContent


-- *** orgIsPublicMember

-- | @GET \/orgs\/{org}\/public_members\/{username}@
-- 
-- Check if a user is a public member of an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgIsPublicMember 
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgIsPublicMember MimeNoContent NoContent MimeNoContent
orgIsPublicMember (Org org) (Username username) =
  _mkRequest "GET" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgIsPublicMember  
instance Produces OrgIsPublicMember MimeNoContent


-- *** orgListCurrentUserOrgs

-- | @GET \/user\/orgs@
-- 
-- List the current user's organizations
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListCurrentUserOrgs 
  :: GiteaRequest OrgListCurrentUserOrgs MimeNoContent [Organization] MimeJSON
orgListCurrentUserOrgs =
  _mkRequest "GET" ["/user/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListCurrentUserOrgs  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListCurrentUserOrgs Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListCurrentUserOrgs Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListCurrentUserOrgs MimeJSON


-- *** orgListHooks

-- | @GET \/orgs\/{org}\/hooks@
-- 
-- List an organization's webhooks
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListHooks 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListHooks MimeNoContent [Hook] MimeJSON
orgListHooks (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListHooks Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListHooks MimeJSON


-- *** orgListLabels

-- | @GET \/orgs\/{org}\/labels@
-- 
-- List an organization's labels
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListLabels 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListLabels MimeNoContent [Label] MimeJSON
orgListLabels (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListLabels  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListLabels Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListLabels Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListLabels MimeJSON


-- *** orgListMembers

-- | @GET \/orgs\/{org}\/members@
-- 
-- List an organization's members
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListMembers 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListMembers MimeNoContent [User] MimeJSON
orgListMembers (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListMembers Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListMembers MimeJSON


-- *** orgListPublicMembers

-- | @GET \/orgs\/{org}\/public_members@
-- 
-- List an organization's public members
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListPublicMembers 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListPublicMembers MimeNoContent [User] MimeJSON
orgListPublicMembers (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/public_members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListPublicMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListPublicMembers Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListPublicMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListPublicMembers MimeJSON


-- *** orgListRepos

-- | @GET \/orgs\/{org}\/repos@
-- 
-- List an organization's repos
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListRepos 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListRepos MimeNoContent [Repository] MimeJSON
orgListRepos (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListRepos Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListRepos MimeJSON


-- *** orgListTeamMember

-- | @GET \/teams\/{id}\/members\/{username}@
-- 
-- List a particular member of team
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListTeamMember 
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the member to list
  -> GiteaRequest OrgListTeamMember MimeNoContent User MimeJSON
orgListTeamMember (Id id) (Username username) =
  _mkRequest "GET" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamMember  
-- | @application/json@
instance Produces OrgListTeamMember MimeJSON


-- *** orgListTeamMembers

-- | @GET \/teams\/{id}\/members@
-- 
-- List a team's members
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListTeamMembers 
  :: Id -- ^ "id" -  id of the team
  -> GiteaRequest OrgListTeamMembers MimeNoContent [User] MimeJSON
orgListTeamMembers (Id id) =
  _mkRequest "GET" ["/teams/",toPath id,"/members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeamMembers Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeamMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeamMembers MimeJSON


-- *** orgListTeamRepos

-- | @GET \/teams\/{id}\/repos@
-- 
-- List a team's repos
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListTeamRepos 
  :: Id -- ^ "id" -  id of the team
  -> GiteaRequest OrgListTeamRepos MimeNoContent [Repository] MimeJSON
orgListTeamRepos (Id id) =
  _mkRequest "GET" ["/teams/",toPath id,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeamRepos Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeamRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeamRepos MimeJSON


-- *** orgListTeams

-- | @GET \/orgs\/{org}\/teams@
-- 
-- List an organization's teams
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListTeams 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListTeams MimeNoContent [Team] MimeJSON
orgListTeams (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeams  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeams Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeams Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeams MimeJSON


-- *** orgListUserOrgs

-- | @GET \/users\/{username}\/orgs@
-- 
-- List a user's organizations
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgListUserOrgs 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest OrgListUserOrgs MimeNoContent [Organization] MimeJSON
orgListUserOrgs (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListUserOrgs  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListUserOrgs Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListUserOrgs Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListUserOrgs MimeJSON


-- *** orgPublicizeMember

-- | @PUT \/orgs\/{org}\/public_members\/{username}@
-- 
-- Publicize a user's membership
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgPublicizeMember 
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgPublicizeMember MimeNoContent NoContent MimeNoContent
orgPublicizeMember (Org org) (Username username) =
  _mkRequest "PUT" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgPublicizeMember  
instance Produces OrgPublicizeMember MimeNoContent


-- *** orgRemoveTeamMember

-- | @DELETE \/teams\/{id}\/members\/{username}@
-- 
-- Remove a team member
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgRemoveTeamMember 
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the user to remove
  -> GiteaRequest OrgRemoveTeamMember MimeNoContent NoContent MimeNoContent
orgRemoveTeamMember (Id id) (Username username) =
  _mkRequest "DELETE" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgRemoveTeamMember  
instance Produces OrgRemoveTeamMember MimeNoContent


-- *** orgRemoveTeamRepository

-- | @DELETE \/teams\/{id}\/repos\/{org}\/{repo}@
-- 
-- Remove a repository from a team
-- 
-- This does not delete the repository, it only removes the repository from the team.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
orgRemoveTeamRepository 
  :: Id -- ^ "id" -  id of the team
  -> Org -- ^ "org" -  organization that owns the repo to remove
  -> Repo -- ^ "repo" -  name of the repo to remove
  -> GiteaRequest OrgRemoveTeamRepository MimeNoContent NoContent MimeNoContent
orgRemoveTeamRepository (Id id) (Org org) (Repo repo) =
  _mkRequest "DELETE" ["/teams/",toPath id,"/repos/",toPath org,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgRemoveTeamRepository  
instance Produces OrgRemoveTeamRepository MimeNoContent


-- *** teamSearch

-- | @GET \/orgs\/{org}\/teams\/search@
-- 
-- Search for teams within an organization
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
teamSearch 
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest TeamSearch MimeNoContent InlineResponse200 MimeJSON
teamSearch (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/teams/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data TeamSearch  

-- | /Optional Param/ "q" - keywords to search
instance HasOptionalParam TeamSearch Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "include_desc" - include search within team description (defaults to true)
instance HasOptionalParam TeamSearch IncludeDesc where
  applyOptionalParam req (IncludeDesc xs) =
    req `setQuery` toQuery ("include_desc", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam TeamSearch Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam TeamSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces TeamSearch MimeJSON

