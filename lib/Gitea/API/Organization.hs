{-
   Gitea API

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API API version: 1.23.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Organization
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Organization where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Organization

-- *** createOrgRepo

-- | @POST \/orgs\/{org}\/repos@
-- 
-- Create a repository in an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createOrgRepo
  :: (Consumes CreateOrgRepo MimeJSON)
  => Org -- ^ "org" -  name of organization
  -> GiteaRequest CreateOrgRepo MimeJSON Repository MimeJSON
createOrgRepo (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateOrgRepo 
instance HasBodyParam CreateOrgRepo CreateRepoOption 

-- | @application/json@
instance Consumes CreateOrgRepo MimeJSON

-- | @application/json@
instance Produces CreateOrgRepo MimeJSON


-- *** createOrgRepoDeprecated

-- | @POST \/org\/{org}\/repos@
-- 
-- Create a repository in an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createOrgRepoDeprecated
  :: (Consumes CreateOrgRepoDeprecated MimeJSON)
  => Org -- ^ "org" -  name of organization
  -> GiteaRequest CreateOrgRepoDeprecated MimeJSON Repository MimeJSON
createOrgRepoDeprecated (Org org) =
  _mkRequest "POST" ["/org/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED createOrgRepoDeprecated "" #-}

data CreateOrgRepoDeprecated 
instance HasBodyParam CreateOrgRepoDeprecated CreateRepoOption 

-- | @application/json@
instance Consumes CreateOrgRepoDeprecated MimeJSON

-- | @application/json@
instance Produces CreateOrgRepoDeprecated MimeJSON


-- *** createOrgVariable

-- | @POST \/orgs\/{org}\/actions\/variables\/{variablename}@
-- 
-- Create an org-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createOrgVariable
  :: (Consumes CreateOrgVariable MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest CreateOrgVariable MimeJSON NoContent MimeNoContent
createOrgVariable (Org org) (Variablename variablename) =
  _mkRequest "POST" ["/orgs/",toPath org,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateOrgVariable 
instance HasBodyParam CreateOrgVariable CreateVariableOption 

-- | @application/json@
instance Consumes CreateOrgVariable MimeJSON

instance Produces CreateOrgVariable MimeNoContent


-- *** deleteOrgSecret

-- | @DELETE \/orgs\/{org}\/actions\/secrets\/{secretname}@
-- 
-- Delete a secret in an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
deleteOrgSecret
  :: Org -- ^ "org" -  name of organization
  -> Secretname -- ^ "secretname" -  name of the secret
  -> GiteaRequest DeleteOrgSecret MimeNoContent NoContent MimeNoContent
deleteOrgSecret (Org org) (Secretname secretname) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/actions/secrets/",toPath secretname]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data DeleteOrgSecret  
instance Produces DeleteOrgSecret MimeNoContent


-- *** deleteOrgVariable

-- | @DELETE \/orgs\/{org}\/actions\/variables\/{variablename}@
-- 
-- Delete an org-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
deleteOrgVariable
  :: Org -- ^ "org" -  name of the organization
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest DeleteOrgVariable MimeNoContent ActionVariable MimeJSON
deleteOrgVariable (Org org) (Variablename variablename) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data DeleteOrgVariable  
-- | @application/json@
instance Produces DeleteOrgVariable MimeJSON


-- *** getOrgVariable

-- | @GET \/orgs\/{org}\/actions\/variables\/{variablename}@
-- 
-- Get an org-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getOrgVariable
  :: Org -- ^ "org" -  name of the organization
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest GetOrgVariable MimeNoContent ActionVariable MimeJSON
getOrgVariable (Org org) (Variablename variablename) =
  _mkRequest "GET" ["/orgs/",toPath org,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetOrgVariable  
-- | @application/json@
instance Produces GetOrgVariable MimeJSON


-- *** getOrgVariablesList

-- | @GET \/orgs\/{org}\/actions\/variables@
-- 
-- Get an org-level variables list
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getOrgVariablesList
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest GetOrgVariablesList MimeNoContent [ActionVariable] MimeJSON
getOrgVariablesList (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/actions/variables"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetOrgVariablesList  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam GetOrgVariablesList Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam GetOrgVariablesList Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces GetOrgVariablesList MimeJSON


-- *** orgAddTeamMember

-- | @PUT \/teams\/{id}\/members\/{username}@
-- 
-- Add a team member
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgAddTeamMember
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the user to add
  -> GiteaRequest OrgAddTeamMember MimeNoContent NoContent MimeNoContent
orgAddTeamMember (Id id) (Username username) =
  _mkRequest "PUT" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgAddTeamMember  
instance Produces OrgAddTeamMember MimeNoContent


-- *** orgAddTeamRepository

-- | @PUT \/teams\/{id}\/repos\/{org}\/{repo}@
-- 
-- Add a repository to a team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgAddTeamRepository
  :: Id -- ^ "id" -  id of the team
  -> Org -- ^ "org" -  organization that owns the repo to add
  -> Repo -- ^ "repo" -  name of the repo to add
  -> GiteaRequest OrgAddTeamRepository MimeNoContent NoContent MimeNoContent
orgAddTeamRepository (Id id) (Org org) (Repo repo) =
  _mkRequest "PUT" ["/teams/",toPath id,"/repos/",toPath org,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgAddTeamRepository  
instance Produces OrgAddTeamRepository MimeNoContent


-- *** orgConcealMember

-- | @DELETE \/orgs\/{org}\/public_members\/{username}@
-- 
-- Conceal a user's membership
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgConcealMember
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgConcealMember MimeNoContent NoContent MimeNoContent
orgConcealMember (Org org) (Username username) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgConcealMember  
instance Produces OrgConcealMember MimeNoContent


-- *** orgCreate

-- | @POST \/orgs@
-- 
-- Create an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgCreate
  :: (Consumes OrgCreate MimeJSON, MimeRender MimeJSON CreateOrgOption)
  => CreateOrgOption -- ^ "organization"
  -> GiteaRequest OrgCreate MimeJSON Organization MimeJSON
orgCreate organization =
  _mkRequest "POST" ["/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` organization

data OrgCreate 
instance HasBodyParam OrgCreate CreateOrgOption 

-- | @application/json@
instance Consumes OrgCreate MimeJSON

-- | @application/json@
instance Produces OrgCreate MimeJSON


-- *** orgCreateHook

-- | @POST \/orgs\/{org}\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgCreateHook
  :: (Consumes OrgCreateHook MimeJSON, MimeRender MimeJSON CreateHookOption)
  => CreateHookOption -- ^ "body"
  -> Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateHook MimeJSON Hook MimeJSON
orgCreateHook body (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data OrgCreateHook 
instance HasBodyParam OrgCreateHook CreateHookOption 

-- | @application/json@
instance Consumes OrgCreateHook MimeJSON

-- | @application/json@
instance Produces OrgCreateHook MimeJSON


-- *** orgCreateLabel

-- | @POST \/orgs\/{org}\/labels@
-- 
-- Create a label for an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgCreateLabel
  :: (Consumes OrgCreateLabel MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateLabel MimeJSON Label MimeJSON
orgCreateLabel (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgCreateLabel 
instance HasBodyParam OrgCreateLabel CreateLabelOption 

-- | @application/json@
instance Consumes OrgCreateLabel MimeJSON

-- | @application/json@
instance Produces OrgCreateLabel MimeJSON


-- *** orgCreateTeam

-- | @POST \/orgs\/{org}\/teams@
-- 
-- Create a team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgCreateTeam
  :: (Consumes OrgCreateTeam MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgCreateTeam MimeJSON Team MimeJSON
orgCreateTeam (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgCreateTeam 
instance HasBodyParam OrgCreateTeam CreateTeamOption 

-- | @application/json@
instance Consumes OrgCreateTeam MimeJSON

-- | @application/json@
instance Produces OrgCreateTeam MimeJSON


-- *** orgDelete

-- | @DELETE \/orgs\/{org}@
-- 
-- Delete an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDelete
  :: Org -- ^ "org" -  organization that is to be deleted
  -> GiteaRequest OrgDelete MimeNoContent NoContent MimeNoContent
orgDelete (Org org) =
  _mkRequest "DELETE" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDelete  
instance Produces OrgDelete MimeNoContent


-- *** orgDeleteAvatar

-- | @DELETE \/orgs\/{org}\/avatar@
-- 
-- Delete Avatar
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDeleteAvatar
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgDeleteAvatar MimeNoContent NoContent MimeNoContent
orgDeleteAvatar (Org org) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/avatar"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteAvatar  
instance Produces OrgDeleteAvatar MimeNoContent


-- *** orgDeleteHook

-- | @DELETE \/orgs\/{org}\/hooks\/{id}@
-- 
-- Delete a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDeleteHook
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest OrgDeleteHook MimeNoContent NoContent MimeNoContent
orgDeleteHook (Org org) (Id id) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteHook  
instance Produces OrgDeleteHook MimeNoContent


-- *** orgDeleteLabel

-- | @DELETE \/orgs\/{org}\/labels\/{id}@
-- 
-- Delete a label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDeleteLabel
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to delete
  -> GiteaRequest OrgDeleteLabel MimeNoContent NoContent MimeNoContent
orgDeleteLabel (Org org) (Id id) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteLabel  
instance Produces OrgDeleteLabel MimeNoContent


-- *** orgDeleteMember

-- | @DELETE \/orgs\/{org}\/members\/{username}@
-- 
-- Remove a member from an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDeleteMember
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgDeleteMember MimeNoContent NoContent MimeNoContent
orgDeleteMember (Org org) (Username username) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteMember  
instance Produces OrgDeleteMember MimeNoContent


-- *** orgDeleteTeam

-- | @DELETE \/teams\/{id}@
-- 
-- Delete a team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgDeleteTeam
  :: Id -- ^ "id" -  id of the team to delete
  -> GiteaRequest OrgDeleteTeam MimeNoContent NoContent MimeNoContent
orgDeleteTeam (Id id) =
  _mkRequest "DELETE" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgDeleteTeam  
instance Produces OrgDeleteTeam MimeNoContent


-- *** orgEdit

-- | @PATCH \/orgs\/{org}@
-- 
-- Edit an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgEdit
  :: (Consumes OrgEdit MimeJSON, MimeRender MimeJSON EditOrgOption)
  => EditOrgOption -- ^ "body"
  -> Org -- ^ "org" -  name of the organization to edit
  -> GiteaRequest OrgEdit MimeJSON Organization MimeJSON
orgEdit body (Org org) =
  _mkRequest "PATCH" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data OrgEdit 
instance HasBodyParam OrgEdit EditOrgOption 

-- | @application/json@
instance Consumes OrgEdit MimeJSON

-- | @application/json@
instance Produces OrgEdit MimeJSON


-- *** orgEditHook

-- | @PATCH \/orgs\/{org}\/hooks\/{id}@
-- 
-- Update a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgEditHook
  :: (Consumes OrgEditHook MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to update
  -> GiteaRequest OrgEditHook MimeJSON Hook MimeJSON
orgEditHook (Org org) (Id id) =
  _mkRequest "PATCH" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditHook 
instance HasBodyParam OrgEditHook EditHookOption 

-- | @application/json@
instance Consumes OrgEditHook MimeJSON

-- | @application/json@
instance Produces OrgEditHook MimeJSON


-- *** orgEditLabel

-- | @PATCH \/orgs\/{org}\/labels\/{id}@
-- 
-- Update a label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgEditLabel
  :: (Consumes OrgEditLabel MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to edit
  -> GiteaRequest OrgEditLabel MimeJSON Label MimeJSON
orgEditLabel (Org org) (Id id) =
  _mkRequest "PATCH" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditLabel 
instance HasBodyParam OrgEditLabel EditLabelOption 

-- | @application/json@
instance Consumes OrgEditLabel MimeJSON

-- | @application/json@
instance Produces OrgEditLabel MimeJSON


-- *** orgEditTeam

-- | @PATCH \/teams\/{id}@
-- 
-- Edit a team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgEditTeam
  :: (Consumes OrgEditTeam MimeJSON)
  => IdInt -- ^ "id" -  id of the team to edit
  -> GiteaRequest OrgEditTeam MimeJSON Team MimeJSON
orgEditTeam (IdInt id) =
  _mkRequest "PATCH" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgEditTeam 
instance HasBodyParam OrgEditTeam EditTeamOption 

-- | @application/json@
instance Consumes OrgEditTeam MimeJSON

-- | @application/json@
instance Produces OrgEditTeam MimeJSON


-- *** orgGet

-- | @GET \/orgs\/{org}@
-- 
-- Get an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGet
  :: Org -- ^ "org" -  name of the organization to get
  -> GiteaRequest OrgGet MimeNoContent Organization MimeJSON
orgGet (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGet  
-- | @application/json@
instance Produces OrgGet MimeJSON


-- *** orgGetAll

-- | @GET \/orgs@
-- 
-- Get list of organizations
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetAll
  :: GiteaRequest OrgGetAll MimeNoContent [Organization] MimeJSON
orgGetAll =
  _mkRequest "GET" ["/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetAll  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgGetAll Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgGetAll Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgGetAll MimeJSON


-- *** orgGetHook

-- | @GET \/orgs\/{org}\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetHook
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest OrgGetHook MimeNoContent Hook MimeJSON
orgGetHook (Org org) (Id id) =
  _mkRequest "GET" ["/orgs/",toPath org,"/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetHook  
-- | @application/json@
instance Produces OrgGetHook MimeJSON


-- *** orgGetLabel

-- | @GET \/orgs\/{org}\/labels\/{id}@
-- 
-- Get a single label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetLabel
  :: Org -- ^ "org" -  name of the organization
  -> Id -- ^ "id" -  id of the label to get
  -> GiteaRequest OrgGetLabel MimeNoContent Label MimeJSON
orgGetLabel (Org org) (Id id) =
  _mkRequest "GET" ["/orgs/",toPath org,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetLabel  
-- | @application/json@
instance Produces OrgGetLabel MimeJSON


-- *** orgGetRunnerRegistrationToken

-- | @GET \/orgs\/{org}\/actions\/runners\/registration-token@
-- 
-- Get an organization's actions runner registration token
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetRunnerRegistrationToken
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgGetRunnerRegistrationToken MimeNoContent NoContent MimeNoContent
orgGetRunnerRegistrationToken (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/actions/runners/registration-token"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetRunnerRegistrationToken  
instance Produces OrgGetRunnerRegistrationToken MimeNoContent


-- *** orgGetTeam

-- | @GET \/teams\/{id}@
-- 
-- Get a team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetTeam
  :: Id -- ^ "id" -  id of the team to get
  -> GiteaRequest OrgGetTeam MimeNoContent Team MimeJSON
orgGetTeam (Id id) =
  _mkRequest "GET" ["/teams/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetTeam  
-- | @application/json@
instance Produces OrgGetTeam MimeJSON


-- *** orgGetUserPermissions

-- | @GET \/users\/{username}\/orgs\/{org}\/permissions@
-- 
-- Get user permissions in organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgGetUserPermissions
  :: Username -- ^ "username" -  username of user
  -> Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgGetUserPermissions MimeNoContent OrganizationPermissions MimeJSON
orgGetUserPermissions (Username username) (Org org) =
  _mkRequest "GET" ["/users/",toPath username,"/orgs/",toPath org,"/permissions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgGetUserPermissions  
-- | @application/json@
instance Produces OrgGetUserPermissions MimeJSON


-- *** orgIsMember

-- | @GET \/orgs\/{org}\/members\/{username}@
-- 
-- Check if a user is a member of an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgIsMember
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgIsMember MimeNoContent NoContent MimeNoContent
orgIsMember (Org org) (Username username) =
  _mkRequest "GET" ["/orgs/",toPath org,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgIsMember  
instance Produces OrgIsMember MimeNoContent


-- *** orgIsPublicMember

-- | @GET \/orgs\/{org}\/public_members\/{username}@
-- 
-- Check if a user is a public member of an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgIsPublicMember
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgIsPublicMember MimeNoContent NoContent MimeNoContent
orgIsPublicMember (Org org) (Username username) =
  _mkRequest "GET" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgIsPublicMember  
instance Produces OrgIsPublicMember MimeNoContent


-- *** orgListActionsSecrets

-- | @GET \/orgs\/{org}\/actions\/secrets@
-- 
-- List an organization's actions secrets
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListActionsSecrets
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListActionsSecrets MimeNoContent [Secret] MimeJSON
orgListActionsSecrets (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/actions/secrets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListActionsSecrets  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListActionsSecrets Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListActionsSecrets Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListActionsSecrets MimeJSON


-- *** orgListActivityFeeds

-- | @GET \/orgs\/{org}\/activities\/feeds@
-- 
-- List an organization's activity feeds
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListActivityFeeds
  :: Org -- ^ "org" -  name of the org
  -> GiteaRequest OrgListActivityFeeds MimeNoContent [Activity] MimeJSON
orgListActivityFeeds (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/activities/feeds"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListActivityFeeds  

-- | /Optional Param/ "date" - the date of the activities to be found
instance HasOptionalParam OrgListActivityFeeds ParamDate where
  applyOptionalParam req (ParamDate xs) =
    req `addQuery` toQuery ("date", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListActivityFeeds Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListActivityFeeds Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListActivityFeeds MimeJSON


-- *** orgListCurrentUserOrgs

-- | @GET \/user\/orgs@
-- 
-- List the current user's organizations
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListCurrentUserOrgs
  :: GiteaRequest OrgListCurrentUserOrgs MimeNoContent [Organization] MimeJSON
orgListCurrentUserOrgs =
  _mkRequest "GET" ["/user/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListCurrentUserOrgs  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListCurrentUserOrgs Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListCurrentUserOrgs Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListCurrentUserOrgs MimeJSON


-- *** orgListHooks

-- | @GET \/orgs\/{org}\/hooks@
-- 
-- List an organization's webhooks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListHooks
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListHooks MimeNoContent [Hook] MimeJSON
orgListHooks (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListHooks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListHooks MimeJSON


-- *** orgListLabels

-- | @GET \/orgs\/{org}\/labels@
-- 
-- List an organization's labels
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListLabels
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListLabels MimeNoContent [Label] MimeJSON
orgListLabels (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListLabels  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListLabels Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListLabels Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListLabels MimeJSON


-- *** orgListMembers

-- | @GET \/orgs\/{org}\/members@
-- 
-- List an organization's members
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListMembers
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListMembers MimeNoContent [User] MimeJSON
orgListMembers (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListMembers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListMembers MimeJSON


-- *** orgListPublicMembers

-- | @GET \/orgs\/{org}\/public_members@
-- 
-- List an organization's public members
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListPublicMembers
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListPublicMembers MimeNoContent [User] MimeJSON
orgListPublicMembers (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/public_members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListPublicMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListPublicMembers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListPublicMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListPublicMembers MimeJSON


-- *** orgListRepos

-- | @GET \/orgs\/{org}\/repos@
-- 
-- List an organization's repos
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListRepos
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListRepos MimeNoContent [Repository] MimeJSON
orgListRepos (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListRepos Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListRepos MimeJSON


-- *** orgListTeamActivityFeeds

-- | @GET \/teams\/{id}\/activities\/feeds@
-- 
-- List a team's activity feeds
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeamActivityFeeds
  :: Id -- ^ "id" -  id of the team
  -> GiteaRequest OrgListTeamActivityFeeds MimeNoContent [Activity] MimeJSON
orgListTeamActivityFeeds (Id id) =
  _mkRequest "GET" ["/teams/",toPath id,"/activities/feeds"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamActivityFeeds  

-- | /Optional Param/ "date" - the date of the activities to be found
instance HasOptionalParam OrgListTeamActivityFeeds ParamDate where
  applyOptionalParam req (ParamDate xs) =
    req `addQuery` toQuery ("date", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeamActivityFeeds Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeamActivityFeeds Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeamActivityFeeds MimeJSON


-- *** orgListTeamMember

-- | @GET \/teams\/{id}\/members\/{username}@
-- 
-- List a particular member of team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeamMember
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the member to list
  -> GiteaRequest OrgListTeamMember MimeNoContent User MimeJSON
orgListTeamMember (Id id) (Username username) =
  _mkRequest "GET" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamMember  
-- | @application/json@
instance Produces OrgListTeamMember MimeJSON


-- *** orgListTeamMembers

-- | @GET \/teams\/{id}\/members@
-- 
-- List a team's members
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeamMembers
  :: Id -- ^ "id" -  id of the team
  -> GiteaRequest OrgListTeamMembers MimeNoContent [User] MimeJSON
orgListTeamMembers (Id id) =
  _mkRequest "GET" ["/teams/",toPath id,"/members"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamMembers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeamMembers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeamMembers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeamMembers MimeJSON


-- *** orgListTeamRepo

-- | @GET \/teams\/{id}\/repos\/{org}\/{repo}@
-- 
-- List a particular repo of team
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeamRepo
  :: Id -- ^ "id" -  id of the team
  -> Org -- ^ "org" -  organization that owns the repo to list
  -> Repo -- ^ "repo" -  name of the repo to list
  -> GiteaRequest OrgListTeamRepo MimeNoContent Repository MimeJSON
orgListTeamRepo (Id id) (Org org) (Repo repo) =
  _mkRequest "GET" ["/teams/",toPath id,"/repos/",toPath org,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamRepo  
-- | @application/json@
instance Produces OrgListTeamRepo MimeJSON


-- *** orgListTeamRepos

-- | @GET \/teams\/{id}\/repos@
-- 
-- List a team's repos
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeamRepos
  :: Id -- ^ "id" -  id of the team
  -> GiteaRequest OrgListTeamRepos MimeNoContent [Repository] MimeJSON
orgListTeamRepos (Id id) =
  _mkRequest "GET" ["/teams/",toPath id,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeamRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeamRepos Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeamRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeamRepos MimeJSON


-- *** orgListTeams

-- | @GET \/orgs\/{org}\/teams@
-- 
-- List an organization's teams
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListTeams
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgListTeams MimeNoContent [Team] MimeJSON
orgListTeams (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListTeams  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListTeams Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListTeams Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListTeams MimeJSON


-- *** orgListUserOrgs

-- | @GET \/users\/{username}\/orgs@
-- 
-- List a user's organizations
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgListUserOrgs
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest OrgListUserOrgs MimeNoContent [Organization] MimeJSON
orgListUserOrgs (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgListUserOrgs  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrgListUserOrgs Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrgListUserOrgs Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrgListUserOrgs MimeJSON


-- *** orgPublicizeMember

-- | @PUT \/orgs\/{org}\/public_members\/{username}@
-- 
-- Publicize a user's membership
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgPublicizeMember
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  username of the user
  -> GiteaRequest OrgPublicizeMember MimeNoContent NoContent MimeNoContent
orgPublicizeMember (Org org) (Username username) =
  _mkRequest "PUT" ["/orgs/",toPath org,"/public_members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgPublicizeMember  
instance Produces OrgPublicizeMember MimeNoContent


-- *** orgRemoveTeamMember

-- | @DELETE \/teams\/{id}\/members\/{username}@
-- 
-- Remove a team member
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgRemoveTeamMember
  :: Id -- ^ "id" -  id of the team
  -> Username -- ^ "username" -  username of the user to remove
  -> GiteaRequest OrgRemoveTeamMember MimeNoContent NoContent MimeNoContent
orgRemoveTeamMember (Id id) (Username username) =
  _mkRequest "DELETE" ["/teams/",toPath id,"/members/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgRemoveTeamMember  
instance Produces OrgRemoveTeamMember MimeNoContent


-- *** orgRemoveTeamRepository

-- | @DELETE \/teams\/{id}\/repos\/{org}\/{repo}@
-- 
-- Remove a repository from a team
-- 
-- This does not delete the repository, it only removes the repository from the team.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgRemoveTeamRepository
  :: Id -- ^ "id" -  id of the team
  -> Org -- ^ "org" -  organization that owns the repo to remove
  -> Repo -- ^ "repo" -  name of the repo to remove
  -> GiteaRequest OrgRemoveTeamRepository MimeNoContent NoContent MimeNoContent
orgRemoveTeamRepository (Id id) (Org org) (Repo repo) =
  _mkRequest "DELETE" ["/teams/",toPath id,"/repos/",toPath org,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgRemoveTeamRepository  
instance Produces OrgRemoveTeamRepository MimeNoContent


-- *** orgUpdateAvatar

-- | @POST \/orgs\/{org}\/avatar@
-- 
-- Update Avatar
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
orgUpdateAvatar
  :: (Consumes OrgUpdateAvatar contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrgUpdateAvatar contentType NoContent MimeNoContent
orgUpdateAvatar _ (Org org) =
  _mkRequest "POST" ["/orgs/",toPath org,"/avatar"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrgUpdateAvatar 
instance HasBodyParam OrgUpdateAvatar UpdateUserAvatarOption 

-- | @application/json@
instance Consumes OrgUpdateAvatar MimeJSON
-- | @text/plain@
instance Consumes OrgUpdateAvatar MimePlainText

instance Produces OrgUpdateAvatar MimeNoContent


-- *** organizationBlockUser

-- | @PUT \/orgs\/{org}\/blocks\/{username}@
-- 
-- Block a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
organizationBlockUser
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  user to block
  -> GiteaRequest OrganizationBlockUser MimeNoContent NoContent MimeNoContent
organizationBlockUser (Org org) (Username username) =
  _mkRequest "PUT" ["/orgs/",toPath org,"/blocks/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrganizationBlockUser  

-- | /Optional Param/ "note" - optional note for the block
instance HasOptionalParam OrganizationBlockUser Note2 where
  applyOptionalParam req (Note2 xs) =
    req `addQuery` toQuery ("note", Just xs)
instance Produces OrganizationBlockUser MimeNoContent


-- *** organizationCheckUserBlock

-- | @GET \/orgs\/{org}\/blocks\/{username}@
-- 
-- Check if a user is blocked by the organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
organizationCheckUserBlock
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  user to check
  -> GiteaRequest OrganizationCheckUserBlock MimeNoContent NoContent MimeNoContent
organizationCheckUserBlock (Org org) (Username username) =
  _mkRequest "GET" ["/orgs/",toPath org,"/blocks/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrganizationCheckUserBlock  
instance Produces OrganizationCheckUserBlock MimeNoContent


-- *** organizationListBlocks

-- | @GET \/orgs\/{org}\/blocks@
-- 
-- List users blocked by the organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
organizationListBlocks
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest OrganizationListBlocks MimeNoContent [User] MimeJSON
organizationListBlocks (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/blocks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrganizationListBlocks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam OrganizationListBlocks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam OrganizationListBlocks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces OrganizationListBlocks MimeJSON


-- *** organizationUnblockUser

-- | @DELETE \/orgs\/{org}\/blocks\/{username}@
-- 
-- Unblock a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
organizationUnblockUser
  :: Org -- ^ "org" -  name of the organization
  -> Username -- ^ "username" -  user to unblock
  -> GiteaRequest OrganizationUnblockUser MimeNoContent NoContent MimeNoContent
organizationUnblockUser (Org org) (Username username) =
  _mkRequest "DELETE" ["/orgs/",toPath org,"/blocks/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data OrganizationUnblockUser  
instance Produces OrganizationUnblockUser MimeNoContent


-- *** teamSearch

-- | @GET \/orgs\/{org}\/teams\/search@
-- 
-- Search for teams within an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
teamSearch
  :: Org -- ^ "org" -  name of the organization
  -> GiteaRequest TeamSearch MimeNoContent TeamSearch200Response MimeJSON
teamSearch (Org org) =
  _mkRequest "GET" ["/orgs/",toPath org,"/teams/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data TeamSearch  

-- | /Optional Param/ "q" - keywords to search
instance HasOptionalParam TeamSearch Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "include_desc" - include search within team description (defaults to true)
instance HasOptionalParam TeamSearch IncludeDesc where
  applyOptionalParam req (IncludeDesc xs) =
    req `addQuery` toQuery ("include_desc", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam TeamSearch Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam TeamSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces TeamSearch MimeJSON


-- *** updateOrgSecret

-- | @PUT \/orgs\/{org}\/actions\/secrets\/{secretname}@
-- 
-- Create or Update a secret value in an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
updateOrgSecret
  :: (Consumes UpdateOrgSecret MimeJSON)
  => Org -- ^ "org" -  name of organization
  -> Secretname -- ^ "secretname" -  name of the secret
  -> GiteaRequest UpdateOrgSecret MimeJSON NoContent MimeNoContent
updateOrgSecret (Org org) (Secretname secretname) =
  _mkRequest "PUT" ["/orgs/",toPath org,"/actions/secrets/",toPath secretname]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UpdateOrgSecret 
instance HasBodyParam UpdateOrgSecret CreateOrUpdateSecretOption 

-- | @application/json@
instance Consumes UpdateOrgSecret MimeJSON

instance Produces UpdateOrgSecret MimeNoContent


-- *** updateOrgVariable

-- | @PUT \/orgs\/{org}\/actions\/variables\/{variablename}@
-- 
-- Update an org-level variable
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
updateOrgVariable
  :: (Consumes UpdateOrgVariable MimeJSON)
  => Org -- ^ "org" -  name of the organization
  -> Variablename -- ^ "variablename" -  name of the variable
  -> GiteaRequest UpdateOrgVariable MimeJSON NoContent MimeNoContent
updateOrgVariable (Org org) (Variablename variablename) =
  _mkRequest "PUT" ["/orgs/",toPath org,"/actions/variables/",toPath variablename]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UpdateOrgVariable 
instance HasBodyParam UpdateOrgVariable UpdateVariableOption 

-- | @application/json@
instance Consumes UpdateOrgVariable MimeJSON

instance Produces UpdateOrgVariable MimeNoContent

