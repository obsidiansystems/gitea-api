{-
   Gitea API

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API API version: 1.22.6
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Admin
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Admin where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Admin

-- *** adminAddUserBadges

-- | @POST \/admin\/users\/{username}\/badges@
-- 
-- Add a badge to a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminAddUserBadges
  :: (Consumes AdminAddUserBadges MimeJSON)
  => Username -- ^ "username" -  username of user
  -> GiteaRequest AdminAddUserBadges MimeJSON NoContent MimeNoContent
adminAddUserBadges (Username username) =
  _mkRequest "POST" ["/admin/users/",toPath username,"/badges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminAddUserBadges 
instance HasBodyParam AdminAddUserBadges UserBadgeOption 

-- | @application/json@
instance Consumes AdminAddUserBadges MimeJSON

instance Produces AdminAddUserBadges MimeNoContent


-- *** adminAdoptRepository

-- | @POST \/admin\/unadopted\/{owner}\/{repo}@
-- 
-- Adopt unadopted files as a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminAdoptRepository
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest AdminAdoptRepository MimeNoContent NoContent MimeNoContent
adminAdoptRepository (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/admin/unadopted/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminAdoptRepository  
instance Produces AdminAdoptRepository MimeNoContent


-- *** adminCreateHook

-- | @POST \/admin\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCreateHook
  :: (Consumes AdminCreateHook MimeJSON, MimeRender MimeJSON CreateHookOption)
  => CreateHookOption -- ^ "body"
  -> GiteaRequest AdminCreateHook MimeJSON Hook MimeJSON
adminCreateHook body =
  _mkRequest "POST" ["/admin/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data AdminCreateHook 
instance HasBodyParam AdminCreateHook CreateHookOption 

-- | @application/json@
instance Consumes AdminCreateHook MimeJSON

-- | @application/json@
instance Produces AdminCreateHook MimeJSON


-- *** adminCreateOrg

-- | @POST \/admin\/users\/{username}\/orgs@
-- 
-- Create an organization
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCreateOrg
  :: (Consumes AdminCreateOrg MimeJSON, MimeRender MimeJSON CreateOrgOption)
  => CreateOrgOption -- ^ "organization"
  -> Username -- ^ "username" -  username of the user that will own the created organization
  -> GiteaRequest AdminCreateOrg MimeJSON Organization MimeJSON
adminCreateOrg organization (Username username) =
  _mkRequest "POST" ["/admin/users/",toPath username,"/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` organization

data AdminCreateOrg 
instance HasBodyParam AdminCreateOrg CreateOrgOption 

-- | @application/json@
instance Consumes AdminCreateOrg MimeJSON

-- | @application/json@
instance Produces AdminCreateOrg MimeJSON


-- *** adminCreatePublicKey

-- | @POST \/admin\/users\/{username}\/keys@
-- 
-- Add a public key on behalf of a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCreatePublicKey
  :: (Consumes AdminCreatePublicKey MimeJSON)
  => Username -- ^ "username" -  username of the user
  -> GiteaRequest AdminCreatePublicKey MimeJSON PublicKey MimeJSON
adminCreatePublicKey (Username username) =
  _mkRequest "POST" ["/admin/users/",toPath username,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminCreatePublicKey 
instance HasBodyParam AdminCreatePublicKey CreateKeyOption 

-- | @application/json@
instance Consumes AdminCreatePublicKey MimeJSON

-- | @application/json@
instance Produces AdminCreatePublicKey MimeJSON


-- *** adminCreateRepo

-- | @POST \/admin\/users\/{username}\/repos@
-- 
-- Create a repository on behalf of a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCreateRepo
  :: (Consumes AdminCreateRepo MimeJSON, MimeRender MimeJSON CreateRepoOption)
  => CreateRepoOption -- ^ "repository"
  -> Username -- ^ "username" -  username of the user. This user will own the created repository
  -> GiteaRequest AdminCreateRepo MimeJSON Repository MimeJSON
adminCreateRepo repository (Username username) =
  _mkRequest "POST" ["/admin/users/",toPath username,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` repository

data AdminCreateRepo 
instance HasBodyParam AdminCreateRepo CreateRepoOption 

-- | @application/json@
instance Consumes AdminCreateRepo MimeJSON

-- | @application/json@
instance Produces AdminCreateRepo MimeJSON


-- *** adminCreateUser

-- | @POST \/admin\/users@
-- 
-- Create a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCreateUser
  :: (Consumes AdminCreateUser MimeJSON)
  => GiteaRequest AdminCreateUser MimeJSON User MimeJSON
adminCreateUser =
  _mkRequest "POST" ["/admin/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminCreateUser 
instance HasBodyParam AdminCreateUser CreateUserOption 

-- | @application/json@
instance Consumes AdminCreateUser MimeJSON

-- | @application/json@
instance Produces AdminCreateUser MimeJSON


-- *** adminCronList

-- | @GET \/admin\/cron@
-- 
-- List cron tasks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCronList
  :: GiteaRequest AdminCronList MimeNoContent [Cron] MimeJSON
adminCronList =
  _mkRequest "GET" ["/admin/cron"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminCronList  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminCronList Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminCronList Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminCronList MimeJSON


-- *** adminCronRun

-- | @POST \/admin\/cron\/{task}@
-- 
-- Run cron task
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminCronRun
  :: Task -- ^ "task" -  task to run
  -> GiteaRequest AdminCronRun MimeNoContent NoContent MimeNoContent
adminCronRun (Task task) =
  _mkRequest "POST" ["/admin/cron/",toPath task]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminCronRun  
instance Produces AdminCronRun MimeNoContent


-- *** adminDeleteHook

-- | @DELETE \/admin\/hooks\/{id}@
-- 
-- Delete a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminDeleteHook
  :: Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest AdminDeleteHook MimeNoContent NoContent MimeNoContent
adminDeleteHook (Id id) =
  _mkRequest "DELETE" ["/admin/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminDeleteHook  
instance Produces AdminDeleteHook MimeNoContent


-- *** adminDeleteUnadoptedRepository

-- | @DELETE \/admin\/unadopted\/{owner}\/{repo}@
-- 
-- Delete unadopted files
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminDeleteUnadoptedRepository
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest AdminDeleteUnadoptedRepository MimeNoContent NoContent MimeNoContent
adminDeleteUnadoptedRepository (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/admin/unadopted/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminDeleteUnadoptedRepository  
instance Produces AdminDeleteUnadoptedRepository MimeNoContent


-- *** adminDeleteUser

-- | @DELETE \/admin\/users\/{username}@
-- 
-- Delete a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminDeleteUser
  :: Username -- ^ "username" -  username of user to delete
  -> GiteaRequest AdminDeleteUser MimeNoContent NoContent MimeNoContent
adminDeleteUser (Username username) =
  _mkRequest "DELETE" ["/admin/users/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminDeleteUser  

-- | /Optional Param/ "purge" - purge the user from the system completely
instance HasOptionalParam AdminDeleteUser Purge where
  applyOptionalParam req (Purge xs) =
    req `addQuery` toQuery ("purge", Just xs)
instance Produces AdminDeleteUser MimeNoContent


-- *** adminDeleteUserBadges

-- | @DELETE \/admin\/users\/{username}\/badges@
-- 
-- Remove a badge from a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminDeleteUserBadges
  :: (Consumes AdminDeleteUserBadges contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Username -- ^ "username" -  username of user
  -> GiteaRequest AdminDeleteUserBadges contentType NoContent MimeNoContent
adminDeleteUserBadges _ (Username username) =
  _mkRequest "DELETE" ["/admin/users/",toPath username,"/badges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminDeleteUserBadges 
instance HasBodyParam AdminDeleteUserBadges UserBadgeOption 

-- | @application/json@
instance Consumes AdminDeleteUserBadges MimeJSON
-- | @text/plain@
instance Consumes AdminDeleteUserBadges MimePlainText

instance Produces AdminDeleteUserBadges MimeNoContent


-- *** adminDeleteUserPublicKey

-- | @DELETE \/admin\/users\/{username}\/keys\/{id}@
-- 
-- Delete a user's public key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminDeleteUserPublicKey
  :: Username -- ^ "username" -  username of user
  -> Id -- ^ "id" -  id of the key to delete
  -> GiteaRequest AdminDeleteUserPublicKey MimeNoContent NoContent MimeNoContent
adminDeleteUserPublicKey (Username username) (Id id) =
  _mkRequest "DELETE" ["/admin/users/",toPath username,"/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminDeleteUserPublicKey  
instance Produces AdminDeleteUserPublicKey MimeNoContent


-- *** adminEditHook

-- | @PATCH \/admin\/hooks\/{id}@
-- 
-- Update a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminEditHook
  :: (Consumes AdminEditHook MimeJSON)
  => Id -- ^ "id" -  id of the hook to update
  -> GiteaRequest AdminEditHook MimeJSON Hook MimeJSON
adminEditHook (Id id) =
  _mkRequest "PATCH" ["/admin/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminEditHook 
instance HasBodyParam AdminEditHook EditHookOption 

-- | @application/json@
instance Consumes AdminEditHook MimeJSON

-- | @application/json@
instance Produces AdminEditHook MimeJSON


-- *** adminEditUser

-- | @PATCH \/admin\/users\/{username}@
-- 
-- Edit an existing user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminEditUser
  :: (Consumes AdminEditUser MimeJSON)
  => Username -- ^ "username" -  username of user to edit
  -> GiteaRequest AdminEditUser MimeJSON User MimeJSON
adminEditUser (Username username) =
  _mkRequest "PATCH" ["/admin/users/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminEditUser 
instance HasBodyParam AdminEditUser EditUserOption 

-- | @application/json@
instance Consumes AdminEditUser MimeJSON

-- | @application/json@
instance Produces AdminEditUser MimeJSON


-- *** adminGetAllEmails

-- | @GET \/admin\/emails@
-- 
-- List all emails
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminGetAllEmails
  :: GiteaRequest AdminGetAllEmails MimeNoContent [Email] MimeJSON
adminGetAllEmails =
  _mkRequest "GET" ["/admin/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminGetAllEmails  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminGetAllEmails Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminGetAllEmails Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminGetAllEmails MimeJSON


-- *** adminGetAllOrgs

-- | @GET \/admin\/orgs@
-- 
-- List all organizations
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminGetAllOrgs
  :: GiteaRequest AdminGetAllOrgs MimeNoContent [Organization] MimeJSON
adminGetAllOrgs =
  _mkRequest "GET" ["/admin/orgs"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminGetAllOrgs  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminGetAllOrgs Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminGetAllOrgs Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminGetAllOrgs MimeJSON


-- *** adminGetHook

-- | @GET \/admin\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminGetHook
  :: Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest AdminGetHook MimeNoContent Hook MimeJSON
adminGetHook (Id id) =
  _mkRequest "GET" ["/admin/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminGetHook  
-- | @application/json@
instance Produces AdminGetHook MimeJSON


-- *** adminGetRunnerRegistrationToken

-- | @GET \/admin\/runners\/registration-token@
-- 
-- Get an global actions runner registration token
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminGetRunnerRegistrationToken
  :: GiteaRequest AdminGetRunnerRegistrationToken MimeNoContent NoContent MimeNoContent
adminGetRunnerRegistrationToken =
  _mkRequest "GET" ["/admin/runners/registration-token"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminGetRunnerRegistrationToken  
instance Produces AdminGetRunnerRegistrationToken MimeNoContent


-- *** adminListHooks

-- | @GET \/admin\/hooks@
-- 
-- List system's webhooks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminListHooks
  :: GiteaRequest AdminListHooks MimeNoContent [Hook] MimeJSON
adminListHooks =
  _mkRequest "GET" ["/admin/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminListHooks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminListHooks MimeJSON


-- *** adminListUserBadges

-- | @GET \/admin\/users\/{username}\/badges@
-- 
-- List a user's badges
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminListUserBadges
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest AdminListUserBadges MimeNoContent [Badge] MimeJSON
adminListUserBadges (Username username) =
  _mkRequest "GET" ["/admin/users/",toPath username,"/badges"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminListUserBadges  
-- | @application/json@
instance Produces AdminListUserBadges MimeJSON


-- *** adminRenameUser

-- | @POST \/admin\/users\/{username}\/rename@
-- 
-- Rename a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminRenameUser
  :: (Consumes AdminRenameUser contentType, MimeRender contentType RenameUserOption)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> RenameUserOption -- ^ "body"
  -> Username -- ^ "username" -  existing username of user
  -> GiteaRequest AdminRenameUser contentType NoContent MimeNoContent
adminRenameUser _ body (Username username) =
  _mkRequest "POST" ["/admin/users/",toPath username,"/rename"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data AdminRenameUser 
instance HasBodyParam AdminRenameUser RenameUserOption 

-- | @application/json@
instance Consumes AdminRenameUser MimeJSON
-- | @text/plain@
instance Consumes AdminRenameUser MimePlainText

instance Produces AdminRenameUser MimeNoContent


-- *** adminSearchEmails

-- | @GET \/admin\/emails\/search@
-- 
-- Search all emails
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminSearchEmails
  :: GiteaRequest AdminSearchEmails MimeNoContent [Email] MimeJSON
adminSearchEmails =
  _mkRequest "GET" ["/admin/emails/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminSearchEmails  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam AdminSearchEmails Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminSearchEmails Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminSearchEmails Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminSearchEmails MimeJSON


-- *** adminSearchUsers

-- | @GET \/admin\/users@
-- 
-- Search users according filter conditions
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminSearchUsers
  :: GiteaRequest AdminSearchUsers MimeNoContent [User] MimeJSON
adminSearchUsers =
  _mkRequest "GET" ["/admin/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminSearchUsers  

-- | /Optional Param/ "source_id" - ID of the user's login source to search for
instance HasOptionalParam AdminSearchUsers SourceId where
  applyOptionalParam req (SourceId xs) =
    req `addQuery` toQuery ("source_id", Just xs)

-- | /Optional Param/ "login_name" - user's login name to search for
instance HasOptionalParam AdminSearchUsers LoginName where
  applyOptionalParam req (LoginName xs) =
    req `addQuery` toQuery ("login_name", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminSearchUsers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminSearchUsers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces AdminSearchUsers MimeJSON


-- *** adminUnadoptedList

-- | @GET \/admin\/unadopted@
-- 
-- List unadopted repositories
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
adminUnadoptedList
  :: GiteaRequest AdminUnadoptedList MimeNoContent [Text] MimeJSON
adminUnadoptedList =
  _mkRequest "GET" ["/admin/unadopted"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data AdminUnadoptedList  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam AdminUnadoptedList Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam AdminUnadoptedList Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pattern" - pattern of repositories to search for
instance HasOptionalParam AdminUnadoptedList Pattern where
  applyOptionalParam req (Pattern xs) =
    req `addQuery` toQuery ("pattern", Just xs)
-- | @application/json@
instance Produces AdminUnadoptedList MimeJSON

