{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.1.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.User
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.User where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** User

-- *** createCurrentUserRepo0

-- | @POST \/user\/repos@
-- 
-- Create a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createCurrentUserRepo0 
  :: (Consumes CreateCurrentUserRepo0 MimeJSON)
  => GiteaRequest CreateCurrentUserRepo0 MimeJSON Repository MimeJSON
createCurrentUserRepo0 =
  _mkRequest "POST" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateCurrentUserRepo0 
instance HasBodyParam CreateCurrentUserRepo0 CreateRepoOption 

-- | @application/json@
instance Consumes CreateCurrentUserRepo0 MimeJSON

-- | @application/json@
instance Produces CreateCurrentUserRepo0 MimeJSON


-- *** userAddEmail

-- | @POST \/user\/emails@
-- 
-- Add email addresses
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userAddEmail 
  :: (Consumes UserAddEmail contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> GiteaRequest UserAddEmail contentType [Email] MimeJSON
userAddEmail _ =
  _mkRequest "POST" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserAddEmail 
instance HasBodyParam UserAddEmail CreateEmailOption 

-- | @application/json@
instance Consumes UserAddEmail MimeJSON
-- | @text/plain@
instance Consumes UserAddEmail MimePlainText

-- | @application/json@
instance Produces UserAddEmail MimeJSON


-- *** userCheckFollowing

-- | @GET \/users\/{follower}\/following\/{followee}@
-- 
-- Check if one user is following another user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCheckFollowing 
  :: Follower -- ^ "follower" -  username of following user
  -> Followee -- ^ "followee" -  username of followed user
  -> GiteaRequest UserCheckFollowing MimeNoContent NoContent MimeNoContent
userCheckFollowing (Follower follower) (Followee followee) =
  _mkRequest "GET" ["/users/",toPath follower,"/following/",toPath followee]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCheckFollowing  
instance Produces UserCheckFollowing MimeNoContent


-- *** userCreateToken

-- | @POST \/users\/{username}\/tokens@
-- 
-- Create an access token
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCreateToken 
  :: (Consumes UserCreateToken MimeJSON)
  => Username -- ^ "username" -  username of user
  -> GiteaRequest UserCreateToken MimeJSON NoContent MimeNoContent
userCreateToken (Username username) =
  _mkRequest "POST" ["/users/",toPath username,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCreateToken 
instance HasBodyParam UserCreateToken InlineObject 

-- | @application/json@
instance Consumes UserCreateToken MimeJSON

instance Produces UserCreateToken MimeNoContent


-- *** userCurrentCheckFollowing

-- | @GET \/user\/following\/{username}@
-- 
-- Check whether a user is followed by the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckFollowing 
  :: Username -- ^ "username" -  username of followed user
  -> GiteaRequest UserCurrentCheckFollowing MimeNoContent NoContent MimeNoContent
userCurrentCheckFollowing (Username username) =
  _mkRequest "GET" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckFollowing  
instance Produces UserCurrentCheckFollowing MimeNoContent


-- *** userCurrentCheckStarring

-- | @GET \/user\/starred\/{owner}\/{repo}@
-- 
-- Whether the authenticated is starring the repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckStarring 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentCheckStarring MimeNoContent NoContent MimeNoContent
userCurrentCheckStarring (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckStarring  
instance Produces UserCurrentCheckStarring MimeNoContent


-- *** userCurrentDeleteFollow

-- | @DELETE \/user\/following\/{username}@
-- 
-- Unfollow a user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteFollow 
  :: Username -- ^ "username" -  username of user to unfollow
  -> GiteaRequest UserCurrentDeleteFollow MimeNoContent NoContent MimeNoContent
userCurrentDeleteFollow (Username username) =
  _mkRequest "DELETE" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteFollow  
instance Produces UserCurrentDeleteFollow MimeNoContent


-- *** userCurrentDeleteGPGKey

-- | @DELETE \/user\/gpg_keys\/{id}@
-- 
-- Remove a GPG key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteGPGKey 
  :: Id -- ^ "id" -  id of key to delete
  -> GiteaRequest UserCurrentDeleteGPGKey MimeNoContent NoContent MimeNoContent
userCurrentDeleteGPGKey (Id id) =
  _mkRequest "DELETE" ["/user/gpg_keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteGPGKey  
instance Produces UserCurrentDeleteGPGKey MimeNoContent


-- *** userCurrentDeleteKey

-- | @DELETE \/user\/keys\/{id}@
-- 
-- Delete a public key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteKey 
  :: Id -- ^ "id" -  id of key to delete
  -> GiteaRequest UserCurrentDeleteKey MimeNoContent NoContent MimeNoContent
userCurrentDeleteKey (Id id) =
  _mkRequest "DELETE" ["/user/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteKey  
instance Produces UserCurrentDeleteKey MimeNoContent


-- *** userCurrentDeleteStar

-- | @DELETE \/user\/starred\/{owner}\/{repo}@
-- 
-- Unstar the given repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteStar 
  :: Owner -- ^ "owner" -  owner of the repo to unstar
  -> Repo -- ^ "repo" -  name of the repo to unstar
  -> GiteaRequest UserCurrentDeleteStar MimeNoContent NoContent MimeNoContent
userCurrentDeleteStar (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteStar  
instance Produces UserCurrentDeleteStar MimeNoContent


-- *** userCurrentGetGPGKey

-- | @GET \/user\/gpg_keys\/{id}@
-- 
-- Get a GPG key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentGetGPGKey 
  :: Id -- ^ "id" -  id of key to get
  -> GiteaRequest UserCurrentGetGPGKey MimeNoContent GPGKey MimeJSON
userCurrentGetGPGKey (Id id) =
  _mkRequest "GET" ["/user/gpg_keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentGetGPGKey  
-- | @application/json@
instance Produces UserCurrentGetGPGKey MimeJSON


-- *** userCurrentGetKey

-- | @GET \/user\/keys\/{id}@
-- 
-- Get a public key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentGetKey 
  :: Id -- ^ "id" -  id of key to get
  -> GiteaRequest UserCurrentGetKey MimeNoContent PublicKey MimeJSON
userCurrentGetKey (Id id) =
  _mkRequest "GET" ["/user/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentGetKey  
-- | @application/json@
instance Produces UserCurrentGetKey MimeJSON


-- *** userCurrentListFollowers

-- | @GET \/user\/followers@
-- 
-- List the authenticated user's followers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListFollowers 
  :: GiteaRequest UserCurrentListFollowers MimeNoContent [User] MimeJSON
userCurrentListFollowers =
  _mkRequest "GET" ["/user/followers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListFollowers  
-- | @application/json@
instance Produces UserCurrentListFollowers MimeJSON


-- *** userCurrentListFollowing

-- | @GET \/user\/following@
-- 
-- List the users that the authenticated user is following
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListFollowing 
  :: GiteaRequest UserCurrentListFollowing MimeNoContent [User] MimeJSON
userCurrentListFollowing =
  _mkRequest "GET" ["/user/following"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListFollowing  
-- | @application/json@
instance Produces UserCurrentListFollowing MimeJSON


-- *** userCurrentListGPGKeys

-- | @GET \/user\/gpg_keys@
-- 
-- List the authenticated user's GPG keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListGPGKeys 
  :: GiteaRequest UserCurrentListGPGKeys MimeNoContent [GPGKey] MimeJSON
userCurrentListGPGKeys =
  _mkRequest "GET" ["/user/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListGPGKeys  
-- | @application/json@
instance Produces UserCurrentListGPGKeys MimeJSON


-- *** userCurrentListKeys

-- | @GET \/user\/keys@
-- 
-- List the authenticated user's public keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListKeys 
  :: GiteaRequest UserCurrentListKeys MimeNoContent [PublicKey] MimeJSON
userCurrentListKeys =
  _mkRequest "GET" ["/user/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListKeys  

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam UserCurrentListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `setQuery` toQuery ("fingerprint", Just xs)
-- | @application/json@
instance Produces UserCurrentListKeys MimeJSON


-- *** userCurrentListRepos

-- | @GET \/user\/repos@
-- 
-- List the repos that the authenticated user owns or has access to
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListRepos 
  :: GiteaRequest UserCurrentListRepos MimeNoContent [Repository] MimeJSON
userCurrentListRepos =
  _mkRequest "GET" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListRepos  
-- | @application/json@
instance Produces UserCurrentListRepos MimeJSON


-- *** userCurrentListStarred

-- | @GET \/user\/starred@
-- 
-- The repos that the authenticated user has starred
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListStarred 
  :: GiteaRequest UserCurrentListStarred MimeNoContent [Repository] MimeJSON
userCurrentListStarred =
  _mkRequest "GET" ["/user/starred"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListStarred  
-- | @application/json@
instance Produces UserCurrentListStarred MimeJSON


-- *** userCurrentListSubscriptions

-- | @GET \/user\/subscriptions@
-- 
-- List repositories watched by the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListSubscriptions 
  :: GiteaRequest UserCurrentListSubscriptions MimeNoContent [Repository] MimeJSON
userCurrentListSubscriptions =
  _mkRequest "GET" ["/user/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListSubscriptions  
-- | @application/json@
instance Produces UserCurrentListSubscriptions MimeJSON


-- *** userCurrentPostGPGKey

-- | @POST \/user\/gpg_keys@
-- 
-- Create a GPG key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPostGPGKey 
  :: (Consumes UserCurrentPostGPGKey MimeJSON)
  => GiteaRequest UserCurrentPostGPGKey MimeJSON GPGKey MimeJSON
userCurrentPostGPGKey =
  _mkRequest "POST" ["/user/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPostGPGKey 
instance HasBodyParam UserCurrentPostGPGKey CreateGPGKeyOption 

-- | @application/json@
instance Consumes UserCurrentPostGPGKey MimeJSON

-- | @application/json@
instance Produces UserCurrentPostGPGKey MimeJSON


-- *** userCurrentPostKey

-- | @POST \/user\/keys@
-- 
-- Create a public key
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPostKey 
  :: (Consumes UserCurrentPostKey MimeJSON)
  => GiteaRequest UserCurrentPostKey MimeJSON PublicKey MimeJSON
userCurrentPostKey =
  _mkRequest "POST" ["/user/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPostKey 
instance HasBodyParam UserCurrentPostKey CreateKeyOption 

-- | @application/json@
instance Consumes UserCurrentPostKey MimeJSON

-- | @application/json@
instance Produces UserCurrentPostKey MimeJSON


-- *** userCurrentPutFollow

-- | @PUT \/user\/following\/{username}@
-- 
-- Follow a user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutFollow 
  :: Username -- ^ "username" -  username of user to follow
  -> GiteaRequest UserCurrentPutFollow MimeNoContent NoContent MimeNoContent
userCurrentPutFollow (Username username) =
  _mkRequest "PUT" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutFollow  
instance Produces UserCurrentPutFollow MimeNoContent


-- *** userCurrentPutStar

-- | @PUT \/user\/starred\/{owner}\/{repo}@
-- 
-- Star the given repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutStar 
  :: Owner -- ^ "owner" -  owner of the repo to star
  -> Repo -- ^ "repo" -  name of the repo to star
  -> GiteaRequest UserCurrentPutStar MimeNoContent NoContent MimeNoContent
userCurrentPutStar (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutStar  
instance Produces UserCurrentPutStar MimeNoContent


-- *** userCurrentTrackedTimes

-- | @GET \/user\/times@
-- 
-- List the current user's tracked times
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentTrackedTimes 
  :: GiteaRequest UserCurrentTrackedTimes MimeNoContent [TrackedTime] MimeJSON
userCurrentTrackedTimes =
  _mkRequest "GET" ["/user/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentTrackedTimes  
-- | @application/json@
instance Produces UserCurrentTrackedTimes MimeJSON


-- *** userDeleteAccessToken

-- | @DELETE \/users\/{username}\/tokens\/{token}@
-- 
-- delete an access token
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteAccessToken 
  :: Username -- ^ "username" -  username of user
  -> Token -- ^ "token" -  token to be deleted
  -> GiteaRequest UserDeleteAccessToken MimeNoContent NoContent MimeNoContent
userDeleteAccessToken (Username username) (Token token) =
  _mkRequest "DELETE" ["/users/",toPath username,"/tokens/",toPath token]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteAccessToken  
instance Produces UserDeleteAccessToken MimeNoContent


-- *** userDeleteEmail

-- | @DELETE \/user\/emails@
-- 
-- Delete email addresses
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteEmail 
  :: (Consumes UserDeleteEmail contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> GiteaRequest UserDeleteEmail contentType NoContent MimeNoContent
userDeleteEmail _ =
  _mkRequest "DELETE" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteEmail 
instance HasBodyParam UserDeleteEmail DeleteEmailOption 

-- | @application/json@
instance Consumes UserDeleteEmail MimeJSON
-- | @text/plain@
instance Consumes UserDeleteEmail MimePlainText

instance Produces UserDeleteEmail MimeNoContent


-- *** userGet

-- | @GET \/users\/{username}@
-- 
-- Get a user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGet 
  :: Username -- ^ "username" -  username of user to get
  -> GiteaRequest UserGet MimeNoContent User MimeJSON
userGet (Username username) =
  _mkRequest "GET" ["/users/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGet  
-- | @application/json@
instance Produces UserGet MimeJSON


-- *** userGetCurrent

-- | @GET \/user@
-- 
-- Get the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetCurrent 
  :: GiteaRequest UserGetCurrent MimeNoContent User MimeJSON
userGetCurrent =
  _mkRequest "GET" ["/user"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetCurrent  
-- | @application/json@
instance Produces UserGetCurrent MimeJSON


-- *** userGetHeatmapData

-- | @GET \/users\/{username}\/heatmap@
-- 
-- Get a user's heatmap
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetHeatmapData 
  :: Username -- ^ "username" -  username of user to get
  -> GiteaRequest UserGetHeatmapData MimeNoContent [UserHeatmapData] MimeJSON
userGetHeatmapData (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/heatmap"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetHeatmapData  
-- | @application/json@
instance Produces UserGetHeatmapData MimeJSON


-- *** userGetStopWatches

-- | @GET \/user\/stopwatches@
-- 
-- Get list of all existing stopwatches
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetStopWatches 
  :: GiteaRequest UserGetStopWatches MimeNoContent [StopWatch] MimeJSON
userGetStopWatches =
  _mkRequest "GET" ["/user/stopwatches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetStopWatches  
-- | @application/json@
instance Produces UserGetStopWatches MimeJSON


-- *** userGetTokens

-- | @GET \/users\/{username}\/tokens@
-- 
-- List the authenticated user's access tokens
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetTokens 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserGetTokens MimeNoContent [AccessToken] MimeJSON
userGetTokens (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetTokens  
-- | @application/json@
instance Produces UserGetTokens MimeJSON


-- *** userListEmails

-- | @GET \/user\/emails@
-- 
-- List the authenticated user's email addresses
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListEmails 
  :: GiteaRequest UserListEmails MimeNoContent [Email] MimeJSON
userListEmails =
  _mkRequest "GET" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListEmails  
-- | @application/json@
instance Produces UserListEmails MimeJSON


-- *** userListFollowers

-- | @GET \/users\/{username}\/followers@
-- 
-- List the given user's followers
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListFollowers 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListFollowers MimeNoContent [User] MimeJSON
userListFollowers (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/followers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListFollowers  
-- | @application/json@
instance Produces UserListFollowers MimeJSON


-- *** userListFollowing

-- | @GET \/users\/{username}\/following@
-- 
-- List the users that the given user is following
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListFollowing 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListFollowing MimeNoContent [User] MimeJSON
userListFollowing (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/following"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListFollowing  
-- | @application/json@
instance Produces UserListFollowing MimeJSON


-- *** userListGPGKeys

-- | @GET \/users\/{username}\/gpg_keys@
-- 
-- List the given user's GPG keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListGPGKeys 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListGPGKeys MimeNoContent [GPGKey] MimeJSON
userListGPGKeys (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListGPGKeys  
-- | @application/json@
instance Produces UserListGPGKeys MimeJSON


-- *** userListKeys

-- | @GET \/users\/{username}\/keys@
-- 
-- List the given user's public keys
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListKeys 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListKeys MimeNoContent [PublicKey] MimeJSON
userListKeys (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListKeys  

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam UserListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `setQuery` toQuery ("fingerprint", Just xs)
-- | @application/json@
instance Produces UserListKeys MimeJSON


-- *** userListRepos

-- | @GET \/users\/{username}\/repos@
-- 
-- List the repos owned by the given user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListRepos 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListRepos MimeNoContent [Repository] MimeJSON
userListRepos (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListRepos  
-- | @application/json@
instance Produces UserListRepos MimeJSON


-- *** userListStarred

-- | @GET \/users\/{username}\/starred@
-- 
-- The repos that the given user has starred
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListStarred 
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListStarred MimeNoContent [Repository] MimeJSON
userListStarred (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/starred"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListStarred  
-- | @application/json@
instance Produces UserListStarred MimeJSON


-- *** userListSubscriptions

-- | @GET \/users\/{username}\/subscriptions@
-- 
-- List the repositories watched by a user
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListSubscriptions 
  :: Username -- ^ "username" -  username of the user
  -> GiteaRequest UserListSubscriptions MimeNoContent [Repository] MimeJSON
userListSubscriptions (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListSubscriptions  
-- | @application/json@
instance Produces UserListSubscriptions MimeJSON


-- *** userListTeams

-- | @GET \/user\/teams@
-- 
-- List all the teams a user belongs to
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListTeams 
  :: GiteaRequest UserListTeams MimeNoContent [Team] MimeJSON
userListTeams =
  _mkRequest "GET" ["/user/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListTeams  
-- | @application/json@
instance Produces UserListTeams MimeJSON


-- *** userSearch

-- | @GET \/users\/search@
-- 
-- Search for users
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userSearch 
  :: GiteaRequest UserSearch MimeNoContent InlineResponse2001 MimeJSON
userSearch =
  _mkRequest "GET" ["/users/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserSearch  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam UserSearch Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "uid" - ID of the user to search for
instance HasOptionalParam UserSearch Uid where
  applyOptionalParam req (Uid xs) =
    req `setQuery` toQuery ("uid", Just xs)

-- | /Optional Param/ "limit" - maximum number of users to return
instance HasOptionalParam UserSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserSearch MimeJSON


-- *** userTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/times\/{user}@
-- 
-- List a user's tracked times in a repo
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userTrackedTimes 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> User2 -- ^ "user" -  username of user
  -> GiteaRequest UserTrackedTimes MimeNoContent [TrackedTime] MimeJSON
userTrackedTimes (Owner owner) (Repo repo) (User2 user) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/times/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserTrackedTimes  
-- | @application/json@
instance Produces UserTrackedTimes MimeJSON

