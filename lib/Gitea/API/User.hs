{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.20.6
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.User
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.User where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** User

-- *** createCurrentUserRepo0

-- | @POST \/user\/repos@
-- 
-- Create a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
createCurrentUserRepo0
  :: (Consumes CreateCurrentUserRepo0 MimeJSON)
  => GiteaRequest CreateCurrentUserRepo0 MimeJSON Repository MimeJSON
createCurrentUserRepo0 =
  _mkRequest "POST" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data CreateCurrentUserRepo0 
instance HasBodyParam CreateCurrentUserRepo0 CreateRepoOption 

-- | @application/json@
instance Consumes CreateCurrentUserRepo0 MimeJSON

-- | @application/json@
instance Produces CreateCurrentUserRepo0 MimeJSON


-- *** getUserSettings

-- | @GET \/user\/settings@
-- 
-- Get user settings
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getUserSettings
  :: GiteaRequest GetUserSettings MimeNoContent [UserSettings] MimeJSON
getUserSettings =
  _mkRequest "GET" ["/user/settings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetUserSettings  
-- | @application/json@
instance Produces GetUserSettings MimeJSON


-- *** getVerificationToken

-- | @GET \/user\/gpg_key_token@
-- 
-- Get a Token to verify
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
getVerificationToken
  :: GiteaRequest GetVerificationToken MimeNoContent Text MimePlainText
getVerificationToken =
  _mkRequest "GET" ["/user/gpg_key_token"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data GetVerificationToken  
-- | @text/plain@
instance Produces GetVerificationToken MimePlainText


-- *** updateUserSettings

-- | @PATCH \/user\/settings@
-- 
-- Update user settings
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
updateUserSettings
  :: (Consumes UpdateUserSettings contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> GiteaRequest UpdateUserSettings contentType [UserSettings] MimeJSON
updateUserSettings _ =
  _mkRequest "PATCH" ["/user/settings"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UpdateUserSettings 
instance HasBodyParam UpdateUserSettings UserSettingsOptions 

-- | @application/json@
instance Consumes UpdateUserSettings MimeJSON
-- | @text/plain@
instance Consumes UpdateUserSettings MimePlainText

-- | @application/json@
instance Produces UpdateUserSettings MimeJSON


-- *** userAddEmail

-- | @POST \/user\/emails@
-- 
-- Add email addresses
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userAddEmail
  :: (Consumes UserAddEmail contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> GiteaRequest UserAddEmail contentType [Email] MimeJSON
userAddEmail _ =
  _mkRequest "POST" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserAddEmail 
instance HasBodyParam UserAddEmail CreateEmailOption 

-- | @application/json@
instance Consumes UserAddEmail MimeJSON
-- | @text/plain@
instance Consumes UserAddEmail MimePlainText

-- | @application/json@
instance Produces UserAddEmail MimeJSON


-- *** userCheckFollowing

-- | @GET \/users\/{username}\/following\/{target}@
-- 
-- Check if one user is following another user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCheckFollowing
  :: Username -- ^ "username" -  username of following user
  -> Target -- ^ "target" -  username of followed user
  -> GiteaRequest UserCheckFollowing MimeNoContent NoContent MimeNoContent
userCheckFollowing (Username username) (Target target) =
  _mkRequest "GET" ["/users/",toPath username,"/following/",toPath target]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCheckFollowing  
instance Produces UserCheckFollowing MimeNoContent


-- *** userCreateHook

-- | @POST \/user\/hooks@
-- 
-- Create a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCreateHook
  :: (Consumes UserCreateHook MimeJSON, MimeRender MimeJSON CreateHookOption)
  => CreateHookOption -- ^ "body"
  -> GiteaRequest UserCreateHook MimeJSON Hook MimeJSON
userCreateHook body =
  _mkRequest "POST" ["/user/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data UserCreateHook 
instance HasBodyParam UserCreateHook CreateHookOption 

-- | @application/json@
instance Consumes UserCreateHook MimeJSON

-- | @application/json@
instance Produces UserCreateHook MimeJSON


-- *** userCreateOAuth2Application

-- | @POST \/user\/applications\/oauth2@
-- 
-- creates a new OAuth2 application
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCreateOAuth2Application
  :: (Consumes UserCreateOAuth2Application contentType, MimeRender contentType CreateOAuth2ApplicationOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> CreateOAuth2ApplicationOptions -- ^ "body"
  -> GiteaRequest UserCreateOAuth2Application contentType OAuth2Application MimeJSON
userCreateOAuth2Application _ body =
  _mkRequest "POST" ["/user/applications/oauth2"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data UserCreateOAuth2Application 
instance HasBodyParam UserCreateOAuth2Application CreateOAuth2ApplicationOptions 

-- | @application/json@
instance Consumes UserCreateOAuth2Application MimeJSON
-- | @text/plain@
instance Consumes UserCreateOAuth2Application MimePlainText

-- | @application/json@
instance Produces UserCreateOAuth2Application MimeJSON


-- *** userCreateToken

-- | @POST \/users\/{username}\/tokens@
-- 
-- Create an access token
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCreateToken
  :: (Consumes UserCreateToken MimeJSON)
  => Username -- ^ "username" -  username of user
  -> GiteaRequest UserCreateToken MimeJSON AccessToken MimeJSON
userCreateToken (Username username) =
  _mkRequest "POST" ["/users/",toPath username,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCreateToken 
instance HasBodyParam UserCreateToken CreateAccessTokenOption 

-- | @application/json@
instance Consumes UserCreateToken MimeJSON

-- | @application/json@
instance Produces UserCreateToken MimeJSON


-- *** userCurrentCheckFollowing

-- | @GET \/user\/following\/{username}@
-- 
-- Check whether a user is followed by the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckFollowing
  :: Username -- ^ "username" -  username of followed user
  -> GiteaRequest UserCurrentCheckFollowing MimeNoContent NoContent MimeNoContent
userCurrentCheckFollowing (Username username) =
  _mkRequest "GET" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckFollowing  
instance Produces UserCurrentCheckFollowing MimeNoContent


-- *** userCurrentCheckStarring

-- | @GET \/user\/starred\/{owner}\/{repo}@
-- 
-- Whether the authenticated is starring the repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentCheckStarring
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest UserCurrentCheckStarring MimeNoContent NoContent MimeNoContent
userCurrentCheckStarring (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentCheckStarring  
instance Produces UserCurrentCheckStarring MimeNoContent


-- *** userCurrentDeleteFollow

-- | @DELETE \/user\/following\/{username}@
-- 
-- Unfollow a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteFollow
  :: Username -- ^ "username" -  username of user to unfollow
  -> GiteaRequest UserCurrentDeleteFollow MimeNoContent NoContent MimeNoContent
userCurrentDeleteFollow (Username username) =
  _mkRequest "DELETE" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteFollow  
instance Produces UserCurrentDeleteFollow MimeNoContent


-- *** userCurrentDeleteGPGKey

-- | @DELETE \/user\/gpg_keys\/{id}@
-- 
-- Remove a GPG key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteGPGKey
  :: Id -- ^ "id" -  id of key to delete
  -> GiteaRequest UserCurrentDeleteGPGKey MimeNoContent NoContent MimeNoContent
userCurrentDeleteGPGKey (Id id) =
  _mkRequest "DELETE" ["/user/gpg_keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteGPGKey  
instance Produces UserCurrentDeleteGPGKey MimeNoContent


-- *** userCurrentDeleteKey

-- | @DELETE \/user\/keys\/{id}@
-- 
-- Delete a public key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteKey
  :: Id -- ^ "id" -  id of key to delete
  -> GiteaRequest UserCurrentDeleteKey MimeNoContent NoContent MimeNoContent
userCurrentDeleteKey (Id id) =
  _mkRequest "DELETE" ["/user/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteKey  
instance Produces UserCurrentDeleteKey MimeNoContent


-- *** userCurrentDeleteStar

-- | @DELETE \/user\/starred\/{owner}\/{repo}@
-- 
-- Unstar the given repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentDeleteStar
  :: Owner -- ^ "owner" -  owner of the repo to unstar
  -> Repo -- ^ "repo" -  name of the repo to unstar
  -> GiteaRequest UserCurrentDeleteStar MimeNoContent NoContent MimeNoContent
userCurrentDeleteStar (Owner owner) (Repo repo) =
  _mkRequest "DELETE" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentDeleteStar  
instance Produces UserCurrentDeleteStar MimeNoContent


-- *** userCurrentGetGPGKey

-- | @GET \/user\/gpg_keys\/{id}@
-- 
-- Get a GPG key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentGetGPGKey
  :: Id -- ^ "id" -  id of key to get
  -> GiteaRequest UserCurrentGetGPGKey MimeNoContent GPGKey MimeJSON
userCurrentGetGPGKey (Id id) =
  _mkRequest "GET" ["/user/gpg_keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentGetGPGKey  
-- | @application/json@
instance Produces UserCurrentGetGPGKey MimeJSON


-- *** userCurrentGetKey

-- | @GET \/user\/keys\/{id}@
-- 
-- Get a public key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentGetKey
  :: Id -- ^ "id" -  id of key to get
  -> GiteaRequest UserCurrentGetKey MimeNoContent PublicKey MimeJSON
userCurrentGetKey (Id id) =
  _mkRequest "GET" ["/user/keys/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentGetKey  
-- | @application/json@
instance Produces UserCurrentGetKey MimeJSON


-- *** userCurrentListFollowers

-- | @GET \/user\/followers@
-- 
-- List the authenticated user's followers
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListFollowers
  :: GiteaRequest UserCurrentListFollowers MimeNoContent [User] MimeJSON
userCurrentListFollowers =
  _mkRequest "GET" ["/user/followers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListFollowers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListFollowers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListFollowers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListFollowers MimeJSON


-- *** userCurrentListFollowing

-- | @GET \/user\/following@
-- 
-- List the users that the authenticated user is following
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListFollowing
  :: GiteaRequest UserCurrentListFollowing MimeNoContent [User] MimeJSON
userCurrentListFollowing =
  _mkRequest "GET" ["/user/following"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListFollowing  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListFollowing Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListFollowing Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListFollowing MimeJSON


-- *** userCurrentListGPGKeys

-- | @GET \/user\/gpg_keys@
-- 
-- List the authenticated user's GPG keys
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListGPGKeys
  :: GiteaRequest UserCurrentListGPGKeys MimeNoContent [GPGKey] MimeJSON
userCurrentListGPGKeys =
  _mkRequest "GET" ["/user/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListGPGKeys  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListGPGKeys Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListGPGKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListGPGKeys MimeJSON


-- *** userCurrentListKeys

-- | @GET \/user\/keys@
-- 
-- List the authenticated user's public keys
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListKeys
  :: GiteaRequest UserCurrentListKeys MimeNoContent [PublicKey] MimeJSON
userCurrentListKeys =
  _mkRequest "GET" ["/user/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListKeys  

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam UserCurrentListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `addQuery` toQuery ("fingerprint", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListKeys Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListKeys MimeJSON


-- *** userCurrentListRepos

-- | @GET \/user\/repos@
-- 
-- List the repos that the authenticated user owns
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListRepos
  :: GiteaRequest UserCurrentListRepos MimeNoContent [Repository] MimeJSON
userCurrentListRepos =
  _mkRequest "GET" ["/user/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListRepos Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListRepos MimeJSON


-- *** userCurrentListStarred

-- | @GET \/user\/starred@
-- 
-- The repos that the authenticated user has starred
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListStarred
  :: GiteaRequest UserCurrentListStarred MimeNoContent [Repository] MimeJSON
userCurrentListStarred =
  _mkRequest "GET" ["/user/starred"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListStarred  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListStarred Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListStarred Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListStarred MimeJSON


-- *** userCurrentListSubscriptions

-- | @GET \/user\/subscriptions@
-- 
-- List repositories watched by the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentListSubscriptions
  :: GiteaRequest UserCurrentListSubscriptions MimeNoContent [Repository] MimeJSON
userCurrentListSubscriptions =
  _mkRequest "GET" ["/user/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentListSubscriptions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentListSubscriptions Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentListSubscriptions Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserCurrentListSubscriptions MimeJSON


-- *** userCurrentPostGPGKey

-- | @POST \/user\/gpg_keys@
-- 
-- Create a GPG key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPostGPGKey
  :: (Consumes UserCurrentPostGPGKey MimeJSON)
  => GiteaRequest UserCurrentPostGPGKey MimeJSON GPGKey MimeJSON
userCurrentPostGPGKey =
  _mkRequest "POST" ["/user/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPostGPGKey 
instance HasBodyParam UserCurrentPostGPGKey CreateGPGKeyOption 

-- | @application/json@
instance Consumes UserCurrentPostGPGKey MimeJSON

-- | @application/json@
instance Produces UserCurrentPostGPGKey MimeJSON


-- *** userCurrentPostKey

-- | @POST \/user\/keys@
-- 
-- Create a public key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPostKey
  :: (Consumes UserCurrentPostKey MimeJSON)
  => GiteaRequest UserCurrentPostKey MimeJSON PublicKey MimeJSON
userCurrentPostKey =
  _mkRequest "POST" ["/user/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPostKey 
instance HasBodyParam UserCurrentPostKey CreateKeyOption 

-- | @application/json@
instance Consumes UserCurrentPostKey MimeJSON

-- | @application/json@
instance Produces UserCurrentPostKey MimeJSON


-- *** userCurrentPutFollow

-- | @PUT \/user\/following\/{username}@
-- 
-- Follow a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutFollow
  :: Username -- ^ "username" -  username of user to follow
  -> GiteaRequest UserCurrentPutFollow MimeNoContent NoContent MimeNoContent
userCurrentPutFollow (Username username) =
  _mkRequest "PUT" ["/user/following/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutFollow  
instance Produces UserCurrentPutFollow MimeNoContent


-- *** userCurrentPutStar

-- | @PUT \/user\/starred\/{owner}\/{repo}@
-- 
-- Star the given repo
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentPutStar
  :: Owner -- ^ "owner" -  owner of the repo to star
  -> Repo -- ^ "repo" -  name of the repo to star
  -> GiteaRequest UserCurrentPutStar MimeNoContent NoContent MimeNoContent
userCurrentPutStar (Owner owner) (Repo repo) =
  _mkRequest "PUT" ["/user/starred/",toPath owner,"/",toPath repo]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentPutStar  
instance Produces UserCurrentPutStar MimeNoContent


-- *** userCurrentTrackedTimes

-- | @GET \/user\/times@
-- 
-- List the current user's tracked times
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userCurrentTrackedTimes
  :: GiteaRequest UserCurrentTrackedTimes MimeNoContent [TrackedTime] MimeJSON
userCurrentTrackedTimes =
  _mkRequest "GET" ["/user/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserCurrentTrackedTimes  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserCurrentTrackedTimes Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserCurrentTrackedTimes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "since" - Only show times updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam UserCurrentTrackedTimes Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show times updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam UserCurrentTrackedTimes Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)
-- | @application/json@
instance Produces UserCurrentTrackedTimes MimeJSON


-- *** userDeleteAccessToken

-- | @DELETE \/users\/{username}\/tokens\/{token}@
-- 
-- delete an access token
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteAccessToken
  :: Username -- ^ "username" -  username of user
  -> Token -- ^ "token" -  token to be deleted, identified by ID and if not available by name
  -> GiteaRequest UserDeleteAccessToken MimeNoContent NoContent MimeNoContent
userDeleteAccessToken (Username username) (Token token) =
  _mkRequest "DELETE" ["/users/",toPath username,"/tokens/",toPath token]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteAccessToken  
instance Produces UserDeleteAccessToken MimeNoContent


-- *** userDeleteEmail

-- | @DELETE \/user\/emails@
-- 
-- Delete email addresses
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteEmail
  :: (Consumes UserDeleteEmail contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> GiteaRequest UserDeleteEmail contentType NoContent MimeNoContent
userDeleteEmail _ =
  _mkRequest "DELETE" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteEmail 
instance HasBodyParam UserDeleteEmail DeleteEmailOption 

-- | @application/json@
instance Consumes UserDeleteEmail MimeJSON
-- | @text/plain@
instance Consumes UserDeleteEmail MimePlainText

instance Produces UserDeleteEmail MimeNoContent


-- *** userDeleteHook

-- | @DELETE \/user\/hooks\/{id}@
-- 
-- Delete a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteHook
  :: Id -- ^ "id" -  id of the hook to delete
  -> GiteaRequest UserDeleteHook MimeNoContent NoContent MimeNoContent
userDeleteHook (Id id) =
  _mkRequest "DELETE" ["/user/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteHook  
instance Produces UserDeleteHook MimeNoContent


-- *** userDeleteOAuth2Application

-- | @DELETE \/user\/applications\/oauth2\/{id}@
-- 
-- delete an OAuth2 Application
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userDeleteOAuth2Application
  :: Id -- ^ "id" -  token to be deleted
  -> GiteaRequest UserDeleteOAuth2Application MimeNoContent NoContent MimeNoContent
userDeleteOAuth2Application (Id id) =
  _mkRequest "DELETE" ["/user/applications/oauth2/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserDeleteOAuth2Application  
instance Produces UserDeleteOAuth2Application MimeNoContent


-- *** userEditHook

-- | @PATCH \/user\/hooks\/{id}@
-- 
-- Update a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userEditHook
  :: (Consumes UserEditHook MimeJSON)
  => Id -- ^ "id" -  id of the hook to update
  -> GiteaRequest UserEditHook MimeJSON Hook MimeJSON
userEditHook (Id id) =
  _mkRequest "PATCH" ["/user/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserEditHook 
instance HasBodyParam UserEditHook EditHookOption 

-- | @application/json@
instance Consumes UserEditHook MimeJSON

-- | @application/json@
instance Produces UserEditHook MimeJSON


-- *** userGet

-- | @GET \/users\/{username}@
-- 
-- Get a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGet
  :: Username -- ^ "username" -  username of user to get
  -> GiteaRequest UserGet MimeNoContent User MimeJSON
userGet (Username username) =
  _mkRequest "GET" ["/users/",toPath username]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGet  
-- | @application/json@
instance Produces UserGet MimeJSON


-- *** userGetCurrent

-- | @GET \/user@
-- 
-- Get the authenticated user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetCurrent
  :: GiteaRequest UserGetCurrent MimeNoContent User MimeJSON
userGetCurrent =
  _mkRequest "GET" ["/user"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetCurrent  
-- | @application/json@
instance Produces UserGetCurrent MimeJSON


-- *** userGetHeatmapData

-- | @GET \/users\/{username}\/heatmap@
-- 
-- Get a user's heatmap
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetHeatmapData
  :: Username -- ^ "username" -  username of user to get
  -> GiteaRequest UserGetHeatmapData MimeNoContent [UserHeatmapData] MimeJSON
userGetHeatmapData (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/heatmap"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetHeatmapData  
-- | @application/json@
instance Produces UserGetHeatmapData MimeJSON


-- *** userGetHook

-- | @GET \/user\/hooks\/{id}@
-- 
-- Get a hook
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetHook
  :: Id -- ^ "id" -  id of the hook to get
  -> GiteaRequest UserGetHook MimeNoContent Hook MimeJSON
userGetHook (Id id) =
  _mkRequest "GET" ["/user/hooks/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetHook  
-- | @application/json@
instance Produces UserGetHook MimeJSON


-- *** userGetOAuth2Application

-- | @GET \/user\/applications\/oauth2\/{id}@
-- 
-- get an OAuth2 Application
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetOAuth2Application
  :: Id -- ^ "id" -  Application ID to be found
  -> GiteaRequest UserGetOAuth2Application MimeNoContent OAuth2Application MimeJSON
userGetOAuth2Application (Id id) =
  _mkRequest "GET" ["/user/applications/oauth2/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetOAuth2Application  
-- | @application/json@
instance Produces UserGetOAuth2Application MimeJSON


-- *** userGetOauth2Application

-- | @GET \/user\/applications\/oauth2@
-- 
-- List the authenticated user's oauth2 applications
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetOauth2Application
  :: GiteaRequest UserGetOauth2Application MimeNoContent [OAuth2Application] MimeJSON
userGetOauth2Application =
  _mkRequest "GET" ["/user/applications/oauth2"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetOauth2Application  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserGetOauth2Application Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserGetOauth2Application Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserGetOauth2Application MimeJSON


-- *** userGetStopWatches

-- | @GET \/user\/stopwatches@
-- 
-- Get list of all existing stopwatches
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetStopWatches
  :: GiteaRequest UserGetStopWatches MimeNoContent [StopWatch] MimeJSON
userGetStopWatches =
  _mkRequest "GET" ["/user/stopwatches"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetStopWatches  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserGetStopWatches Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserGetStopWatches Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserGetStopWatches MimeJSON


-- *** userGetTokens

-- | @GET \/users\/{username}\/tokens@
-- 
-- List the authenticated user's access tokens
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userGetTokens
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserGetTokens MimeNoContent [AccessToken] MimeJSON
userGetTokens (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserGetTokens  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserGetTokens Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserGetTokens Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserGetTokens MimeJSON


-- *** userListActivityFeeds

-- | @GET \/users\/{username}\/activities\/feeds@
-- 
-- List a user's activity feeds
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListActivityFeeds
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListActivityFeeds MimeNoContent [Activity] MimeJSON
userListActivityFeeds (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/activities/feeds"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListActivityFeeds  

-- | /Optional Param/ "only-performed-by" - if true, only show actions performed by the requested user
instance HasOptionalParam UserListActivityFeeds OnlyPerformedBy where
  applyOptionalParam req (OnlyPerformedBy xs) =
    req `addQuery` toQuery ("only-performed-by", Just xs)

-- | /Optional Param/ "date" - the date of the activities to be found
instance HasOptionalParam UserListActivityFeeds ParamDate where
  applyOptionalParam req (ParamDate xs) =
    req `addQuery` toQuery ("date", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListActivityFeeds Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListActivityFeeds Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListActivityFeeds MimeJSON


-- *** userListEmails

-- | @GET \/user\/emails@
-- 
-- List the authenticated user's email addresses
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListEmails
  :: GiteaRequest UserListEmails MimeNoContent [Email] MimeJSON
userListEmails =
  _mkRequest "GET" ["/user/emails"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListEmails  
-- | @application/json@
instance Produces UserListEmails MimeJSON


-- *** userListFollowers

-- | @GET \/users\/{username}\/followers@
-- 
-- List the given user's followers
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListFollowers
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListFollowers MimeNoContent [User] MimeJSON
userListFollowers (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/followers"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListFollowers  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListFollowers Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListFollowers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListFollowers MimeJSON


-- *** userListFollowing

-- | @GET \/users\/{username}\/following@
-- 
-- List the users that the given user is following
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListFollowing
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListFollowing MimeNoContent [User] MimeJSON
userListFollowing (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/following"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListFollowing  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListFollowing Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListFollowing Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListFollowing MimeJSON


-- *** userListGPGKeys

-- | @GET \/users\/{username}\/gpg_keys@
-- 
-- List the given user's GPG keys
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListGPGKeys
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListGPGKeys MimeNoContent [GPGKey] MimeJSON
userListGPGKeys (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/gpg_keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListGPGKeys  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListGPGKeys Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListGPGKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListGPGKeys MimeJSON


-- *** userListHooks

-- | @GET \/user\/hooks@
-- 
-- List the authenticated user's webhooks
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListHooks
  :: GiteaRequest UserListHooks MimeNoContent [Hook] MimeJSON
userListHooks =
  _mkRequest "GET" ["/user/hooks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListHooks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListHooks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListHooks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListHooks MimeJSON


-- *** userListKeys

-- | @GET \/users\/{username}\/keys@
-- 
-- List the given user's public keys
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListKeys
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListKeys MimeNoContent [PublicKey] MimeJSON
userListKeys (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/keys"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListKeys  

-- | /Optional Param/ "fingerprint" - fingerprint of the key
instance HasOptionalParam UserListKeys Fingerprint where
  applyOptionalParam req (Fingerprint xs) =
    req `addQuery` toQuery ("fingerprint", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListKeys Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListKeys Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListKeys MimeJSON


-- *** userListRepos

-- | @GET \/users\/{username}\/repos@
-- 
-- List the repos owned by the given user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListRepos
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListRepos MimeNoContent [Repository] MimeJSON
userListRepos (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/repos"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListRepos  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListRepos Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListRepos Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListRepos MimeJSON


-- *** userListStarred

-- | @GET \/users\/{username}\/starred@
-- 
-- The repos that the given user has starred
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListStarred
  :: Username -- ^ "username" -  username of user
  -> GiteaRequest UserListStarred MimeNoContent [Repository] MimeJSON
userListStarred (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/starred"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListStarred  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListStarred Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListStarred Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListStarred MimeJSON


-- *** userListSubscriptions

-- | @GET \/users\/{username}\/subscriptions@
-- 
-- List the repositories watched by a user
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListSubscriptions
  :: Username -- ^ "username" -  username of the user
  -> GiteaRequest UserListSubscriptions MimeNoContent [Repository] MimeJSON
userListSubscriptions (Username username) =
  _mkRequest "GET" ["/users/",toPath username,"/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListSubscriptions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListSubscriptions Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListSubscriptions Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListSubscriptions MimeJSON


-- *** userListTeams

-- | @GET \/user\/teams@
-- 
-- List all the teams a user belongs to
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userListTeams
  :: GiteaRequest UserListTeams MimeNoContent [Team] MimeJSON
userListTeams =
  _mkRequest "GET" ["/user/teams"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserListTeams  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserListTeams Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserListTeams Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserListTeams MimeJSON


-- *** userSearch

-- | @GET \/users\/search@
-- 
-- Search for users
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userSearch
  :: GiteaRequest UserSearch MimeNoContent UserSearch200Response MimeJSON
userSearch =
  _mkRequest "GET" ["/users/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserSearch  

-- | /Optional Param/ "q" - keyword
instance HasOptionalParam UserSearch Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "uid" - ID of the user to search for
instance HasOptionalParam UserSearch Uid where
  applyOptionalParam req (Uid xs) =
    req `addQuery` toQuery ("uid", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam UserSearch Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam UserSearch Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces UserSearch MimeJSON


-- *** userUpdateOAuth2Application

-- | @PATCH \/user\/applications\/oauth2\/{id}@
-- 
-- update an OAuth2 Application, this includes regenerating the client secret
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userUpdateOAuth2Application
  :: (Consumes UserUpdateOAuth2Application contentType, MimeRender contentType CreateOAuth2ApplicationOptions)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> CreateOAuth2ApplicationOptions -- ^ "body"
  -> Id -- ^ "id" -  application to be updated
  -> GiteaRequest UserUpdateOAuth2Application contentType OAuth2Application MimeJSON
userUpdateOAuth2Application _ body (Id id) =
  _mkRequest "PATCH" ["/user/applications/oauth2/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `setBodyParam` body

data UserUpdateOAuth2Application 
instance HasBodyParam UserUpdateOAuth2Application CreateOAuth2ApplicationOptions 

-- | @application/json@
instance Consumes UserUpdateOAuth2Application MimeJSON
-- | @text/plain@
instance Consumes UserUpdateOAuth2Application MimePlainText

-- | @application/json@
instance Produces UserUpdateOAuth2Application MimeJSON


-- *** userVerifyGPGKey

-- | @POST \/user\/gpg_key_verify@
-- 
-- Verify a GPG key
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
userVerifyGPGKey
  :: GiteaRequest UserVerifyGPGKey MimeNoContent GPGKey MimeJSON
userVerifyGPGKey =
  _mkRequest "POST" ["/user/gpg_key_verify"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UserVerifyGPGKey  
-- | @application/json@
instance Produces UserVerifyGPGKey MimeJSON

