{-
   Gitea API

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API API version: 1.21.11
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Issue
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Issue where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Issue

-- *** issueAddLabel

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Add a label to an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueAddLabel
  :: (Consumes IssueAddLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueAddLabel MimeJSON [Label] MimeJSON
issueAddLabel (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddLabel 
instance HasBodyParam IssueAddLabel IssueLabelsOption 

-- | @application/json@
instance Consumes IssueAddLabel MimeJSON

-- | @application/json@
instance Produces IssueAddLabel MimeJSON


-- *** issueAddSubscription

-- | @PUT \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/{user}@
-- 
-- Subscribe user to issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueAddSubscription
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> User2 -- ^ "user" -  user to subscribe
  -> GiteaRequest IssueAddSubscription MimeNoContent NoContent MimeNoContent
issueAddSubscription (Owner owner) (Repo repo) (Index index) (User2 user) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddSubscription  
instance Produces IssueAddSubscription MimeNoContent


-- *** issueAddTime

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- Add tracked time to a issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueAddTime
  :: (Consumes IssueAddTime MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueAddTime MimeJSON TrackedTime MimeJSON
issueAddTime (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddTime 
instance HasBodyParam IssueAddTime AddTimeOption 

-- | @application/json@
instance Consumes IssueAddTime MimeJSON

-- | @application/json@
instance Produces IssueAddTime MimeJSON


-- *** issueCheckSubscription

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/check@
-- 
-- Check if user is subscribed to an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCheckSubscription
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCheckSubscription MimeNoContent WatchInfo MimeJSON
issueCheckSubscription (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/check"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCheckSubscription  
-- | @application/json@
instance Produces IssueCheckSubscription MimeJSON


-- *** issueClearLabels

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Remove all labels from an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueClearLabels
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueClearLabels MimeNoContent NoContent MimeNoContent
issueClearLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueClearLabels  
instance Produces IssueClearLabels MimeNoContent


-- *** issueCreateComment

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/comments@
-- 
-- Add a comment to an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateComment
  :: (Consumes IssueCreateComment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCreateComment MimeJSON Comment MimeJSON
issueCreateComment (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateComment 
instance HasBodyParam IssueCreateComment CreateIssueCommentOption 

-- | @application/json@
instance Consumes IssueCreateComment MimeJSON

-- | @application/json@
instance Produces IssueCreateComment MimeJSON


-- *** issueCreateIssue

-- | @POST \/repos\/{owner}\/{repo}\/issues@
-- 
-- Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateIssue
  :: (Consumes IssueCreateIssue MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateIssue MimeJSON Issue MimeJSON
issueCreateIssue (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateIssue 
instance HasBodyParam IssueCreateIssue CreateIssueOption 

-- | @application/json@
instance Consumes IssueCreateIssue MimeJSON

-- | @application/json@
instance Produces IssueCreateIssue MimeJSON


-- *** issueCreateIssueAttachment

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/assets@
-- 
-- Create an issue attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateIssueAttachment
  :: (Consumes IssueCreateIssueAttachment MimeMultipartFormData)
  => Attachment2 -- ^ "attachment" -  attachment to upload
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCreateIssueAttachment MimeMultipartFormData Attachment MimeJSON
issueCreateIssueAttachment (Attachment2 attachment) (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `_addMultiFormPart` NH.partFileSource "attachment" attachment

data IssueCreateIssueAttachment  

-- | /Optional Param/ "name" - name of the attachment
instance HasOptionalParam IssueCreateIssueAttachment Name where
  applyOptionalParam req (Name xs) =
    req `addQuery` toQuery ("name", Just xs)

-- | @multipart/form-data@
instance Consumes IssueCreateIssueAttachment MimeMultipartFormData

-- | @application/json@
instance Produces IssueCreateIssueAttachment MimeJSON


-- *** issueCreateIssueBlocking

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/blocks@
-- 
-- Block the issue given in the body by the issue in path
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateIssueBlocking
  :: (Consumes IssueCreateIssueBlocking contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCreateIssueBlocking contentType Issue MimeJSON
issueCreateIssueBlocking _ (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/blocks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateIssueBlocking 
instance HasBodyParam IssueCreateIssueBlocking IssueMeta 

-- | @application/json@
instance Consumes IssueCreateIssueBlocking MimeJSON
-- | @text/plain@
instance Consumes IssueCreateIssueBlocking MimePlainText

-- | @application/json@
instance Produces IssueCreateIssueBlocking MimeJSON


-- *** issueCreateIssueCommentAttachment

-- | @POST \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/assets@
-- 
-- Create a comment attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateIssueCommentAttachment
  :: (Consumes IssueCreateIssueCommentAttachment MimeMultipartFormData)
  => Attachment2 -- ^ "attachment" -  attachment to upload
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> GiteaRequest IssueCreateIssueCommentAttachment MimeMultipartFormData Attachment MimeJSON
issueCreateIssueCommentAttachment (Attachment2 attachment) (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)
    `_addMultiFormPart` NH.partFileSource "attachment" attachment

data IssueCreateIssueCommentAttachment  

-- | /Optional Param/ "name" - name of the attachment
instance HasOptionalParam IssueCreateIssueCommentAttachment Name where
  applyOptionalParam req (Name xs) =
    req `addQuery` toQuery ("name", Just xs)

-- | @multipart/form-data@
instance Consumes IssueCreateIssueCommentAttachment MimeMultipartFormData

-- | @application/json@
instance Produces IssueCreateIssueCommentAttachment MimeJSON


-- *** issueCreateIssueDependencies

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/dependencies@
-- 
-- Make the issue in the url depend on the issue in the form.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateIssueDependencies
  :: (Consumes IssueCreateIssueDependencies contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCreateIssueDependencies contentType Issue MimeJSON
issueCreateIssueDependencies _ (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/dependencies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateIssueDependencies 
instance HasBodyParam IssueCreateIssueDependencies IssueMeta 

-- | @application/json@
instance Consumes IssueCreateIssueDependencies MimeJSON
-- | @text/plain@
instance Consumes IssueCreateIssueDependencies MimePlainText

-- | @application/json@
instance Produces IssueCreateIssueDependencies MimeJSON


-- *** issueCreateLabel

-- | @POST \/repos\/{owner}\/{repo}\/labels@
-- 
-- Create a label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateLabel
  :: (Consumes IssueCreateLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateLabel MimeJSON Label MimeJSON
issueCreateLabel (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateLabel 
instance HasBodyParam IssueCreateLabel CreateLabelOption 

-- | @application/json@
instance Consumes IssueCreateLabel MimeJSON

-- | @application/json@
instance Produces IssueCreateLabel MimeJSON


-- *** issueCreateMilestone

-- | @POST \/repos\/{owner}\/{repo}\/milestones@
-- 
-- Create a milestone
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueCreateMilestone
  :: (Consumes IssueCreateMilestone MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateMilestone MimeJSON Milestone MimeJSON
issueCreateMilestone (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/milestones"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateMilestone 
instance HasBodyParam IssueCreateMilestone CreateMilestoneOption 

-- | @application/json@
instance Consumes IssueCreateMilestone MimeJSON

-- | @application/json@
instance Produces IssueCreateMilestone MimeJSON


-- *** issueDelete

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}@
-- 
-- Delete an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDelete
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of issue to delete
  -> GiteaRequest IssueDelete MimeNoContent NoContent MimeNoContent
issueDelete (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDelete  
instance Produces IssueDelete MimeNoContent


-- *** issueDeleteComment

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Delete a comment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteComment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of comment to delete
  -> GiteaRequest IssueDeleteComment MimeNoContent NoContent MimeNoContent
issueDeleteComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteComment  
instance Produces IssueDeleteComment MimeNoContent


-- *** issueDeleteCommentDeprecated

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/comments\/{id}@
-- 
-- Delete a comment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteCommentDeprecated
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexInt -- ^ "index" -  this parameter is ignored
  -> Id -- ^ "id" -  id of comment to delete
  -> GiteaRequest IssueDeleteCommentDeprecated MimeNoContent NoContent MimeNoContent
issueDeleteCommentDeprecated (Owner owner) (Repo repo) (IndexInt index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED issueDeleteCommentDeprecated "" #-}

data IssueDeleteCommentDeprecated  
instance Produces IssueDeleteCommentDeprecated MimeNoContent


-- *** issueDeleteCommentReaction

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Remove a reaction from a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteCommentReaction
  :: (Consumes IssueDeleteCommentReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueDeleteCommentReaction MimeJSON NoContent MimeNoContent
issueDeleteCommentReaction (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteCommentReaction 
instance HasBodyParam IssueDeleteCommentReaction EditReactionOption 

-- | @application/json@
instance Consumes IssueDeleteCommentReaction MimeJSON

instance Produces IssueDeleteCommentReaction MimeNoContent


-- *** issueDeleteIssueAttachment

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/assets\/{attachment_id}@
-- 
-- Delete an issue attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteIssueAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to delete
  -> GiteaRequest IssueDeleteIssueAttachment MimeNoContent NoContent MimeNoContent
issueDeleteIssueAttachment (Owner owner) (Repo repo) (Index index) (AttachmentId attachmentId) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteIssueAttachment  
instance Produces IssueDeleteIssueAttachment MimeNoContent


-- *** issueDeleteIssueCommentAttachment

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/assets\/{attachment_id}@
-- 
-- Delete a comment attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteIssueCommentAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to delete
  -> GiteaRequest IssueDeleteIssueCommentAttachment MimeNoContent NoContent MimeNoContent
issueDeleteIssueCommentAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteIssueCommentAttachment  
instance Produces IssueDeleteIssueCommentAttachment MimeNoContent


-- *** issueDeleteIssueReaction

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Remove a reaction from an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteIssueReaction
  :: (Consumes IssueDeleteIssueReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueDeleteIssueReaction MimeJSON NoContent MimeNoContent
issueDeleteIssueReaction (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteIssueReaction 
instance HasBodyParam IssueDeleteIssueReaction EditReactionOption 

-- | @application/json@
instance Consumes IssueDeleteIssueReaction MimeJSON

instance Produces IssueDeleteIssueReaction MimeNoContent


-- *** issueDeleteLabel

-- | @DELETE \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Delete a label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteLabel
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to delete
  -> GiteaRequest IssueDeleteLabel MimeNoContent NoContent MimeNoContent
issueDeleteLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteLabel  
instance Produces IssueDeleteLabel MimeNoContent


-- *** issueDeleteMilestone

-- | @DELETE \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Delete a milestone
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteMilestone
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to delete, identified by ID and if not available by name
  -> GiteaRequest IssueDeleteMilestone MimeNoContent NoContent MimeNoContent
issueDeleteMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteMilestone  
instance Produces IssueDeleteMilestone MimeNoContent


-- *** issueDeleteStopWatch

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/delete@
-- 
-- Delete an issue's existing stopwatch.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteStopWatch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to stop the stopwatch on
  -> GiteaRequest IssueDeleteStopWatch MimeNoContent NoContent MimeNoContent
issueDeleteStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/delete"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteStopWatch  
instance Produces IssueDeleteStopWatch MimeNoContent


-- *** issueDeleteSubscription

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/{user}@
-- 
-- Unsubscribe user from issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteSubscription
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> User2 -- ^ "user" -  user witch unsubscribe
  -> GiteaRequest IssueDeleteSubscription MimeNoContent NoContent MimeNoContent
issueDeleteSubscription (Owner owner) (Repo repo) (Index index) (User2 user) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteSubscription  
instance Produces IssueDeleteSubscription MimeNoContent


-- *** issueDeleteTime

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/times\/{id}@
-- 
-- Delete specific tracked time
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueDeleteTime
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> Id -- ^ "id" -  id of time to delete
  -> GiteaRequest IssueDeleteTime MimeNoContent NoContent MimeNoContent
issueDeleteTime (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteTime  
instance Produces IssueDeleteTime MimeNoContent


-- *** issueEditComment

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Edit a comment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditComment
  :: (Consumes IssueEditComment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueEditComment MimeJSON Comment MimeJSON
issueEditComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditComment 
instance HasBodyParam IssueEditComment EditIssueCommentOption 

-- | @application/json@
instance Consumes IssueEditComment MimeJSON

-- | @application/json@
instance Produces IssueEditComment MimeJSON


-- *** issueEditCommentDeprecated

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}\/comments\/{id}@
-- 
-- Edit a comment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditCommentDeprecated
  :: (Consumes IssueEditCommentDeprecated MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexInt -- ^ "index" -  this parameter is ignored
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueEditCommentDeprecated MimeJSON Comment MimeJSON
issueEditCommentDeprecated (Owner owner) (Repo repo) (IndexInt index) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED issueEditCommentDeprecated "" #-}

data IssueEditCommentDeprecated 
instance HasBodyParam IssueEditCommentDeprecated EditIssueCommentOption 

-- | @application/json@
instance Consumes IssueEditCommentDeprecated MimeJSON

-- | @application/json@
instance Produces IssueEditCommentDeprecated MimeJSON


-- *** issueEditIssue

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}@
-- 
-- Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditIssue
  :: (Consumes IssueEditIssue MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to edit
  -> GiteaRequest IssueEditIssue MimeJSON Issue MimeJSON
issueEditIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssue 
instance HasBodyParam IssueEditIssue EditIssueOption 

-- | @application/json@
instance Consumes IssueEditIssue MimeJSON

-- | @application/json@
instance Produces IssueEditIssue MimeJSON


-- *** issueEditIssueAttachment

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}\/assets\/{attachment_id}@
-- 
-- Edit an issue attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditIssueAttachment
  :: (Consumes IssueEditIssueAttachment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to edit
  -> GiteaRequest IssueEditIssueAttachment MimeJSON Attachment MimeJSON
issueEditIssueAttachment (Owner owner) (Repo repo) (Index index) (AttachmentId attachmentId) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssueAttachment 
instance HasBodyParam IssueEditIssueAttachment EditAttachmentOptions 

-- | @application/json@
instance Consumes IssueEditIssueAttachment MimeJSON

-- | @application/json@
instance Produces IssueEditIssueAttachment MimeJSON


-- *** issueEditIssueCommentAttachment

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/assets\/{attachment_id}@
-- 
-- Edit a comment attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditIssueCommentAttachment
  :: (Consumes IssueEditIssueCommentAttachment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to edit
  -> GiteaRequest IssueEditIssueCommentAttachment MimeJSON Attachment MimeJSON
issueEditIssueCommentAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssueCommentAttachment 
instance HasBodyParam IssueEditIssueCommentAttachment EditAttachmentOptions 

-- | @application/json@
instance Consumes IssueEditIssueCommentAttachment MimeJSON

-- | @application/json@
instance Produces IssueEditIssueCommentAttachment MimeJSON


-- *** issueEditIssueDeadline

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/deadline@
-- 
-- Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditIssueDeadline
  :: (Consumes IssueEditIssueDeadline MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to create or update a deadline on
  -> GiteaRequest IssueEditIssueDeadline MimeJSON IssueDeadline MimeJSON
issueEditIssueDeadline (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/deadline"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssueDeadline 
instance HasBodyParam IssueEditIssueDeadline EditDeadlineOption 

-- | @application/json@
instance Consumes IssueEditIssueDeadline MimeJSON

-- | @application/json@
instance Produces IssueEditIssueDeadline MimeJSON


-- *** issueEditLabel

-- | @PATCH \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Update a label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditLabel
  :: (Consumes IssueEditLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to edit
  -> GiteaRequest IssueEditLabel MimeJSON Label MimeJSON
issueEditLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditLabel 
instance HasBodyParam IssueEditLabel EditLabelOption 

-- | @application/json@
instance Consumes IssueEditLabel MimeJSON

-- | @application/json@
instance Produces IssueEditLabel MimeJSON


-- *** issueEditMilestone

-- | @PATCH \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Update a milestone
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueEditMilestone
  :: (Consumes IssueEditMilestone MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to edit, identified by ID and if not available by name
  -> GiteaRequest IssueEditMilestone MimeJSON Milestone MimeJSON
issueEditMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditMilestone 
instance HasBodyParam IssueEditMilestone EditMilestoneOption 

-- | @application/json@
instance Consumes IssueEditMilestone MimeJSON

-- | @application/json@
instance Produces IssueEditMilestone MimeJSON


-- *** issueGetComment

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Get a comment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetComment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> GiteaRequest IssueGetComment MimeNoContent Comment MimeJSON
issueGetComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetComment  
-- | @application/json@
instance Produces IssueGetComment MimeJSON


-- *** issueGetCommentReactions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Get a list of reactions from a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetCommentReactions
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueGetCommentReactions MimeNoContent [Reaction] MimeJSON
issueGetCommentReactions (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetCommentReactions  
-- | @application/json@
instance Produces IssueGetCommentReactions MimeJSON


-- *** issueGetComments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/comments@
-- 
-- List all comments on an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetComments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetComments MimeNoContent [Comment] MimeJSON
issueGetComments (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetComments  

-- | /Optional Param/ "since" - if provided, only comments updated since the specified time are returned.
instance HasOptionalParam IssueGetComments Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - if provided, only comments updated before the provided time are returned.
instance HasOptionalParam IssueGetComments Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)
-- | @application/json@
instance Produces IssueGetComments MimeJSON


-- *** issueGetCommentsAndTimeline

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/timeline@
-- 
-- List all comments and events on an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetCommentsAndTimeline
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetCommentsAndTimeline MimeNoContent [TimelineComment] MimeJSON
issueGetCommentsAndTimeline (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/timeline"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetCommentsAndTimeline  

-- | /Optional Param/ "since" - if provided, only comments updated since the specified time are returned.
instance HasOptionalParam IssueGetCommentsAndTimeline Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetCommentsAndTimeline Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetCommentsAndTimeline Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "before" - if provided, only comments updated before the provided time are returned.
instance HasOptionalParam IssueGetCommentsAndTimeline Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)
-- | @application/json@
instance Produces IssueGetCommentsAndTimeline MimeJSON


-- *** issueGetIssue

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}@
-- 
-- Get an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetIssue
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to get
  -> GiteaRequest IssueGetIssue MimeNoContent Issue MimeJSON
issueGetIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssue  
-- | @application/json@
instance Produces IssueGetIssue MimeJSON


-- *** issueGetIssueAttachment

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/assets\/{attachment_id}@
-- 
-- Get an issue attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetIssueAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to get
  -> GiteaRequest IssueGetIssueAttachment MimeNoContent Attachment MimeJSON
issueGetIssueAttachment (Owner owner) (Repo repo) (Index index) (AttachmentId attachmentId) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssueAttachment  
-- | @application/json@
instance Produces IssueGetIssueAttachment MimeJSON


-- *** issueGetIssueCommentAttachment

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/assets\/{attachment_id}@
-- 
-- Get a comment attachment
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetIssueCommentAttachment
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> AttachmentId -- ^ "attachmentId" -  id of the attachment to get
  -> GiteaRequest IssueGetIssueCommentAttachment MimeNoContent Attachment MimeJSON
issueGetIssueCommentAttachment (Owner owner) (Repo repo) (Id id) (AttachmentId attachmentId) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/assets/",toPath attachmentId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssueCommentAttachment  
-- | @application/json@
instance Produces IssueGetIssueCommentAttachment MimeJSON


-- *** issueGetIssueReactions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Get a list reactions of an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetIssueReactions
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetIssueReactions MimeNoContent [Reaction] MimeJSON
issueGetIssueReactions (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssueReactions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetIssueReactions Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetIssueReactions Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetIssueReactions MimeJSON


-- *** issueGetLabel

-- | @GET \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Get a single label
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetLabel
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to get
  -> GiteaRequest IssueGetLabel MimeNoContent Label MimeJSON
issueGetLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetLabel  
-- | @application/json@
instance Produces IssueGetLabel MimeJSON


-- *** issueGetLabels

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Get an issue's labels
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetLabels
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetLabels MimeNoContent [Label] MimeJSON
issueGetLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetLabels  
-- | @application/json@
instance Produces IssueGetLabels MimeJSON


-- *** issueGetMilestone

-- | @GET \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Get a milestone
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetMilestone
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to get, identified by ID and if not available by name
  -> GiteaRequest IssueGetMilestone MimeNoContent Milestone MimeJSON
issueGetMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetMilestone  
-- | @application/json@
instance Produces IssueGetMilestone MimeJSON


-- *** issueGetMilestonesList

-- | @GET \/repos\/{owner}\/{repo}\/milestones@
-- 
-- Get all of a repository's opened milestones
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetMilestonesList
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueGetMilestonesList MimeNoContent [Milestone] MimeJSON
issueGetMilestonesList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/milestones"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetMilestonesList  

-- | /Optional Param/ "state" - Milestone state, Recognized values are open, closed and all. Defaults to \"open\"
instance HasOptionalParam IssueGetMilestonesList State where
  applyOptionalParam req (State xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "name" - filter by milestone name
instance HasOptionalParam IssueGetMilestonesList Name where
  applyOptionalParam req (Name xs) =
    req `addQuery` toQuery ("name", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetMilestonesList Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetMilestonesList Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetMilestonesList MimeJSON


-- *** issueGetRepoComments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments@
-- 
-- List all comments in a repository
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueGetRepoComments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueGetRepoComments MimeNoContent [Comment] MimeJSON
issueGetRepoComments (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetRepoComments  

-- | /Optional Param/ "since" - if provided, only comments updated since the provided time are returned.
instance HasOptionalParam IssueGetRepoComments Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - if provided, only comments updated before the provided time are returned.
instance HasOptionalParam IssueGetRepoComments Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetRepoComments Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetRepoComments Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetRepoComments MimeJSON


-- *** issueListBlocks

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/blocks@
-- 
-- List issues that are blocked by this issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListBlocks
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueListBlocks MimeNoContent [Issue] MimeJSON
issueListBlocks (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/blocks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListBlocks  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListBlocks Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListBlocks Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListBlocks MimeJSON


-- *** issueListIssueAttachments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/assets@
-- 
-- List issue's attachments
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListIssueAttachments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueListIssueAttachments MimeNoContent [Attachment] MimeJSON
issueListIssueAttachments (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListIssueAttachments  
-- | @application/json@
instance Produces IssueListIssueAttachments MimeJSON


-- *** issueListIssueCommentAttachments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/assets@
-- 
-- List comment's attachments
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListIssueCommentAttachments
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> GiteaRequest IssueListIssueCommentAttachments MimeNoContent [Attachment] MimeJSON
issueListIssueCommentAttachments (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/assets"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListIssueCommentAttachments  
-- | @application/json@
instance Produces IssueListIssueCommentAttachments MimeJSON


-- *** issueListIssueDependencies

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/dependencies@
-- 
-- List an issue's dependencies, i.e all issues that block this issue.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListIssueDependencies
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueListIssueDependencies MimeNoContent [Issue] MimeJSON
issueListIssueDependencies (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/dependencies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListIssueDependencies  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListIssueDependencies Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListIssueDependencies Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListIssueDependencies MimeJSON


-- *** issueListIssues

-- | @GET \/repos\/{owner}\/{repo}\/issues@
-- 
-- List a repository's issues
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListIssues
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueListIssues MimeNoContent [Issue] MimeJSON
issueListIssues (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListIssues  

-- | /Optional Param/ "state" - whether issue is open or closed
instance HasOptionalParam IssueListIssues State3 where
  applyOptionalParam req (State3 xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "labels" - comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
instance HasOptionalParam IssueListIssues Labels where
  applyOptionalParam req (Labels xs) =
    req `addQuery` toQuery ("labels", Just xs)

-- | /Optional Param/ "q" - search string
instance HasOptionalParam IssueListIssues Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "type" - filter by type (issues / pulls) if set
instance HasOptionalParam IssueListIssues ParamType2 where
  applyOptionalParam req (ParamType2 xs) =
    req `addQuery` toQuery ("type", Just xs)

-- | /Optional Param/ "milestones" - comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
instance HasOptionalParam IssueListIssues Milestones where
  applyOptionalParam req (Milestones xs) =
    req `addQuery` toQuery ("milestones", Just xs)

-- | /Optional Param/ "since" - Only show items updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueListIssues Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show items updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueListIssues Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "created_by" - Only show items which were created by the the given user
instance HasOptionalParam IssueListIssues CreatedBy where
  applyOptionalParam req (CreatedBy xs) =
    req `addQuery` toQuery ("created_by", Just xs)

-- | /Optional Param/ "assigned_by" - Only show items for which the given user is assigned
instance HasOptionalParam IssueListIssues AssignedBy where
  applyOptionalParam req (AssignedBy xs) =
    req `addQuery` toQuery ("assigned_by", Just xs)

-- | /Optional Param/ "mentioned_by" - Only show items in which the given user was mentioned
instance HasOptionalParam IssueListIssues MentionedBy where
  applyOptionalParam req (MentionedBy xs) =
    req `addQuery` toQuery ("mentioned_by", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListIssues Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListIssues Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListIssues MimeJSON


-- *** issueListLabels

-- | @GET \/repos\/{owner}\/{repo}\/labels@
-- 
-- Get all of a repository's labels
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueListLabels
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueListLabels MimeNoContent [Label] MimeJSON
issueListLabels (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListLabels  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListLabels Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListLabels Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListLabels MimeJSON


-- *** issuePostCommentReaction

-- | @POST \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Add a reaction to a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issuePostCommentReaction
  :: (Consumes IssuePostCommentReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssuePostCommentReaction MimeJSON Reaction MimeJSON
issuePostCommentReaction (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssuePostCommentReaction 
instance HasBodyParam IssuePostCommentReaction EditReactionOption 

-- | @application/json@
instance Consumes IssuePostCommentReaction MimeJSON

-- | @application/json@
instance Produces IssuePostCommentReaction MimeJSON


-- *** issuePostIssueReaction

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Add a reaction to an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issuePostIssueReaction
  :: (Consumes IssuePostIssueReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssuePostIssueReaction MimeJSON Reaction MimeJSON
issuePostIssueReaction (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssuePostIssueReaction 
instance HasBodyParam IssuePostIssueReaction EditReactionOption 

-- | @application/json@
instance Consumes IssuePostIssueReaction MimeJSON

-- | @application/json@
instance Produces IssuePostIssueReaction MimeJSON


-- *** issueRemoveIssueBlocking

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/blocks@
-- 
-- Unblock the issue given in the body by the issue in path
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueRemoveIssueBlocking
  :: (Consumes IssueRemoveIssueBlocking contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueRemoveIssueBlocking contentType Issue MimeJSON
issueRemoveIssueBlocking _ (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/blocks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueRemoveIssueBlocking 
instance HasBodyParam IssueRemoveIssueBlocking IssueMeta 

-- | @application/json@
instance Consumes IssueRemoveIssueBlocking MimeJSON
-- | @text/plain@
instance Consumes IssueRemoveIssueBlocking MimePlainText

-- | @application/json@
instance Produces IssueRemoveIssueBlocking MimeJSON


-- *** issueRemoveIssueDependencies

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/dependencies@
-- 
-- Remove an issue dependency
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueRemoveIssueDependencies
  :: (Consumes IssueRemoveIssueDependencies contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexText -- ^ "index" -  index of the issue
  -> GiteaRequest IssueRemoveIssueDependencies contentType Issue MimeJSON
issueRemoveIssueDependencies _ (Owner owner) (Repo repo) (IndexText index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/dependencies"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueRemoveIssueDependencies 
instance HasBodyParam IssueRemoveIssueDependencies IssueMeta 

-- | @application/json@
instance Consumes IssueRemoveIssueDependencies MimeJSON
-- | @text/plain@
instance Consumes IssueRemoveIssueDependencies MimePlainText

-- | @application/json@
instance Produces IssueRemoveIssueDependencies MimeJSON


-- *** issueRemoveLabel

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/labels\/{id}@
-- 
-- Remove a label from an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueRemoveLabel
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> Id -- ^ "id" -  id of the label to remove
  -> GiteaRequest IssueRemoveLabel MimeNoContent NoContent MimeNoContent
issueRemoveLabel (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueRemoveLabel  
instance Produces IssueRemoveLabel MimeNoContent


-- *** issueReplaceLabels

-- | @PUT \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Replace an issue's labels
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueReplaceLabels
  :: (Consumes IssueReplaceLabels MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueReplaceLabels MimeJSON [Label] MimeJSON
issueReplaceLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueReplaceLabels 
instance HasBodyParam IssueReplaceLabels IssueLabelsOption 

-- | @application/json@
instance Consumes IssueReplaceLabels MimeJSON

-- | @application/json@
instance Produces IssueReplaceLabels MimeJSON


-- *** issueResetTime

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- Reset a tracked time of an issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueResetTime
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to add tracked time to
  -> GiteaRequest IssueResetTime MimeNoContent NoContent MimeNoContent
issueResetTime (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueResetTime  
instance Produces IssueResetTime MimeNoContent


-- *** issueSearchIssues

-- | @GET \/repos\/issues\/search@
-- 
-- Search for issues across the repositories that the user has access to
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueSearchIssues
  :: GiteaRequest IssueSearchIssues MimeNoContent [Issue] MimeJSON
issueSearchIssues =
  _mkRequest "GET" ["/repos/issues/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueSearchIssues  

-- | /Optional Param/ "state" - whether issue is open or closed
instance HasOptionalParam IssueSearchIssues State where
  applyOptionalParam req (State xs) =
    req `addQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "labels" - comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
instance HasOptionalParam IssueSearchIssues Labels where
  applyOptionalParam req (Labels xs) =
    req `addQuery` toQuery ("labels", Just xs)

-- | /Optional Param/ "milestones" - comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
instance HasOptionalParam IssueSearchIssues Milestones where
  applyOptionalParam req (Milestones xs) =
    req `addQuery` toQuery ("milestones", Just xs)

-- | /Optional Param/ "q" - search string
instance HasOptionalParam IssueSearchIssues Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "priority_repo_id" - repository to prioritize in the results
instance HasOptionalParam IssueSearchIssues PriorityRepoId where
  applyOptionalParam req (PriorityRepoId xs) =
    req `addQuery` toQuery ("priority_repo_id", Just xs)

-- | /Optional Param/ "type" - filter by type (issues / pulls) if set
instance HasOptionalParam IssueSearchIssues ParamTypeText where
  applyOptionalParam req (ParamTypeText xs) =
    req `addQuery` toQuery ("type", Just xs)

-- | /Optional Param/ "since" - Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueSearchIssues Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueSearchIssues Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "assigned" - filter (issues / pulls) assigned to you, default is false
instance HasOptionalParam IssueSearchIssues Assigned where
  applyOptionalParam req (Assigned xs) =
    req `addQuery` toQuery ("assigned", Just xs)

-- | /Optional Param/ "created" - filter (issues / pulls) created by you, default is false
instance HasOptionalParam IssueSearchIssues Created where
  applyOptionalParam req (Created xs) =
    req `addQuery` toQuery ("created", Just xs)

-- | /Optional Param/ "mentioned" - filter (issues / pulls) mentioning you, default is false
instance HasOptionalParam IssueSearchIssues Mentioned where
  applyOptionalParam req (Mentioned xs) =
    req `addQuery` toQuery ("mentioned", Just xs)

-- | /Optional Param/ "review_requested" - filter pulls requesting your review, default is false
instance HasOptionalParam IssueSearchIssues ReviewRequested where
  applyOptionalParam req (ReviewRequested xs) =
    req `addQuery` toQuery ("review_requested", Just xs)

-- | /Optional Param/ "reviewed" - filter pulls reviewed by you, default is false
instance HasOptionalParam IssueSearchIssues Reviewed where
  applyOptionalParam req (Reviewed xs) =
    req `addQuery` toQuery ("reviewed", Just xs)

-- | /Optional Param/ "owner" - filter by owner
instance HasOptionalParam IssueSearchIssues Owner where
  applyOptionalParam req (Owner xs) =
    req `addQuery` toQuery ("owner", Just xs)

-- | /Optional Param/ "team" - filter by team (requires organization owner parameter to be provided)
instance HasOptionalParam IssueSearchIssues Team2 where
  applyOptionalParam req (Team2 xs) =
    req `addQuery` toQuery ("team", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueSearchIssues Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueSearchIssues Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueSearchIssues MimeJSON


-- *** issueStartStopWatch

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/start@
-- 
-- Start stopwatch on an issue.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueStartStopWatch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to create the stopwatch on
  -> GiteaRequest IssueStartStopWatch MimeNoContent NoContent MimeNoContent
issueStartStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/start"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueStartStopWatch  
instance Produces IssueStartStopWatch MimeNoContent


-- *** issueStopStopWatch

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/stop@
-- 
-- Stop an issue's existing stopwatch.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueStopStopWatch
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to stop the stopwatch on
  -> GiteaRequest IssueStopStopWatch MimeNoContent NoContent MimeNoContent
issueStopStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/stop"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueStopStopWatch  
instance Produces IssueStopStopWatch MimeNoContent


-- *** issueSubscriptions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions@
-- 
-- Get users who subscribed on an issue.
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueSubscriptions
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueSubscriptions MimeNoContent [User] MimeJSON
issueSubscriptions (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueSubscriptions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueSubscriptions Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueSubscriptions Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueSubscriptions MimeJSON


-- *** issueTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- List an issue's tracked times
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
issueTrackedTimes
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueTrackedTimes MimeNoContent [TrackedTime] MimeJSON
issueTrackedTimes (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueTrackedTimes  

-- | /Optional Param/ "user" - optional filter by user (available for issue managers)
instance HasOptionalParam IssueTrackedTimes User2 where
  applyOptionalParam req (User2 xs) =
    req `addQuery` toQuery ("user", Just xs)

-- | /Optional Param/ "since" - Only show times updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueTrackedTimes Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show times updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueTrackedTimes Before where
  applyOptionalParam req (Before xs) =
    req `addQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueTrackedTimes Page where
  applyOptionalParam req (Page xs) =
    req `addQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueTrackedTimes Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueTrackedTimes MimeJSON


-- *** moveIssuePin

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}\/pin\/{position}@
-- 
-- Moves the Pin to the given Position
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
moveIssuePin
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of issue
  -> Position -- ^ "position" -  the new position
  -> GiteaRequest MoveIssuePin MimeNoContent NoContent MimeNoContent
moveIssuePin (Owner owner) (Repo repo) (Index index) (Position position) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/pin/",toPath position]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data MoveIssuePin  
instance Produces MoveIssuePin MimeNoContent


-- *** pinIssue

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/pin@
-- 
-- Pin an Issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
pinIssue
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of issue to pin
  -> GiteaRequest PinIssue MimeNoContent NoContent MimeNoContent
pinIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/pin"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data PinIssue  
instance Produces PinIssue MimeNoContent


-- *** unpinIssue

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/pin@
-- 
-- Unpin an Issue
-- 
-- AuthMethod: 'AuthApiKeyTOTPHeader', 'AuthApiKeyAuthorizationHeaderToken', 'AuthApiKeySudoHeader', 'AuthBasicBasicAuth', 'AuthApiKeyAccessToken', 'AuthApiKeySudoParam', 'AuthApiKeyToken'
-- 
unpinIssue
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of issue to unpin
  -> GiteaRequest UnpinIssue MimeNoContent NoContent MimeNoContent
unpinIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/pin"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data UnpinIssue  
instance Produces UnpinIssue MimeNoContent

