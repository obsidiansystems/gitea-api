{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.15.9
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.API.Issue
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.API.Issue where

import Gitea.Core
import Gitea.MimeTypes
import Gitea.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Issue

-- *** issueAddLabel

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Add a label to an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueAddLabel 
  :: (Consumes IssueAddLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueAddLabel MimeJSON [Label] MimeJSON
issueAddLabel (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddLabel 
instance HasBodyParam IssueAddLabel IssueLabelsOption 

-- | @application/json@
instance Consumes IssueAddLabel MimeJSON

-- | @application/json@
instance Produces IssueAddLabel MimeJSON


-- *** issueAddSubscription

-- | @PUT \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/{user}@
-- 
-- Subscribe user to issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueAddSubscription 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> User2 -- ^ "user" -  user to subscribe
  -> GiteaRequest IssueAddSubscription MimeNoContent NoContent MimeNoContent
issueAddSubscription (Owner owner) (Repo repo) (Index index) (User2 user) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddSubscription  
instance Produces IssueAddSubscription MimeNoContent


-- *** issueAddTime

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- Add tracked time to a issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueAddTime 
  :: (Consumes IssueAddTime MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueAddTime MimeJSON TrackedTime MimeJSON
issueAddTime (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueAddTime 
instance HasBodyParam IssueAddTime AddTimeOption 

-- | @application/json@
instance Consumes IssueAddTime MimeJSON

-- | @application/json@
instance Produces IssueAddTime MimeJSON


-- *** issueCheckSubscription

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/check@
-- 
-- Check if user is subscribed to an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueCheckSubscription 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCheckSubscription MimeNoContent WatchInfo MimeJSON
issueCheckSubscription (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/check"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCheckSubscription  
-- | @application/json@
instance Produces IssueCheckSubscription MimeJSON


-- *** issueClearLabels

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Remove all labels from an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueClearLabels 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueClearLabels MimeNoContent NoContent MimeNoContent
issueClearLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueClearLabels  
instance Produces IssueClearLabels MimeNoContent


-- *** issueCreateComment

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/comments@
-- 
-- Add a comment to an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueCreateComment 
  :: (Consumes IssueCreateComment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueCreateComment MimeJSON Comment MimeJSON
issueCreateComment (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateComment 
instance HasBodyParam IssueCreateComment CreateIssueCommentOption 

-- | @application/json@
instance Consumes IssueCreateComment MimeJSON

-- | @application/json@
instance Produces IssueCreateComment MimeJSON


-- *** issueCreateIssue

-- | @POST \/repos\/{owner}\/{repo}\/issues@
-- 
-- Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueCreateIssue 
  :: (Consumes IssueCreateIssue MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateIssue MimeJSON Issue MimeJSON
issueCreateIssue (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateIssue 
instance HasBodyParam IssueCreateIssue CreateIssueOption 

-- | @application/json@
instance Consumes IssueCreateIssue MimeJSON

-- | @application/json@
instance Produces IssueCreateIssue MimeJSON


-- *** issueCreateLabel

-- | @POST \/repos\/{owner}\/{repo}\/labels@
-- 
-- Create a label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueCreateLabel 
  :: (Consumes IssueCreateLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateLabel MimeJSON Label MimeJSON
issueCreateLabel (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateLabel 
instance HasBodyParam IssueCreateLabel CreateLabelOption 

-- | @application/json@
instance Consumes IssueCreateLabel MimeJSON

-- | @application/json@
instance Produces IssueCreateLabel MimeJSON


-- *** issueCreateMilestone

-- | @POST \/repos\/{owner}\/{repo}\/milestones@
-- 
-- Create a milestone
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueCreateMilestone 
  :: (Consumes IssueCreateMilestone MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueCreateMilestone MimeJSON Milestone MimeJSON
issueCreateMilestone (Owner owner) (Repo repo) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/milestones"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueCreateMilestone 
instance HasBodyParam IssueCreateMilestone CreateMilestoneOption 

-- | @application/json@
instance Consumes IssueCreateMilestone MimeJSON

-- | @application/json@
instance Produces IssueCreateMilestone MimeJSON


-- *** issueDeleteComment

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Delete a comment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteComment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of comment to delete
  -> GiteaRequest IssueDeleteComment MimeNoContent NoContent MimeNoContent
issueDeleteComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteComment  
instance Produces IssueDeleteComment MimeNoContent


-- *** issueDeleteCommentDeprecated

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/comments\/{id}@
-- 
-- Delete a comment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteCommentDeprecated 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexInt -- ^ "index" -  this parameter is ignored
  -> Id -- ^ "id" -  id of comment to delete
  -> GiteaRequest IssueDeleteCommentDeprecated MimeNoContent NoContent MimeNoContent
issueDeleteCommentDeprecated (Owner owner) (Repo repo) (IndexInt index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED issueDeleteCommentDeprecated "" #-}

data IssueDeleteCommentDeprecated  
instance Produces IssueDeleteCommentDeprecated MimeNoContent


-- *** issueDeleteCommentReaction

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Remove a reaction from a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteCommentReaction 
  :: (Consumes IssueDeleteCommentReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueDeleteCommentReaction MimeJSON NoContent MimeNoContent
issueDeleteCommentReaction (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteCommentReaction 
instance HasBodyParam IssueDeleteCommentReaction EditReactionOption 

-- | @application/json@
instance Consumes IssueDeleteCommentReaction MimeJSON

instance Produces IssueDeleteCommentReaction MimeNoContent


-- *** issueDeleteIssueReaction

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Remove a reaction from an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteIssueReaction 
  :: (Consumes IssueDeleteIssueReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueDeleteIssueReaction MimeJSON NoContent MimeNoContent
issueDeleteIssueReaction (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteIssueReaction 
instance HasBodyParam IssueDeleteIssueReaction EditReactionOption 

-- | @application/json@
instance Consumes IssueDeleteIssueReaction MimeJSON

instance Produces IssueDeleteIssueReaction MimeNoContent


-- *** issueDeleteLabel

-- | @DELETE \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Delete a label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteLabel 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to delete
  -> GiteaRequest IssueDeleteLabel MimeNoContent NoContent MimeNoContent
issueDeleteLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteLabel  
instance Produces IssueDeleteLabel MimeNoContent


-- *** issueDeleteMilestone

-- | @DELETE \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Delete a milestone
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteMilestone 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to delete, identified by ID and if not available by name
  -> GiteaRequest IssueDeleteMilestone MimeNoContent NoContent MimeNoContent
issueDeleteMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteMilestone  
instance Produces IssueDeleteMilestone MimeNoContent


-- *** issueDeleteStopWatch

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/delete@
-- 
-- Delete an issue's existing stopwatch.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteStopWatch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to stop the stopwatch on
  -> GiteaRequest IssueDeleteStopWatch MimeNoContent NoContent MimeNoContent
issueDeleteStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/delete"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteStopWatch  
instance Produces IssueDeleteStopWatch MimeNoContent


-- *** issueDeleteSubscription

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions\/{user}@
-- 
-- Unsubscribe user from issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteSubscription 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> User2 -- ^ "user" -  user witch unsubscribe
  -> GiteaRequest IssueDeleteSubscription MimeNoContent NoContent MimeNoContent
issueDeleteSubscription (Owner owner) (Repo repo) (Index index) (User2 user) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions/",toPath user]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteSubscription  
instance Produces IssueDeleteSubscription MimeNoContent


-- *** issueDeleteTime

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/times\/{id}@
-- 
-- Delete specific tracked time
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueDeleteTime 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> Id -- ^ "id" -  id of time to delete
  -> GiteaRequest IssueDeleteTime MimeNoContent NoContent MimeNoContent
issueDeleteTime (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueDeleteTime  
instance Produces IssueDeleteTime MimeNoContent


-- *** issueEditComment

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Edit a comment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditComment 
  :: (Consumes IssueEditComment MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueEditComment MimeJSON Comment MimeJSON
issueEditComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditComment 
instance HasBodyParam IssueEditComment EditIssueCommentOption 

-- | @application/json@
instance Consumes IssueEditComment MimeJSON

-- | @application/json@
instance Produces IssueEditComment MimeJSON


-- *** issueEditCommentDeprecated

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}\/comments\/{id}@
-- 
-- Edit a comment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditCommentDeprecated 
  :: (Consumes IssueEditCommentDeprecated MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IndexInt -- ^ "index" -  this parameter is ignored
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueEditCommentDeprecated MimeJSON Comment MimeJSON
issueEditCommentDeprecated (Owner owner) (Repo repo) (IndexInt index) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

{-# DEPRECATED issueEditCommentDeprecated "" #-}

data IssueEditCommentDeprecated 
instance HasBodyParam IssueEditCommentDeprecated EditIssueCommentOption 

-- | @application/json@
instance Consumes IssueEditCommentDeprecated MimeJSON

-- | @application/json@
instance Produces IssueEditCommentDeprecated MimeJSON


-- *** issueEditIssue

-- | @PATCH \/repos\/{owner}\/{repo}\/issues\/{index}@
-- 
-- Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditIssue 
  :: (Consumes IssueEditIssue MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to edit
  -> GiteaRequest IssueEditIssue MimeJSON Issue MimeJSON
issueEditIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssue 
instance HasBodyParam IssueEditIssue EditIssueOption 

-- | @application/json@
instance Consumes IssueEditIssue MimeJSON

-- | @application/json@
instance Produces IssueEditIssue MimeJSON


-- *** issueEditIssueDeadline

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/deadline@
-- 
-- Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditIssueDeadline 
  :: (Consumes IssueEditIssueDeadline MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to create or update a deadline on
  -> GiteaRequest IssueEditIssueDeadline MimeJSON IssueDeadline MimeJSON
issueEditIssueDeadline (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/deadline"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditIssueDeadline 
instance HasBodyParam IssueEditIssueDeadline EditDeadlineOption 

-- | @application/json@
instance Consumes IssueEditIssueDeadline MimeJSON

-- | @application/json@
instance Produces IssueEditIssueDeadline MimeJSON


-- *** issueEditLabel

-- | @PATCH \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Update a label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditLabel 
  :: (Consumes IssueEditLabel MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to edit
  -> GiteaRequest IssueEditLabel MimeJSON Label MimeJSON
issueEditLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditLabel 
instance HasBodyParam IssueEditLabel EditLabelOption 

-- | @application/json@
instance Consumes IssueEditLabel MimeJSON

-- | @application/json@
instance Produces IssueEditLabel MimeJSON


-- *** issueEditMilestone

-- | @PATCH \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Update a milestone
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueEditMilestone 
  :: (Consumes IssueEditMilestone MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to edit, identified by ID and if not available by name
  -> GiteaRequest IssueEditMilestone MimeJSON Milestone MimeJSON
issueEditMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "PATCH" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueEditMilestone 
instance HasBodyParam IssueEditMilestone EditMilestoneOption 

-- | @application/json@
instance Consumes IssueEditMilestone MimeJSON

-- | @application/json@
instance Produces IssueEditMilestone MimeJSON


-- *** issueGetComment

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}@
-- 
-- Get a comment
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetComment 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment
  -> GiteaRequest IssueGetComment MimeNoContent Comment MimeJSON
issueGetComment (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetComment  
-- | @application/json@
instance Produces IssueGetComment MimeJSON


-- *** issueGetCommentReactions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Get a list of reactions from a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetCommentReactions 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssueGetCommentReactions MimeNoContent [Reaction] MimeJSON
issueGetCommentReactions (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetCommentReactions  
-- | @application/json@
instance Produces IssueGetCommentReactions MimeJSON


-- *** issueGetComments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/comments@
-- 
-- List all comments on an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetComments 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetComments MimeNoContent [Comment] MimeJSON
issueGetComments (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetComments  

-- | /Optional Param/ "since" - if provided, only comments updated since the specified time are returned.
instance HasOptionalParam IssueGetComments Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - if provided, only comments updated before the provided time are returned.
instance HasOptionalParam IssueGetComments Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)
-- | @application/json@
instance Produces IssueGetComments MimeJSON


-- *** issueGetIssue

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}@
-- 
-- Get an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetIssue 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to get
  -> GiteaRequest IssueGetIssue MimeNoContent Issue MimeJSON
issueGetIssue (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssue  
-- | @application/json@
instance Produces IssueGetIssue MimeJSON


-- *** issueGetIssueReactions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Get a list reactions of an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetIssueReactions 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetIssueReactions MimeNoContent [Reaction] MimeJSON
issueGetIssueReactions (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetIssueReactions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetIssueReactions Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetIssueReactions Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetIssueReactions MimeJSON


-- *** issueGetLabel

-- | @GET \/repos\/{owner}\/{repo}\/labels\/{id}@
-- 
-- Get a single label
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetLabel 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the label to get
  -> GiteaRequest IssueGetLabel MimeNoContent Label MimeJSON
issueGetLabel (Owner owner) (Repo repo) (Id id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetLabel  
-- | @application/json@
instance Produces IssueGetLabel MimeJSON


-- *** issueGetLabels

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Get an issue's labels
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetLabels 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueGetLabels MimeNoContent [Label] MimeJSON
issueGetLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetLabels  
-- | @application/json@
instance Produces IssueGetLabels MimeJSON


-- *** issueGetMilestone

-- | @GET \/repos\/{owner}\/{repo}\/milestones\/{id}@
-- 
-- Get a milestone
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetMilestone 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> IdText -- ^ "id" -  the milestone to get, identified by ID and if not available by name
  -> GiteaRequest IssueGetMilestone MimeNoContent Milestone MimeJSON
issueGetMilestone (Owner owner) (Repo repo) (IdText id) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/milestones/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetMilestone  
-- | @application/json@
instance Produces IssueGetMilestone MimeJSON


-- *** issueGetMilestonesList

-- | @GET \/repos\/{owner}\/{repo}\/milestones@
-- 
-- Get all of a repository's opened milestones
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetMilestonesList 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueGetMilestonesList MimeNoContent [Milestone] MimeJSON
issueGetMilestonesList (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/milestones"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetMilestonesList  

-- | /Optional Param/ "state" - Milestone state, Recognised values are open, closed and all. Defaults to \"open\"
instance HasOptionalParam IssueGetMilestonesList State where
  applyOptionalParam req (State xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "name" - filter by milestone name
instance HasOptionalParam IssueGetMilestonesList Name where
  applyOptionalParam req (Name xs) =
    req `setQuery` toQuery ("name", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetMilestonesList Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetMilestonesList Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetMilestonesList MimeJSON


-- *** issueGetRepoComments

-- | @GET \/repos\/{owner}\/{repo}\/issues\/comments@
-- 
-- List all comments in a repository
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueGetRepoComments 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueGetRepoComments MimeNoContent [Comment] MimeJSON
issueGetRepoComments (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueGetRepoComments  

-- | /Optional Param/ "since" - if provided, only comments updated since the provided time are returned.
instance HasOptionalParam IssueGetRepoComments Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - if provided, only comments updated before the provided time are returned.
instance HasOptionalParam IssueGetRepoComments Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueGetRepoComments Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueGetRepoComments Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueGetRepoComments MimeJSON


-- *** issueListIssues

-- | @GET \/repos\/{owner}\/{repo}\/issues@
-- 
-- List a repository's issues
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueListIssues 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueListIssues MimeNoContent [Issue] MimeJSON
issueListIssues (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListIssues  

-- | /Optional Param/ "state" - whether issue is open or closed
instance HasOptionalParam IssueListIssues State3 where
  applyOptionalParam req (State3 xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "labels" - comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
instance HasOptionalParam IssueListIssues Labels where
  applyOptionalParam req (Labels xs) =
    req `setQuery` toQuery ("labels", Just xs)

-- | /Optional Param/ "q" - search string
instance HasOptionalParam IssueListIssues Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "type" - filter by type (issues / pulls) if set
instance HasOptionalParam IssueListIssues ParamType2 where
  applyOptionalParam req (ParamType2 xs) =
    req `setQuery` toQuery ("type", Just xs)

-- | /Optional Param/ "milestones" - comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
instance HasOptionalParam IssueListIssues Milestones where
  applyOptionalParam req (Milestones xs) =
    req `setQuery` toQuery ("milestones", Just xs)

-- | /Optional Param/ "since" - Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueListIssues Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueListIssues Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "created_by" - filter (issues / pulls) created to
instance HasOptionalParam IssueListIssues CreatedBy where
  applyOptionalParam req (CreatedBy xs) =
    req `setQuery` toQuery ("created_by", Just xs)

-- | /Optional Param/ "assigned_by" - filter (issues / pulls) assigned to
instance HasOptionalParam IssueListIssues AssignedBy where
  applyOptionalParam req (AssignedBy xs) =
    req `setQuery` toQuery ("assigned_by", Just xs)

-- | /Optional Param/ "mentioned_by" - filter (issues / pulls) mentioning to
instance HasOptionalParam IssueListIssues MentionedBy where
  applyOptionalParam req (MentionedBy xs) =
    req `setQuery` toQuery ("mentioned_by", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListIssues Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListIssues Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListIssues MimeJSON


-- *** issueListLabels

-- | @GET \/repos\/{owner}\/{repo}\/labels@
-- 
-- Get all of a repository's labels
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueListLabels 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> GiteaRequest IssueListLabels MimeNoContent [Label] MimeJSON
issueListLabels (Owner owner) (Repo repo) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueListLabels  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueListLabels Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueListLabels Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueListLabels MimeJSON


-- *** issuePostCommentReaction

-- | @POST \/repos\/{owner}\/{repo}\/issues\/comments\/{id}\/reactions@
-- 
-- Add a reaction to a comment of an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issuePostCommentReaction 
  :: (Consumes IssuePostCommentReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Id -- ^ "id" -  id of the comment to edit
  -> GiteaRequest IssuePostCommentReaction MimeJSON Reaction MimeJSON
issuePostCommentReaction (Owner owner) (Repo repo) (Id id) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/comments/",toPath id,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssuePostCommentReaction 
instance HasBodyParam IssuePostCommentReaction EditReactionOption 

-- | @application/json@
instance Consumes IssuePostCommentReaction MimeJSON

-- | @application/json@
instance Produces IssuePostCommentReaction MimeJSON


-- *** issuePostIssueReaction

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/reactions@
-- 
-- Add a reaction to an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issuePostIssueReaction 
  :: (Consumes IssuePostIssueReaction MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssuePostIssueReaction MimeJSON Reaction MimeJSON
issuePostIssueReaction (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/reactions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssuePostIssueReaction 
instance HasBodyParam IssuePostIssueReaction EditReactionOption 

-- | @application/json@
instance Consumes IssuePostIssueReaction MimeJSON

-- | @application/json@
instance Produces IssuePostIssueReaction MimeJSON


-- *** issueRemoveLabel

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/labels\/{id}@
-- 
-- Remove a label from an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueRemoveLabel 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> Id -- ^ "id" -  id of the label to remove
  -> GiteaRequest IssueRemoveLabel MimeNoContent NoContent MimeNoContent
issueRemoveLabel (Owner owner) (Repo repo) (Index index) (Id id) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels/",toPath id]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueRemoveLabel  
instance Produces IssueRemoveLabel MimeNoContent


-- *** issueReplaceLabels

-- | @PUT \/repos\/{owner}\/{repo}\/issues\/{index}\/labels@
-- 
-- Replace an issue's labels
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueReplaceLabels 
  :: (Consumes IssueReplaceLabels MimeJSON)
  => Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueReplaceLabels MimeJSON [Label] MimeJSON
issueReplaceLabels (Owner owner) (Repo repo) (Index index) =
  _mkRequest "PUT" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/labels"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueReplaceLabels 
instance HasBodyParam IssueReplaceLabels IssueLabelsOption 

-- | @application/json@
instance Consumes IssueReplaceLabels MimeJSON

-- | @application/json@
instance Produces IssueReplaceLabels MimeJSON


-- *** issueResetTime

-- | @DELETE \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- Reset a tracked time of an issue
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueResetTime 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to add tracked time to
  -> GiteaRequest IssueResetTime MimeNoContent NoContent MimeNoContent
issueResetTime (Owner owner) (Repo repo) (Index index) =
  _mkRequest "DELETE" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueResetTime  
instance Produces IssueResetTime MimeNoContent


-- *** issueSearchIssues

-- | @GET \/repos\/issues\/search@
-- 
-- Search for issues across the repositories that the user has access to
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueSearchIssues 
  :: GiteaRequest IssueSearchIssues MimeNoContent [Issue] MimeJSON
issueSearchIssues =
  _mkRequest "GET" ["/repos/issues/search"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueSearchIssues  

-- | /Optional Param/ "state" - whether issue is open or closed
instance HasOptionalParam IssueSearchIssues State where
  applyOptionalParam req (State xs) =
    req `setQuery` toQuery ("state", Just xs)

-- | /Optional Param/ "labels" - comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
instance HasOptionalParam IssueSearchIssues Labels where
  applyOptionalParam req (Labels xs) =
    req `setQuery` toQuery ("labels", Just xs)

-- | /Optional Param/ "milestones" - comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
instance HasOptionalParam IssueSearchIssues Milestones where
  applyOptionalParam req (Milestones xs) =
    req `setQuery` toQuery ("milestones", Just xs)

-- | /Optional Param/ "q" - search string
instance HasOptionalParam IssueSearchIssues Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "priority_repo_id" - repository to prioritize in the results
instance HasOptionalParam IssueSearchIssues PriorityRepoId where
  applyOptionalParam req (PriorityRepoId xs) =
    req `setQuery` toQuery ("priority_repo_id", Just xs)

-- | /Optional Param/ "type" - filter by type (issues / pulls) if set
instance HasOptionalParam IssueSearchIssues ParamType where
  applyOptionalParam req (ParamType xs) =
    req `setQuery` toQuery ("type", Just xs)

-- | /Optional Param/ "since" - Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueSearchIssues Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueSearchIssues Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "assigned" - filter (issues / pulls) assigned to you, default is false
instance HasOptionalParam IssueSearchIssues Assigned where
  applyOptionalParam req (Assigned xs) =
    req `setQuery` toQuery ("assigned", Just xs)

-- | /Optional Param/ "created" - filter (issues / pulls) created by you, default is false
instance HasOptionalParam IssueSearchIssues Created where
  applyOptionalParam req (Created xs) =
    req `setQuery` toQuery ("created", Just xs)

-- | /Optional Param/ "mentioned" - filter (issues / pulls) mentioning you, default is false
instance HasOptionalParam IssueSearchIssues Mentioned where
  applyOptionalParam req (Mentioned xs) =
    req `setQuery` toQuery ("mentioned", Just xs)

-- | /Optional Param/ "review_requested" - filter pulls requesting your review, default is false
instance HasOptionalParam IssueSearchIssues ReviewRequested where
  applyOptionalParam req (ReviewRequested xs) =
    req `setQuery` toQuery ("review_requested", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueSearchIssues Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueSearchIssues Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueSearchIssues MimeJSON


-- *** issueStartStopWatch

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/start@
-- 
-- Start stopwatch on an issue.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueStartStopWatch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to create the stopwatch on
  -> GiteaRequest IssueStartStopWatch MimeNoContent NoContent MimeNoContent
issueStartStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/start"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueStartStopWatch  
instance Produces IssueStartStopWatch MimeNoContent


-- *** issueStopStopWatch

-- | @POST \/repos\/{owner}\/{repo}\/issues\/{index}\/stopwatch\/stop@
-- 
-- Stop an issue's existing stopwatch.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueStopStopWatch 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue to stop the stopwatch on
  -> GiteaRequest IssueStopStopWatch MimeNoContent NoContent MimeNoContent
issueStopStopWatch (Owner owner) (Repo repo) (Index index) =
  _mkRequest "POST" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/stopwatch/stop"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueStopStopWatch  
instance Produces IssueStopStopWatch MimeNoContent


-- *** issueSubscriptions

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/subscriptions@
-- 
-- Get users who subscribed on an issue.
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueSubscriptions 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueSubscriptions MimeNoContent [User] MimeJSON
issueSubscriptions (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueSubscriptions  

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueSubscriptions Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueSubscriptions Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueSubscriptions MimeJSON


-- *** issueTrackedTimes

-- | @GET \/repos\/{owner}\/{repo}\/issues\/{index}\/times@
-- 
-- List an issue's tracked times
-- 
-- AuthMethod: 'AuthApiKeyAccessToken', 'AuthApiKeyAuthorizationHeaderToken', 'AuthBasicBasicAuth', 'AuthApiKeySudoHeader', 'AuthApiKeySudoParam', 'AuthApiKeyTOTPHeader', 'AuthApiKeyToken'
-- 
issueTrackedTimes 
  :: Owner -- ^ "owner" -  owner of the repo
  -> Repo -- ^ "repo" -  name of the repo
  -> Index -- ^ "index" -  index of the issue
  -> GiteaRequest IssueTrackedTimes MimeNoContent [TrackedTime] MimeJSON
issueTrackedTimes (Owner owner) (Repo repo) (Index index) =
  _mkRequest "GET" ["/repos/",toPath owner,"/",toPath repo,"/issues/",toPath index,"/times"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAccessToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyAuthorizationHeaderToken)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthBasicBasicAuth)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeySudoParam)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyTOTPHeader)
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyToken)

data IssueTrackedTimes  

-- | /Optional Param/ "user" - optional filter by user (available for issue managers)
instance HasOptionalParam IssueTrackedTimes User2 where
  applyOptionalParam req (User2 xs) =
    req `setQuery` toQuery ("user", Just xs)

-- | /Optional Param/ "since" - Only show times updated after the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueTrackedTimes Since where
  applyOptionalParam req (Since xs) =
    req `setQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "before" - Only show times updated before the given time. This is a timestamp in RFC 3339 format
instance HasOptionalParam IssueTrackedTimes Before where
  applyOptionalParam req (Before xs) =
    req `setQuery` toQuery ("before", Just xs)

-- | /Optional Param/ "page" - page number of results to return (1-based)
instance HasOptionalParam IssueTrackedTimes Page where
  applyOptionalParam req (Page xs) =
    req `setQuery` toQuery ("page", Just xs)

-- | /Optional Param/ "limit" - page size of results
instance HasOptionalParam IssueTrackedTimes Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces IssueTrackedTimes MimeJSON

