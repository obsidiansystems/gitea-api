{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.1.1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.Model where

import Gitea.Core
import Gitea.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Archive
newtype Archive = Archive { unArchive :: Text } deriving (P.Eq, P.Show)

-- ** Attachment2
newtype Attachment2 = Attachment2 { unAttachment2 :: FilePath } deriving (P.Eq, P.Show)

-- ** AttachmentId
newtype AttachmentId = AttachmentId { unAttachmentId :: Integer } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Branch2
newtype Branch2 = Branch2 { unBranch2 :: Text } deriving (P.Eq, P.Show)

-- ** Collaborator
newtype Collaborator = Collaborator { unCollaborator :: Text } deriving (P.Eq, P.Show)

-- ** Exclusive
newtype Exclusive = Exclusive { unExclusive :: Bool } deriving (P.Eq, P.Show)

-- ** Filepath
newtype Filepath = Filepath { unFilepath :: Text } deriving (P.Eq, P.Show)

-- ** Fingerprint
newtype Fingerprint = Fingerprint { unFingerprint :: Text } deriving (P.Eq, P.Show)

-- ** Followee
newtype Followee = Followee { unFollowee :: Text } deriving (P.Eq, P.Show)

-- ** Follower
newtype Follower = Follower { unFollower :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Integer } deriving (P.Eq, P.Show)

-- ** IdInt
newtype IdInt = IdInt { unIdInt :: Int } deriving (P.Eq, P.Show)

-- ** IdText
newtype IdText = IdText { unIdText :: Text } deriving (P.Eq, P.Show)

-- ** Index
newtype Index = Index { unIndex :: Integer } deriving (P.Eq, P.Show)

-- ** IndexInt
newtype IndexInt = IndexInt { unIndexInt :: Int } deriving (P.Eq, P.Show)

-- ** KeyId
newtype KeyId = KeyId { unKeyId :: Int } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** LabelsInteger
newtype LabelsInteger = LabelsInteger { unLabelsInteger :: [Integer] } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Milestone2
newtype Milestone2 = Milestone2 { unMilestone2 :: Integer } deriving (P.Eq, P.Show)

-- ** Mode
newtype Mode = Mode { unMode :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Order
newtype Order = Order { unOrder :: Text } deriving (P.Eq, P.Show)

-- ** Org
newtype Org = Org { unOrg :: Text } deriving (P.Eq, P.Show)

-- ** Owner
newtype Owner = Owner { unOwner :: Text } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** PerPage
newtype PerPage = PerPage { unPerPage :: Int } deriving (P.Eq, P.Show)

-- ** Private
newtype Private = Private { unPrivate :: Bool } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Recursive
newtype Recursive = Recursive { unRecursive :: Bool } deriving (P.Eq, P.Show)

-- ** Ref
newtype Ref = Ref { unRef :: Text } deriving (P.Eq, P.Show)

-- ** Repo
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)

-- ** Sha
newtype Sha = Sha { unSha :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** Sort2
newtype Sort2 = Sort2 { unSort2 :: E'Sort } deriving (P.Eq, P.Show)

-- ** StarredBy
newtype StarredBy = StarredBy { unStarredBy :: Integer } deriving (P.Eq, P.Show)

-- ** State
newtype State = State { unState :: Text } deriving (P.Eq, P.Show)

-- ** State2
newtype State2 = State2 { unState2 :: E'State } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Integer } deriving (P.Eq, P.Show)

-- ** Uid
newtype Uid = Uid { unUid :: Integer } deriving (P.Eq, P.Show)

-- ** User2
newtype User2 = User2 { unUser2 :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AccessToken
-- | AccessToken
-- AccessToken represents an API access token.
-- 
data AccessToken = AccessToken
  { accessTokenId :: !(Maybe Integer) -- ^ "id"
  , accessTokenName :: !(Maybe Text) -- ^ "name"
  , accessTokenSha1 :: !(Maybe Text) -- ^ "sha1"
  , accessTokenTokenLastEight :: !(Maybe Text) -- ^ "token_last_eight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessToken
instance A.FromJSON AccessToken where
  parseJSON = A.withObject "AccessToken" $ \o ->
    AccessToken
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "sha1")
      <*> (o .:? "token_last_eight")

-- | ToJSON AccessToken
instance A.ToJSON AccessToken where
  toJSON AccessToken {..} =
   _omitNulls
      [ "id" .= accessTokenId
      , "name" .= accessTokenName
      , "sha1" .= accessTokenSha1
      , "token_last_eight" .= accessTokenTokenLastEight
      ]


-- | Construct a value of type 'AccessToken' (by applying it's required fields, if any)
mkAccessToken
  :: AccessToken
mkAccessToken =
  AccessToken
  { accessTokenId = Nothing
  , accessTokenName = Nothing
  , accessTokenSha1 = Nothing
  , accessTokenTokenLastEight = Nothing
  }

-- ** AddCollaboratorOption
-- | AddCollaboratorOption
-- AddCollaboratorOption options when adding a user as a collaborator of a repository
data AddCollaboratorOption = AddCollaboratorOption
  { addCollaboratorOptionPermission :: !(Maybe Text) -- ^ "permission"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddCollaboratorOption
instance A.FromJSON AddCollaboratorOption where
  parseJSON = A.withObject "AddCollaboratorOption" $ \o ->
    AddCollaboratorOption
      <$> (o .:? "permission")

-- | ToJSON AddCollaboratorOption
instance A.ToJSON AddCollaboratorOption where
  toJSON AddCollaboratorOption {..} =
   _omitNulls
      [ "permission" .= addCollaboratorOptionPermission
      ]


-- | Construct a value of type 'AddCollaboratorOption' (by applying it's required fields, if any)
mkAddCollaboratorOption
  :: AddCollaboratorOption
mkAddCollaboratorOption =
  AddCollaboratorOption
  { addCollaboratorOptionPermission = Nothing
  }

-- ** AddTimeOption
-- | AddTimeOption
-- AddTimeOption options for adding time to an issue
data AddTimeOption = AddTimeOption
  { addTimeOptionTime :: !(Integer) -- ^ /Required/ "time" - time in seconds
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddTimeOption
instance A.FromJSON AddTimeOption where
  parseJSON = A.withObject "AddTimeOption" $ \o ->
    AddTimeOption
      <$> (o .:  "time")

-- | ToJSON AddTimeOption
instance A.ToJSON AddTimeOption where
  toJSON AddTimeOption {..} =
   _omitNulls
      [ "time" .= addTimeOptionTime
      ]


-- | Construct a value of type 'AddTimeOption' (by applying it's required fields, if any)
mkAddTimeOption
  :: Integer -- ^ 'addTimeOptionTime': time in seconds
  -> AddTimeOption
mkAddTimeOption addTimeOptionTime =
  AddTimeOption
  { addTimeOptionTime
  }

-- ** AnnotatedTag
-- | AnnotatedTag
-- AnnotatedTag represents an annotated tag
data AnnotatedTag = AnnotatedTag
  { annotatedTagMessage :: !(Maybe Text) -- ^ "message"
  , annotatedTagObject :: !(Maybe AnnotatedTagObject) -- ^ "object"
  , annotatedTagSha :: !(Maybe Text) -- ^ "sha"
  , annotatedTagTag :: !(Maybe Text) -- ^ "tag"
  , annotatedTagTagger :: !(Maybe CommitUser) -- ^ "tagger"
  , annotatedTagUrl :: !(Maybe Text) -- ^ "url"
  , annotatedTagVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnnotatedTag
instance A.FromJSON AnnotatedTag where
  parseJSON = A.withObject "AnnotatedTag" $ \o ->
    AnnotatedTag
      <$> (o .:? "message")
      <*> (o .:? "object")
      <*> (o .:? "sha")
      <*> (o .:? "tag")
      <*> (o .:? "tagger")
      <*> (o .:? "url")
      <*> (o .:? "verification")

-- | ToJSON AnnotatedTag
instance A.ToJSON AnnotatedTag where
  toJSON AnnotatedTag {..} =
   _omitNulls
      [ "message" .= annotatedTagMessage
      , "object" .= annotatedTagObject
      , "sha" .= annotatedTagSha
      , "tag" .= annotatedTagTag
      , "tagger" .= annotatedTagTagger
      , "url" .= annotatedTagUrl
      , "verification" .= annotatedTagVerification
      ]


-- | Construct a value of type 'AnnotatedTag' (by applying it's required fields, if any)
mkAnnotatedTag
  :: AnnotatedTag
mkAnnotatedTag =
  AnnotatedTag
  { annotatedTagMessage = Nothing
  , annotatedTagObject = Nothing
  , annotatedTagSha = Nothing
  , annotatedTagTag = Nothing
  , annotatedTagTagger = Nothing
  , annotatedTagUrl = Nothing
  , annotatedTagVerification = Nothing
  }

-- ** AnnotatedTagObject
-- | AnnotatedTagObject
-- AnnotatedTagObject contains meta information of the tag object
data AnnotatedTagObject = AnnotatedTagObject
  { annotatedTagObjectSha :: !(Maybe Text) -- ^ "sha"
  , annotatedTagObjectType :: !(Maybe Text) -- ^ "type"
  , annotatedTagObjectUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnnotatedTagObject
instance A.FromJSON AnnotatedTagObject where
  parseJSON = A.withObject "AnnotatedTagObject" $ \o ->
    AnnotatedTagObject
      <$> (o .:? "sha")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON AnnotatedTagObject
instance A.ToJSON AnnotatedTagObject where
  toJSON AnnotatedTagObject {..} =
   _omitNulls
      [ "sha" .= annotatedTagObjectSha
      , "type" .= annotatedTagObjectType
      , "url" .= annotatedTagObjectUrl
      ]


-- | Construct a value of type 'AnnotatedTagObject' (by applying it's required fields, if any)
mkAnnotatedTagObject
  :: AnnotatedTagObject
mkAnnotatedTagObject =
  AnnotatedTagObject
  { annotatedTagObjectSha = Nothing
  , annotatedTagObjectType = Nothing
  , annotatedTagObjectUrl = Nothing
  }

-- ** Attachment
-- | Attachment
-- Attachment a generic attachment
data Attachment = Attachment
  { attachmentBrowserDownloadUrl :: !(Maybe Text) -- ^ "browser_download_url"
  , attachmentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , attachmentDownloadCount :: !(Maybe Integer) -- ^ "download_count"
  , attachmentId :: !(Maybe Integer) -- ^ "id"
  , attachmentName :: !(Maybe Text) -- ^ "name"
  , attachmentSize :: !(Maybe Integer) -- ^ "size"
  , attachmentUuid :: !(Maybe Text) -- ^ "uuid"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Attachment
instance A.FromJSON Attachment where
  parseJSON = A.withObject "Attachment" $ \o ->
    Attachment
      <$> (o .:? "browser_download_url")
      <*> (o .:? "created_at")
      <*> (o .:? "download_count")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "size")
      <*> (o .:? "uuid")

-- | ToJSON Attachment
instance A.ToJSON Attachment where
  toJSON Attachment {..} =
   _omitNulls
      [ "browser_download_url" .= attachmentBrowserDownloadUrl
      , "created_at" .= attachmentCreatedAt
      , "download_count" .= attachmentDownloadCount
      , "id" .= attachmentId
      , "name" .= attachmentName
      , "size" .= attachmentSize
      , "uuid" .= attachmentUuid
      ]


-- | Construct a value of type 'Attachment' (by applying it's required fields, if any)
mkAttachment
  :: Attachment
mkAttachment =
  Attachment
  { attachmentBrowserDownloadUrl = Nothing
  , attachmentCreatedAt = Nothing
  , attachmentDownloadCount = Nothing
  , attachmentId = Nothing
  , attachmentName = Nothing
  , attachmentSize = Nothing
  , attachmentUuid = Nothing
  }

-- ** Branch
-- | Branch
-- Branch represents a repository branch
data Branch = Branch
  { branchCommit :: !(Maybe PayloadCommit) -- ^ "commit"
  , branchName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Branch
instance A.FromJSON Branch where
  parseJSON = A.withObject "Branch" $ \o ->
    Branch
      <$> (o .:? "commit")
      <*> (o .:? "name")

-- | ToJSON Branch
instance A.ToJSON Branch where
  toJSON Branch {..} =
   _omitNulls
      [ "commit" .= branchCommit
      , "name" .= branchName
      ]


-- | Construct a value of type 'Branch' (by applying it's required fields, if any)
mkBranch
  :: Branch
mkBranch =
  Branch
  { branchCommit = Nothing
  , branchName = Nothing
  }

-- ** Comment
-- | Comment
-- Comment represents a comment on a commit or issue
data Comment = Comment
  { commentBody :: !(Maybe Text) -- ^ "body"
  , commentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , commentHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , commentId :: !(Maybe Integer) -- ^ "id"
  , commentIssueUrl :: !(Maybe Text) -- ^ "issue_url"
  , commentPullRequestUrl :: !(Maybe Text) -- ^ "pull_request_url"
  , commentUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , commentUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Comment
instance A.FromJSON Comment where
  parseJSON = A.withObject "Comment" $ \o ->
    Comment
      <$> (o .:? "body")
      <*> (o .:? "created_at")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "issue_url")
      <*> (o .:? "pull_request_url")
      <*> (o .:? "updated_at")
      <*> (o .:? "user")

-- | ToJSON Comment
instance A.ToJSON Comment where
  toJSON Comment {..} =
   _omitNulls
      [ "body" .= commentBody
      , "created_at" .= commentCreatedAt
      , "html_url" .= commentHtmlUrl
      , "id" .= commentId
      , "issue_url" .= commentIssueUrl
      , "pull_request_url" .= commentPullRequestUrl
      , "updated_at" .= commentUpdatedAt
      , "user" .= commentUser
      ]


-- | Construct a value of type 'Comment' (by applying it's required fields, if any)
mkComment
  :: Comment
mkComment =
  Comment
  { commentBody = Nothing
  , commentCreatedAt = Nothing
  , commentHtmlUrl = Nothing
  , commentId = Nothing
  , commentIssueUrl = Nothing
  , commentPullRequestUrl = Nothing
  , commentUpdatedAt = Nothing
  , commentUser = Nothing
  }

-- ** Commit
-- | Commit
-- Commit contains information generated from a Git commit.
-- 
data Commit = Commit
  { commitAuthor :: !(Maybe User) -- ^ "author"
  , commitCommit :: !(Maybe RepoCommit) -- ^ "commit"
  , commitCommitter :: !(Maybe User) -- ^ "committer"
  , commitHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , commitParents :: !(Maybe [CommitMeta]) -- ^ "parents"
  , commitSha :: !(Maybe Text) -- ^ "sha"
  , commitUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Commit
instance A.FromJSON Commit where
  parseJSON = A.withObject "Commit" $ \o ->
    Commit
      <$> (o .:? "author")
      <*> (o .:? "commit")
      <*> (o .:? "committer")
      <*> (o .:? "html_url")
      <*> (o .:? "parents")
      <*> (o .:? "sha")
      <*> (o .:? "url")

-- | ToJSON Commit
instance A.ToJSON Commit where
  toJSON Commit {..} =
   _omitNulls
      [ "author" .= commitAuthor
      , "commit" .= commitCommit
      , "committer" .= commitCommitter
      , "html_url" .= commitHtmlUrl
      , "parents" .= commitParents
      , "sha" .= commitSha
      , "url" .= commitUrl
      ]


-- | Construct a value of type 'Commit' (by applying it's required fields, if any)
mkCommit
  :: Commit
mkCommit =
  Commit
  { commitAuthor = Nothing
  , commitCommit = Nothing
  , commitCommitter = Nothing
  , commitHtmlUrl = Nothing
  , commitParents = Nothing
  , commitSha = Nothing
  , commitUrl = Nothing
  }

-- ** CommitMeta
-- | CommitMeta
-- CommitMeta contains meta information of a commit in terms of API.
-- 
data CommitMeta = CommitMeta
  { commitMetaSha :: !(Maybe Text) -- ^ "sha"
  , commitMetaUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitMeta
instance A.FromJSON CommitMeta where
  parseJSON = A.withObject "CommitMeta" $ \o ->
    CommitMeta
      <$> (o .:? "sha")
      <*> (o .:? "url")

-- | ToJSON CommitMeta
instance A.ToJSON CommitMeta where
  toJSON CommitMeta {..} =
   _omitNulls
      [ "sha" .= commitMetaSha
      , "url" .= commitMetaUrl
      ]


-- | Construct a value of type 'CommitMeta' (by applying it's required fields, if any)
mkCommitMeta
  :: CommitMeta
mkCommitMeta =
  CommitMeta
  { commitMetaSha = Nothing
  , commitMetaUrl = Nothing
  }

-- ** CommitUser
-- | CommitUser
-- CommitUser contains information of a user in the context of a commit.
-- 
data CommitUser = CommitUser
  { commitUserDate :: !(Maybe Text) -- ^ "date"
  , commitUserEmail :: !(Maybe Text) -- ^ "email"
  , commitUserName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitUser
instance A.FromJSON CommitUser where
  parseJSON = A.withObject "CommitUser" $ \o ->
    CommitUser
      <$> (o .:? "date")
      <*> (o .:? "email")
      <*> (o .:? "name")

-- | ToJSON CommitUser
instance A.ToJSON CommitUser where
  toJSON CommitUser {..} =
   _omitNulls
      [ "date" .= commitUserDate
      , "email" .= commitUserEmail
      , "name" .= commitUserName
      ]


-- | Construct a value of type 'CommitUser' (by applying it's required fields, if any)
mkCommitUser
  :: CommitUser
mkCommitUser =
  CommitUser
  { commitUserDate = Nothing
  , commitUserEmail = Nothing
  , commitUserName = Nothing
  }

-- ** ContentsResponse
-- | ContentsResponse
-- ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content
data ContentsResponse = ContentsResponse
  { contentsResponseLinks :: !(Maybe FileLinksResponse) -- ^ "_links"
  , contentsResponseContent :: !(Maybe Text) -- ^ "content" - &#x60;content&#x60; is populated when &#x60;type&#x60; is &#x60;file&#x60;, otherwise null
  , contentsResponseDownloadUrl :: !(Maybe Text) -- ^ "download_url"
  , contentsResponseEncoding :: !(Maybe Text) -- ^ "encoding" - &#x60;encoding&#x60; is populated when &#x60;type&#x60; is &#x60;file&#x60;, otherwise null
  , contentsResponseGitUrl :: !(Maybe Text) -- ^ "git_url"
  , contentsResponseHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , contentsResponseName :: !(Maybe Text) -- ^ "name"
  , contentsResponsePath :: !(Maybe Text) -- ^ "path"
  , contentsResponseSha :: !(Maybe Text) -- ^ "sha"
  , contentsResponseSize :: !(Maybe Integer) -- ^ "size"
  , contentsResponseSubmoduleGitUrl :: !(Maybe Text) -- ^ "submodule_git_url" - &#x60;submodule_git_url&#x60; is populated when &#x60;type&#x60; is &#x60;submodule&#x60;, otherwise null
  , contentsResponseTarget :: !(Maybe Text) -- ^ "target" - &#x60;target&#x60; is populated when &#x60;type&#x60; is &#x60;symlink&#x60;, otherwise null
  , contentsResponseType :: !(Maybe Text) -- ^ "type" - &#x60;type&#x60; will be &#x60;file&#x60;, &#x60;dir&#x60;, &#x60;symlink&#x60;, or &#x60;submodule&#x60;
  , contentsResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContentsResponse
instance A.FromJSON ContentsResponse where
  parseJSON = A.withObject "ContentsResponse" $ \o ->
    ContentsResponse
      <$> (o .:? "_links")
      <*> (o .:? "content")
      <*> (o .:? "download_url")
      <*> (o .:? "encoding")
      <*> (o .:? "git_url")
      <*> (o .:? "html_url")
      <*> (o .:? "name")
      <*> (o .:? "path")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "submodule_git_url")
      <*> (o .:? "target")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON ContentsResponse
instance A.ToJSON ContentsResponse where
  toJSON ContentsResponse {..} =
   _omitNulls
      [ "_links" .= contentsResponseLinks
      , "content" .= contentsResponseContent
      , "download_url" .= contentsResponseDownloadUrl
      , "encoding" .= contentsResponseEncoding
      , "git_url" .= contentsResponseGitUrl
      , "html_url" .= contentsResponseHtmlUrl
      , "name" .= contentsResponseName
      , "path" .= contentsResponsePath
      , "sha" .= contentsResponseSha
      , "size" .= contentsResponseSize
      , "submodule_git_url" .= contentsResponseSubmoduleGitUrl
      , "target" .= contentsResponseTarget
      , "type" .= contentsResponseType
      , "url" .= contentsResponseUrl
      ]


-- | Construct a value of type 'ContentsResponse' (by applying it's required fields, if any)
mkContentsResponse
  :: ContentsResponse
mkContentsResponse =
  ContentsResponse
  { contentsResponseLinks = Nothing
  , contentsResponseContent = Nothing
  , contentsResponseDownloadUrl = Nothing
  , contentsResponseEncoding = Nothing
  , contentsResponseGitUrl = Nothing
  , contentsResponseHtmlUrl = Nothing
  , contentsResponseName = Nothing
  , contentsResponsePath = Nothing
  , contentsResponseSha = Nothing
  , contentsResponseSize = Nothing
  , contentsResponseSubmoduleGitUrl = Nothing
  , contentsResponseTarget = Nothing
  , contentsResponseType = Nothing
  , contentsResponseUrl = Nothing
  }

-- ** CreateEmailOption
-- | CreateEmailOption
-- CreateEmailOption options when creating email addresses
data CreateEmailOption = CreateEmailOption
  { createEmailOptionEmails :: !(Maybe [Text]) -- ^ "emails" - email addresses to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmailOption
instance A.FromJSON CreateEmailOption where
  parseJSON = A.withObject "CreateEmailOption" $ \o ->
    CreateEmailOption
      <$> (o .:? "emails")

-- | ToJSON CreateEmailOption
instance A.ToJSON CreateEmailOption where
  toJSON CreateEmailOption {..} =
   _omitNulls
      [ "emails" .= createEmailOptionEmails
      ]


-- | Construct a value of type 'CreateEmailOption' (by applying it's required fields, if any)
mkCreateEmailOption
  :: CreateEmailOption
mkCreateEmailOption =
  CreateEmailOption
  { createEmailOptionEmails = Nothing
  }

-- ** CreateFileOptions
-- | CreateFileOptions
-- CreateFileOptions options for creating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data CreateFileOptions = CreateFileOptions
  { createFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , createFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , createFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , createFileOptionsContent :: !(Text) -- ^ /Required/ "content" - content must be base64 encoded
  , createFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , createFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFileOptions
instance A.FromJSON CreateFileOptions where
  parseJSON = A.withObject "CreateFileOptions" $ \o ->
    CreateFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:  "content")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")

-- | ToJSON CreateFileOptions
instance A.ToJSON CreateFileOptions where
  toJSON CreateFileOptions {..} =
   _omitNulls
      [ "author" .= createFileOptionsAuthor
      , "branch" .= createFileOptionsBranch
      , "committer" .= createFileOptionsCommitter
      , "content" .= createFileOptionsContent
      , "message" .= createFileOptionsMessage
      , "new_branch" .= createFileOptionsNewBranch
      ]


-- | Construct a value of type 'CreateFileOptions' (by applying it's required fields, if any)
mkCreateFileOptions
  :: Text -- ^ 'createFileOptionsContent': content must be base64 encoded
  -> CreateFileOptions
mkCreateFileOptions createFileOptionsContent =
  CreateFileOptions
  { createFileOptionsAuthor = Nothing
  , createFileOptionsBranch = Nothing
  , createFileOptionsCommitter = Nothing
  , createFileOptionsContent
  , createFileOptionsMessage = Nothing
  , createFileOptionsNewBranch = Nothing
  }

-- ** CreateForkOption
-- | CreateForkOption
-- CreateForkOption options for creating a fork
data CreateForkOption = CreateForkOption
  { createForkOptionOrganization :: !(Maybe Text) -- ^ "organization" - organization name, if forking into an organization
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateForkOption
instance A.FromJSON CreateForkOption where
  parseJSON = A.withObject "CreateForkOption" $ \o ->
    CreateForkOption
      <$> (o .:? "organization")

-- | ToJSON CreateForkOption
instance A.ToJSON CreateForkOption where
  toJSON CreateForkOption {..} =
   _omitNulls
      [ "organization" .= createForkOptionOrganization
      ]


-- | Construct a value of type 'CreateForkOption' (by applying it's required fields, if any)
mkCreateForkOption
  :: CreateForkOption
mkCreateForkOption =
  CreateForkOption
  { createForkOptionOrganization = Nothing
  }

-- ** CreateGPGKeyOption
-- | CreateGPGKeyOption
-- CreateGPGKeyOption options create user GPG key
data CreateGPGKeyOption = CreateGPGKeyOption
  { createGPGKeyOptionArmoredPublicKey :: !(Text) -- ^ /Required/ "armored_public_key" - An armored GPG key to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateGPGKeyOption
instance A.FromJSON CreateGPGKeyOption where
  parseJSON = A.withObject "CreateGPGKeyOption" $ \o ->
    CreateGPGKeyOption
      <$> (o .:  "armored_public_key")

-- | ToJSON CreateGPGKeyOption
instance A.ToJSON CreateGPGKeyOption where
  toJSON CreateGPGKeyOption {..} =
   _omitNulls
      [ "armored_public_key" .= createGPGKeyOptionArmoredPublicKey
      ]


-- | Construct a value of type 'CreateGPGKeyOption' (by applying it's required fields, if any)
mkCreateGPGKeyOption
  :: Text -- ^ 'createGPGKeyOptionArmoredPublicKey': An armored GPG key to add
  -> CreateGPGKeyOption
mkCreateGPGKeyOption createGPGKeyOptionArmoredPublicKey =
  CreateGPGKeyOption
  { createGPGKeyOptionArmoredPublicKey
  }

-- ** CreateHookOption
-- | CreateHookOption
-- CreateHookOption options when create a hook
data CreateHookOption = CreateHookOption
  { createHookOptionActive :: !(Maybe Bool) -- ^ "active"
  , createHookOptionConfig :: !((Map.Map String Text)) -- ^ /Required/ "config"
  , createHookOptionEvents :: !(Maybe [Text]) -- ^ "events"
  , createHookOptionType :: !(E'Type) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateHookOption
instance A.FromJSON CreateHookOption where
  parseJSON = A.withObject "CreateHookOption" $ \o ->
    CreateHookOption
      <$> (o .:? "active")
      <*> (o .:  "config")
      <*> (o .:? "events")
      <*> (o .:  "type")

-- | ToJSON CreateHookOption
instance A.ToJSON CreateHookOption where
  toJSON CreateHookOption {..} =
   _omitNulls
      [ "active" .= createHookOptionActive
      , "config" .= createHookOptionConfig
      , "events" .= createHookOptionEvents
      , "type" .= createHookOptionType
      ]


-- | Construct a value of type 'CreateHookOption' (by applying it's required fields, if any)
mkCreateHookOption
  :: (Map.Map String Text) -- ^ 'createHookOptionConfig' 
  -> E'Type -- ^ 'createHookOptionType' 
  -> CreateHookOption
mkCreateHookOption createHookOptionConfig createHookOptionType =
  CreateHookOption
  { createHookOptionActive = Nothing
  , createHookOptionConfig
  , createHookOptionEvents = Nothing
  , createHookOptionType
  }

-- ** CreateIssueCommentOption
-- | CreateIssueCommentOption
-- CreateIssueCommentOption options for creating a comment on an issue
data CreateIssueCommentOption = CreateIssueCommentOption
  { createIssueCommentOptionBody :: !(Text) -- ^ /Required/ "body"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateIssueCommentOption
instance A.FromJSON CreateIssueCommentOption where
  parseJSON = A.withObject "CreateIssueCommentOption" $ \o ->
    CreateIssueCommentOption
      <$> (o .:  "body")

-- | ToJSON CreateIssueCommentOption
instance A.ToJSON CreateIssueCommentOption where
  toJSON CreateIssueCommentOption {..} =
   _omitNulls
      [ "body" .= createIssueCommentOptionBody
      ]


-- | Construct a value of type 'CreateIssueCommentOption' (by applying it's required fields, if any)
mkCreateIssueCommentOption
  :: Text -- ^ 'createIssueCommentOptionBody' 
  -> CreateIssueCommentOption
mkCreateIssueCommentOption createIssueCommentOptionBody =
  CreateIssueCommentOption
  { createIssueCommentOptionBody
  }

-- ** CreateIssueOption
-- | CreateIssueOption
-- CreateIssueOption options to create one issue
data CreateIssueOption = CreateIssueOption
  { createIssueOptionAssignee :: !(Maybe Text) -- ^ "assignee" - username of assignee
  , createIssueOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , createIssueOptionBody :: !(Maybe Text) -- ^ "body"
  , createIssueOptionClosed :: !(Maybe Bool) -- ^ "closed"
  , createIssueOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , createIssueOptionLabels :: !(Maybe [Integer]) -- ^ "labels" - list of label ids
  , createIssueOptionMilestone :: !(Maybe Integer) -- ^ "milestone" - milestone id
  , createIssueOptionTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateIssueOption
instance A.FromJSON CreateIssueOption where
  parseJSON = A.withObject "CreateIssueOption" $ \o ->
    CreateIssueOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "closed")
      <*> (o .:? "due_date")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:  "title")

-- | ToJSON CreateIssueOption
instance A.ToJSON CreateIssueOption where
  toJSON CreateIssueOption {..} =
   _omitNulls
      [ "assignee" .= createIssueOptionAssignee
      , "assignees" .= createIssueOptionAssignees
      , "body" .= createIssueOptionBody
      , "closed" .= createIssueOptionClosed
      , "due_date" .= createIssueOptionDueDate
      , "labels" .= createIssueOptionLabels
      , "milestone" .= createIssueOptionMilestone
      , "title" .= createIssueOptionTitle
      ]


-- | Construct a value of type 'CreateIssueOption' (by applying it's required fields, if any)
mkCreateIssueOption
  :: Text -- ^ 'createIssueOptionTitle' 
  -> CreateIssueOption
mkCreateIssueOption createIssueOptionTitle =
  CreateIssueOption
  { createIssueOptionAssignee = Nothing
  , createIssueOptionAssignees = Nothing
  , createIssueOptionBody = Nothing
  , createIssueOptionClosed = Nothing
  , createIssueOptionDueDate = Nothing
  , createIssueOptionLabels = Nothing
  , createIssueOptionMilestone = Nothing
  , createIssueOptionTitle
  }

-- ** CreateKeyOption
-- | CreateKeyOption
-- CreateKeyOption options when creating a key
data CreateKeyOption = CreateKeyOption
  { createKeyOptionKey :: !(Text) -- ^ /Required/ "key" - An armored SSH key to add
  , createKeyOptionReadOnly :: !(Maybe Bool) -- ^ "read_only" - Describe if the key has only read access or read/write
  , createKeyOptionTitle :: !(Text) -- ^ /Required/ "title" - Title of the key to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateKeyOption
instance A.FromJSON CreateKeyOption where
  parseJSON = A.withObject "CreateKeyOption" $ \o ->
    CreateKeyOption
      <$> (o .:  "key")
      <*> (o .:? "read_only")
      <*> (o .:  "title")

-- | ToJSON CreateKeyOption
instance A.ToJSON CreateKeyOption where
  toJSON CreateKeyOption {..} =
   _omitNulls
      [ "key" .= createKeyOptionKey
      , "read_only" .= createKeyOptionReadOnly
      , "title" .= createKeyOptionTitle
      ]


-- | Construct a value of type 'CreateKeyOption' (by applying it's required fields, if any)
mkCreateKeyOption
  :: Text -- ^ 'createKeyOptionKey': An armored SSH key to add
  -> Text -- ^ 'createKeyOptionTitle': Title of the key to add
  -> CreateKeyOption
mkCreateKeyOption createKeyOptionKey createKeyOptionTitle =
  CreateKeyOption
  { createKeyOptionKey
  , createKeyOptionReadOnly = Nothing
  , createKeyOptionTitle
  }

-- ** CreateLabelOption
-- | CreateLabelOption
-- CreateLabelOption options for creating a label
data CreateLabelOption = CreateLabelOption
  { createLabelOptionColor :: !(Text) -- ^ /Required/ "color"
  , createLabelOptionDescription :: !(Maybe Text) -- ^ "description"
  , createLabelOptionName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateLabelOption
instance A.FromJSON CreateLabelOption where
  parseJSON = A.withObject "CreateLabelOption" $ \o ->
    CreateLabelOption
      <$> (o .:  "color")
      <*> (o .:? "description")
      <*> (o .:  "name")

-- | ToJSON CreateLabelOption
instance A.ToJSON CreateLabelOption where
  toJSON CreateLabelOption {..} =
   _omitNulls
      [ "color" .= createLabelOptionColor
      , "description" .= createLabelOptionDescription
      , "name" .= createLabelOptionName
      ]


-- | Construct a value of type 'CreateLabelOption' (by applying it's required fields, if any)
mkCreateLabelOption
  :: Text -- ^ 'createLabelOptionColor' 
  -> Text -- ^ 'createLabelOptionName' 
  -> CreateLabelOption
mkCreateLabelOption createLabelOptionColor createLabelOptionName =
  CreateLabelOption
  { createLabelOptionColor
  , createLabelOptionDescription = Nothing
  , createLabelOptionName
  }

-- ** CreateMilestoneOption
-- | CreateMilestoneOption
-- CreateMilestoneOption options for creating a milestone
data CreateMilestoneOption = CreateMilestoneOption
  { createMilestoneOptionDescription :: !(Maybe Text) -- ^ "description"
  , createMilestoneOptionDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , createMilestoneOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateMilestoneOption
instance A.FromJSON CreateMilestoneOption where
  parseJSON = A.withObject "CreateMilestoneOption" $ \o ->
    CreateMilestoneOption
      <$> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "title")

-- | ToJSON CreateMilestoneOption
instance A.ToJSON CreateMilestoneOption where
  toJSON CreateMilestoneOption {..} =
   _omitNulls
      [ "description" .= createMilestoneOptionDescription
      , "due_on" .= createMilestoneOptionDueOn
      , "title" .= createMilestoneOptionTitle
      ]


-- | Construct a value of type 'CreateMilestoneOption' (by applying it's required fields, if any)
mkCreateMilestoneOption
  :: CreateMilestoneOption
mkCreateMilestoneOption =
  CreateMilestoneOption
  { createMilestoneOptionDescription = Nothing
  , createMilestoneOptionDueOn = Nothing
  , createMilestoneOptionTitle = Nothing
  }

-- ** CreateOrgOption
-- | CreateOrgOption
-- CreateOrgOption options for creating an organization
data CreateOrgOption = CreateOrgOption
  { createOrgOptionDescription :: !(Maybe Text) -- ^ "description"
  , createOrgOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , createOrgOptionLocation :: !(Maybe Text) -- ^ "location"
  , createOrgOptionUsername :: !(Text) -- ^ /Required/ "username"
  , createOrgOptionVisibility :: !(Maybe E'Visibility) -- ^ "visibility" - possible values are &#x60;public&#x60; (default), &#x60;limited&#x60; or &#x60;private&#x60;
  , createOrgOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOrgOption
instance A.FromJSON CreateOrgOption where
  parseJSON = A.withObject "CreateOrgOption" $ \o ->
    CreateOrgOption
      <$> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:  "username")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON CreateOrgOption
instance A.ToJSON CreateOrgOption where
  toJSON CreateOrgOption {..} =
   _omitNulls
      [ "description" .= createOrgOptionDescription
      , "full_name" .= createOrgOptionFullName
      , "location" .= createOrgOptionLocation
      , "username" .= createOrgOptionUsername
      , "visibility" .= createOrgOptionVisibility
      , "website" .= createOrgOptionWebsite
      ]


-- | Construct a value of type 'CreateOrgOption' (by applying it's required fields, if any)
mkCreateOrgOption
  :: Text -- ^ 'createOrgOptionUsername' 
  -> CreateOrgOption
mkCreateOrgOption createOrgOptionUsername =
  CreateOrgOption
  { createOrgOptionDescription = Nothing
  , createOrgOptionFullName = Nothing
  , createOrgOptionLocation = Nothing
  , createOrgOptionUsername
  , createOrgOptionVisibility = Nothing
  , createOrgOptionWebsite = Nothing
  }

-- ** CreatePullRequestOption
-- | CreatePullRequestOption
-- CreatePullRequestOption options when creating a pull request
data CreatePullRequestOption = CreatePullRequestOption
  { createPullRequestOptionAssignee :: !(Maybe Text) -- ^ "assignee"
  , createPullRequestOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , createPullRequestOptionBase :: !(Maybe Text) -- ^ "base"
  , createPullRequestOptionBody :: !(Maybe Text) -- ^ "body"
  , createPullRequestOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , createPullRequestOptionHead :: !(Maybe Text) -- ^ "head"
  , createPullRequestOptionLabels :: !(Maybe [Integer]) -- ^ "labels"
  , createPullRequestOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , createPullRequestOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePullRequestOption
instance A.FromJSON CreatePullRequestOption where
  parseJSON = A.withObject "CreatePullRequestOption" $ \o ->
    CreatePullRequestOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "base")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "head")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "title")

-- | ToJSON CreatePullRequestOption
instance A.ToJSON CreatePullRequestOption where
  toJSON CreatePullRequestOption {..} =
   _omitNulls
      [ "assignee" .= createPullRequestOptionAssignee
      , "assignees" .= createPullRequestOptionAssignees
      , "base" .= createPullRequestOptionBase
      , "body" .= createPullRequestOptionBody
      , "due_date" .= createPullRequestOptionDueDate
      , "head" .= createPullRequestOptionHead
      , "labels" .= createPullRequestOptionLabels
      , "milestone" .= createPullRequestOptionMilestone
      , "title" .= createPullRequestOptionTitle
      ]


-- | Construct a value of type 'CreatePullRequestOption' (by applying it's required fields, if any)
mkCreatePullRequestOption
  :: CreatePullRequestOption
mkCreatePullRequestOption =
  CreatePullRequestOption
  { createPullRequestOptionAssignee = Nothing
  , createPullRequestOptionAssignees = Nothing
  , createPullRequestOptionBase = Nothing
  , createPullRequestOptionBody = Nothing
  , createPullRequestOptionDueDate = Nothing
  , createPullRequestOptionHead = Nothing
  , createPullRequestOptionLabels = Nothing
  , createPullRequestOptionMilestone = Nothing
  , createPullRequestOptionTitle = Nothing
  }

-- ** CreateReleaseOption
-- | CreateReleaseOption
-- CreateReleaseOption options when creating a release
data CreateReleaseOption = CreateReleaseOption
  { createReleaseOptionBody :: !(Maybe Text) -- ^ "body"
  , createReleaseOptionDraft :: !(Maybe Bool) -- ^ "draft"
  , createReleaseOptionName :: !(Maybe Text) -- ^ "name"
  , createReleaseOptionPrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , createReleaseOptionTagName :: !(Text) -- ^ /Required/ "tag_name"
  , createReleaseOptionTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateReleaseOption
instance A.FromJSON CreateReleaseOption where
  parseJSON = A.withObject "CreateReleaseOption" $ \o ->
    CreateReleaseOption
      <$> (o .:? "body")
      <*> (o .:? "draft")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:  "tag_name")
      <*> (o .:? "target_commitish")

-- | ToJSON CreateReleaseOption
instance A.ToJSON CreateReleaseOption where
  toJSON CreateReleaseOption {..} =
   _omitNulls
      [ "body" .= createReleaseOptionBody
      , "draft" .= createReleaseOptionDraft
      , "name" .= createReleaseOptionName
      , "prerelease" .= createReleaseOptionPrerelease
      , "tag_name" .= createReleaseOptionTagName
      , "target_commitish" .= createReleaseOptionTargetCommitish
      ]


-- | Construct a value of type 'CreateReleaseOption' (by applying it's required fields, if any)
mkCreateReleaseOption
  :: Text -- ^ 'createReleaseOptionTagName' 
  -> CreateReleaseOption
mkCreateReleaseOption createReleaseOptionTagName =
  CreateReleaseOption
  { createReleaseOptionBody = Nothing
  , createReleaseOptionDraft = Nothing
  , createReleaseOptionName = Nothing
  , createReleaseOptionPrerelease = Nothing
  , createReleaseOptionTagName
  , createReleaseOptionTargetCommitish = Nothing
  }

-- ** CreateRepoOption
-- | CreateRepoOption
-- CreateRepoOption options when creating repository
data CreateRepoOption = CreateRepoOption
  { createRepoOptionAutoInit :: !(Maybe Bool) -- ^ "auto_init" - Whether the repository should be auto-intialized?
  , createRepoOptionDescription :: !(Maybe Text) -- ^ "description" - Description of the repository to create
  , createRepoOptionGitignores :: !(Maybe Text) -- ^ "gitignores" - Gitignores to use
  , createRepoOptionLicense :: !(Maybe Text) -- ^ "license" - License to use
  , createRepoOptionName :: !(Text) -- ^ /Required/ "name" - Name of the repository to create
  , createRepoOptionPrivate :: !(Maybe Bool) -- ^ "private" - Whether the repository is private
  , createRepoOptionReadme :: !(Maybe Text) -- ^ "readme" - Readme of the repository to create
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateRepoOption
instance A.FromJSON CreateRepoOption where
  parseJSON = A.withObject "CreateRepoOption" $ \o ->
    CreateRepoOption
      <$> (o .:? "auto_init")
      <*> (o .:? "description")
      <*> (o .:? "gitignores")
      <*> (o .:? "license")
      <*> (o .:  "name")
      <*> (o .:? "private")
      <*> (o .:? "readme")

-- | ToJSON CreateRepoOption
instance A.ToJSON CreateRepoOption where
  toJSON CreateRepoOption {..} =
   _omitNulls
      [ "auto_init" .= createRepoOptionAutoInit
      , "description" .= createRepoOptionDescription
      , "gitignores" .= createRepoOptionGitignores
      , "license" .= createRepoOptionLicense
      , "name" .= createRepoOptionName
      , "private" .= createRepoOptionPrivate
      , "readme" .= createRepoOptionReadme
      ]


-- | Construct a value of type 'CreateRepoOption' (by applying it's required fields, if any)
mkCreateRepoOption
  :: Text -- ^ 'createRepoOptionName': Name of the repository to create
  -> CreateRepoOption
mkCreateRepoOption createRepoOptionName =
  CreateRepoOption
  { createRepoOptionAutoInit = Nothing
  , createRepoOptionDescription = Nothing
  , createRepoOptionGitignores = Nothing
  , createRepoOptionLicense = Nothing
  , createRepoOptionName
  , createRepoOptionPrivate = Nothing
  , createRepoOptionReadme = Nothing
  }

-- ** CreateStatusOption
-- | CreateStatusOption
-- CreateStatusOption holds the information needed to create a new Status for a Commit
data CreateStatusOption = CreateStatusOption
  { createStatusOptionContext :: !(Maybe Text) -- ^ "context"
  , createStatusOptionDescription :: !(Maybe Text) -- ^ "description"
  , createStatusOptionState :: !(Maybe Text) -- ^ "state" - StatusState holds the state of a Status It can be \&quot;pending\&quot;, \&quot;success\&quot;, \&quot;error\&quot;, \&quot;failure\&quot;, and \&quot;warning\&quot;
  , createStatusOptionTargetUrl :: !(Maybe Text) -- ^ "target_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateStatusOption
instance A.FromJSON CreateStatusOption where
  parseJSON = A.withObject "CreateStatusOption" $ \o ->
    CreateStatusOption
      <$> (o .:? "context")
      <*> (o .:? "description")
      <*> (o .:? "state")
      <*> (o .:? "target_url")

-- | ToJSON CreateStatusOption
instance A.ToJSON CreateStatusOption where
  toJSON CreateStatusOption {..} =
   _omitNulls
      [ "context" .= createStatusOptionContext
      , "description" .= createStatusOptionDescription
      , "state" .= createStatusOptionState
      , "target_url" .= createStatusOptionTargetUrl
      ]


-- | Construct a value of type 'CreateStatusOption' (by applying it's required fields, if any)
mkCreateStatusOption
  :: CreateStatusOption
mkCreateStatusOption =
  CreateStatusOption
  { createStatusOptionContext = Nothing
  , createStatusOptionDescription = Nothing
  , createStatusOptionState = Nothing
  , createStatusOptionTargetUrl = Nothing
  }

-- ** CreateTeamOption
-- | CreateTeamOption
-- CreateTeamOption options for creating a team
data CreateTeamOption = CreateTeamOption
  { createTeamOptionDescription :: !(Maybe Text) -- ^ "description"
  , createTeamOptionName :: !(Text) -- ^ /Required/ "name"
  , createTeamOptionPermission :: !(Maybe E'Permission) -- ^ "permission"
  , createTeamOptionUnits :: !(Maybe [Text]) -- ^ "units"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTeamOption
instance A.FromJSON CreateTeamOption where
  parseJSON = A.withObject "CreateTeamOption" $ \o ->
    CreateTeamOption
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "permission")
      <*> (o .:? "units")

-- | ToJSON CreateTeamOption
instance A.ToJSON CreateTeamOption where
  toJSON CreateTeamOption {..} =
   _omitNulls
      [ "description" .= createTeamOptionDescription
      , "name" .= createTeamOptionName
      , "permission" .= createTeamOptionPermission
      , "units" .= createTeamOptionUnits
      ]


-- | Construct a value of type 'CreateTeamOption' (by applying it's required fields, if any)
mkCreateTeamOption
  :: Text -- ^ 'createTeamOptionName' 
  -> CreateTeamOption
mkCreateTeamOption createTeamOptionName =
  CreateTeamOption
  { createTeamOptionDescription = Nothing
  , createTeamOptionName
  , createTeamOptionPermission = Nothing
  , createTeamOptionUnits = Nothing
  }

-- ** CreateUserOption
-- | CreateUserOption
-- CreateUserOption create user options
data CreateUserOption = CreateUserOption
  { createUserOptionEmail :: !(Text) -- ^ /Required/ "email"
  , createUserOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , createUserOptionLoginName :: !(Maybe Text) -- ^ "login_name"
  , createUserOptionMustChangePassword :: !(Maybe Bool) -- ^ "must_change_password"
  , createUserOptionPassword :: !(Text) -- ^ /Required/ "password"
  , createUserOptionSendNotify :: !(Maybe Bool) -- ^ "send_notify"
  , createUserOptionSourceId :: !(Maybe Integer) -- ^ "source_id"
  , createUserOptionUsername :: !(Text) -- ^ /Required/ "username"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUserOption
instance A.FromJSON CreateUserOption where
  parseJSON = A.withObject "CreateUserOption" $ \o ->
    CreateUserOption
      <$> (o .:  "email")
      <*> (o .:? "full_name")
      <*> (o .:? "login_name")
      <*> (o .:? "must_change_password")
      <*> (o .:  "password")
      <*> (o .:? "send_notify")
      <*> (o .:? "source_id")
      <*> (o .:  "username")

-- | ToJSON CreateUserOption
instance A.ToJSON CreateUserOption where
  toJSON CreateUserOption {..} =
   _omitNulls
      [ "email" .= createUserOptionEmail
      , "full_name" .= createUserOptionFullName
      , "login_name" .= createUserOptionLoginName
      , "must_change_password" .= createUserOptionMustChangePassword
      , "password" .= createUserOptionPassword
      , "send_notify" .= createUserOptionSendNotify
      , "source_id" .= createUserOptionSourceId
      , "username" .= createUserOptionUsername
      ]


-- | Construct a value of type 'CreateUserOption' (by applying it's required fields, if any)
mkCreateUserOption
  :: Text -- ^ 'createUserOptionEmail' 
  -> Text -- ^ 'createUserOptionPassword' 
  -> Text -- ^ 'createUserOptionUsername' 
  -> CreateUserOption
mkCreateUserOption createUserOptionEmail createUserOptionPassword createUserOptionUsername =
  CreateUserOption
  { createUserOptionEmail
  , createUserOptionFullName = Nothing
  , createUserOptionLoginName = Nothing
  , createUserOptionMustChangePassword = Nothing
  , createUserOptionPassword
  , createUserOptionSendNotify = Nothing
  , createUserOptionSourceId = Nothing
  , createUserOptionUsername
  }

-- ** DeleteEmailOption
-- | DeleteEmailOption
-- DeleteEmailOption options when deleting email addresses
data DeleteEmailOption = DeleteEmailOption
  { deleteEmailOptionEmails :: !(Maybe [Text]) -- ^ "emails" - email addresses to delete
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteEmailOption
instance A.FromJSON DeleteEmailOption where
  parseJSON = A.withObject "DeleteEmailOption" $ \o ->
    DeleteEmailOption
      <$> (o .:? "emails")

-- | ToJSON DeleteEmailOption
instance A.ToJSON DeleteEmailOption where
  toJSON DeleteEmailOption {..} =
   _omitNulls
      [ "emails" .= deleteEmailOptionEmails
      ]


-- | Construct a value of type 'DeleteEmailOption' (by applying it's required fields, if any)
mkDeleteEmailOption
  :: DeleteEmailOption
mkDeleteEmailOption =
  DeleteEmailOption
  { deleteEmailOptionEmails = Nothing
  }

-- ** DeleteFileOptions
-- | DeleteFileOptions
-- DeleteFileOptions options for deleting files (used for other File structs below) Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data DeleteFileOptions = DeleteFileOptions
  { deleteFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , deleteFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , deleteFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , deleteFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , deleteFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , deleteFileOptionsSha :: !(Text) -- ^ /Required/ "sha" - sha is the SHA for the file that already exists
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteFileOptions
instance A.FromJSON DeleteFileOptions where
  parseJSON = A.withObject "DeleteFileOptions" $ \o ->
    DeleteFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:  "sha")

-- | ToJSON DeleteFileOptions
instance A.ToJSON DeleteFileOptions where
  toJSON DeleteFileOptions {..} =
   _omitNulls
      [ "author" .= deleteFileOptionsAuthor
      , "branch" .= deleteFileOptionsBranch
      , "committer" .= deleteFileOptionsCommitter
      , "message" .= deleteFileOptionsMessage
      , "new_branch" .= deleteFileOptionsNewBranch
      , "sha" .= deleteFileOptionsSha
      ]


-- | Construct a value of type 'DeleteFileOptions' (by applying it's required fields, if any)
mkDeleteFileOptions
  :: Text -- ^ 'deleteFileOptionsSha': sha is the SHA for the file that already exists
  -> DeleteFileOptions
mkDeleteFileOptions deleteFileOptionsSha =
  DeleteFileOptions
  { deleteFileOptionsAuthor = Nothing
  , deleteFileOptionsBranch = Nothing
  , deleteFileOptionsCommitter = Nothing
  , deleteFileOptionsMessage = Nothing
  , deleteFileOptionsNewBranch = Nothing
  , deleteFileOptionsSha
  }

-- ** DeployKey
-- | DeployKey
-- DeployKey a deploy key
data DeployKey = DeployKey
  { deployKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , deployKeyFingerprint :: !(Maybe Text) -- ^ "fingerprint"
  , deployKeyId :: !(Maybe Integer) -- ^ "id"
  , deployKeyKey :: !(Maybe Text) -- ^ "key"
  , deployKeyKeyId :: !(Maybe Integer) -- ^ "key_id"
  , deployKeyReadOnly :: !(Maybe Bool) -- ^ "read_only"
  , deployKeyRepository :: !(Maybe Repository) -- ^ "repository"
  , deployKeyTitle :: !(Maybe Text) -- ^ "title"
  , deployKeyUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeployKey
instance A.FromJSON DeployKey where
  parseJSON = A.withObject "DeployKey" $ \o ->
    DeployKey
      <$> (o .:? "created_at")
      <*> (o .:? "fingerprint")
      <*> (o .:? "id")
      <*> (o .:? "key")
      <*> (o .:? "key_id")
      <*> (o .:? "read_only")
      <*> (o .:? "repository")
      <*> (o .:? "title")
      <*> (o .:? "url")

-- | ToJSON DeployKey
instance A.ToJSON DeployKey where
  toJSON DeployKey {..} =
   _omitNulls
      [ "created_at" .= deployKeyCreatedAt
      , "fingerprint" .= deployKeyFingerprint
      , "id" .= deployKeyId
      , "key" .= deployKeyKey
      , "key_id" .= deployKeyKeyId
      , "read_only" .= deployKeyReadOnly
      , "repository" .= deployKeyRepository
      , "title" .= deployKeyTitle
      , "url" .= deployKeyUrl
      ]


-- | Construct a value of type 'DeployKey' (by applying it's required fields, if any)
mkDeployKey
  :: DeployKey
mkDeployKey =
  DeployKey
  { deployKeyCreatedAt = Nothing
  , deployKeyFingerprint = Nothing
  , deployKeyId = Nothing
  , deployKeyKey = Nothing
  , deployKeyKeyId = Nothing
  , deployKeyReadOnly = Nothing
  , deployKeyRepository = Nothing
  , deployKeyTitle = Nothing
  , deployKeyUrl = Nothing
  }

-- ** EditAttachmentOptions
-- | EditAttachmentOptions
-- EditAttachmentOptions options for editing attachments
data EditAttachmentOptions = EditAttachmentOptions
  { editAttachmentOptionsName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditAttachmentOptions
instance A.FromJSON EditAttachmentOptions where
  parseJSON = A.withObject "EditAttachmentOptions" $ \o ->
    EditAttachmentOptions
      <$> (o .:? "name")

-- | ToJSON EditAttachmentOptions
instance A.ToJSON EditAttachmentOptions where
  toJSON EditAttachmentOptions {..} =
   _omitNulls
      [ "name" .= editAttachmentOptionsName
      ]


-- | Construct a value of type 'EditAttachmentOptions' (by applying it's required fields, if any)
mkEditAttachmentOptions
  :: EditAttachmentOptions
mkEditAttachmentOptions =
  EditAttachmentOptions
  { editAttachmentOptionsName = Nothing
  }

-- ** EditDeadlineOption
-- | EditDeadlineOption
-- EditDeadlineOption options for creating a deadline
data EditDeadlineOption = EditDeadlineOption
  { editDeadlineOptionDueDate :: !(DateTime) -- ^ /Required/ "due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditDeadlineOption
instance A.FromJSON EditDeadlineOption where
  parseJSON = A.withObject "EditDeadlineOption" $ \o ->
    EditDeadlineOption
      <$> (o .:  "due_date")

-- | ToJSON EditDeadlineOption
instance A.ToJSON EditDeadlineOption where
  toJSON EditDeadlineOption {..} =
   _omitNulls
      [ "due_date" .= editDeadlineOptionDueDate
      ]


-- | Construct a value of type 'EditDeadlineOption' (by applying it's required fields, if any)
mkEditDeadlineOption
  :: DateTime -- ^ 'editDeadlineOptionDueDate' 
  -> EditDeadlineOption
mkEditDeadlineOption editDeadlineOptionDueDate =
  EditDeadlineOption
  { editDeadlineOptionDueDate
  }

-- ** EditGitHookOption
-- | EditGitHookOption
-- EditGitHookOption options when modifying one Git hook
data EditGitHookOption = EditGitHookOption
  { editGitHookOptionContent :: !(Maybe Text) -- ^ "content"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditGitHookOption
instance A.FromJSON EditGitHookOption where
  parseJSON = A.withObject "EditGitHookOption" $ \o ->
    EditGitHookOption
      <$> (o .:? "content")

-- | ToJSON EditGitHookOption
instance A.ToJSON EditGitHookOption where
  toJSON EditGitHookOption {..} =
   _omitNulls
      [ "content" .= editGitHookOptionContent
      ]


-- | Construct a value of type 'EditGitHookOption' (by applying it's required fields, if any)
mkEditGitHookOption
  :: EditGitHookOption
mkEditGitHookOption =
  EditGitHookOption
  { editGitHookOptionContent = Nothing
  }

-- ** EditHookOption
-- | EditHookOption
-- EditHookOption options when modify one hook
data EditHookOption = EditHookOption
  { editHookOptionActive :: !(Maybe Bool) -- ^ "active"
  , editHookOptionConfig :: !(Maybe (Map.Map String Text)) -- ^ "config"
  , editHookOptionEvents :: !(Maybe [Text]) -- ^ "events"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditHookOption
instance A.FromJSON EditHookOption where
  parseJSON = A.withObject "EditHookOption" $ \o ->
    EditHookOption
      <$> (o .:? "active")
      <*> (o .:? "config")
      <*> (o .:? "events")

-- | ToJSON EditHookOption
instance A.ToJSON EditHookOption where
  toJSON EditHookOption {..} =
   _omitNulls
      [ "active" .= editHookOptionActive
      , "config" .= editHookOptionConfig
      , "events" .= editHookOptionEvents
      ]


-- | Construct a value of type 'EditHookOption' (by applying it's required fields, if any)
mkEditHookOption
  :: EditHookOption
mkEditHookOption =
  EditHookOption
  { editHookOptionActive = Nothing
  , editHookOptionConfig = Nothing
  , editHookOptionEvents = Nothing
  }

-- ** EditIssueCommentOption
-- | EditIssueCommentOption
-- EditIssueCommentOption options for editing a comment
data EditIssueCommentOption = EditIssueCommentOption
  { editIssueCommentOptionBody :: !(Text) -- ^ /Required/ "body"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditIssueCommentOption
instance A.FromJSON EditIssueCommentOption where
  parseJSON = A.withObject "EditIssueCommentOption" $ \o ->
    EditIssueCommentOption
      <$> (o .:  "body")

-- | ToJSON EditIssueCommentOption
instance A.ToJSON EditIssueCommentOption where
  toJSON EditIssueCommentOption {..} =
   _omitNulls
      [ "body" .= editIssueCommentOptionBody
      ]


-- | Construct a value of type 'EditIssueCommentOption' (by applying it's required fields, if any)
mkEditIssueCommentOption
  :: Text -- ^ 'editIssueCommentOptionBody' 
  -> EditIssueCommentOption
mkEditIssueCommentOption editIssueCommentOptionBody =
  EditIssueCommentOption
  { editIssueCommentOptionBody
  }

-- ** EditIssueOption
-- | EditIssueOption
-- EditIssueOption options for editing an issue
data EditIssueOption = EditIssueOption
  { editIssueOptionAssignee :: !(Maybe Text) -- ^ "assignee"
  , editIssueOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , editIssueOptionBody :: !(Maybe Text) -- ^ "body"
  , editIssueOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , editIssueOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , editIssueOptionState :: !(Maybe Text) -- ^ "state"
  , editIssueOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditIssueOption
instance A.FromJSON EditIssueOption where
  parseJSON = A.withObject "EditIssueOption" $ \o ->
    EditIssueOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "milestone")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON EditIssueOption
instance A.ToJSON EditIssueOption where
  toJSON EditIssueOption {..} =
   _omitNulls
      [ "assignee" .= editIssueOptionAssignee
      , "assignees" .= editIssueOptionAssignees
      , "body" .= editIssueOptionBody
      , "due_date" .= editIssueOptionDueDate
      , "milestone" .= editIssueOptionMilestone
      , "state" .= editIssueOptionState
      , "title" .= editIssueOptionTitle
      ]


-- | Construct a value of type 'EditIssueOption' (by applying it's required fields, if any)
mkEditIssueOption
  :: EditIssueOption
mkEditIssueOption =
  EditIssueOption
  { editIssueOptionAssignee = Nothing
  , editIssueOptionAssignees = Nothing
  , editIssueOptionBody = Nothing
  , editIssueOptionDueDate = Nothing
  , editIssueOptionMilestone = Nothing
  , editIssueOptionState = Nothing
  , editIssueOptionTitle = Nothing
  }

-- ** EditLabelOption
-- | EditLabelOption
-- EditLabelOption options for editing a label
data EditLabelOption = EditLabelOption
  { editLabelOptionColor :: !(Maybe Text) -- ^ "color"
  , editLabelOptionDescription :: !(Maybe Text) -- ^ "description"
  , editLabelOptionName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditLabelOption
instance A.FromJSON EditLabelOption where
  parseJSON = A.withObject "EditLabelOption" $ \o ->
    EditLabelOption
      <$> (o .:? "color")
      <*> (o .:? "description")
      <*> (o .:? "name")

-- | ToJSON EditLabelOption
instance A.ToJSON EditLabelOption where
  toJSON EditLabelOption {..} =
   _omitNulls
      [ "color" .= editLabelOptionColor
      , "description" .= editLabelOptionDescription
      , "name" .= editLabelOptionName
      ]


-- | Construct a value of type 'EditLabelOption' (by applying it's required fields, if any)
mkEditLabelOption
  :: EditLabelOption
mkEditLabelOption =
  EditLabelOption
  { editLabelOptionColor = Nothing
  , editLabelOptionDescription = Nothing
  , editLabelOptionName = Nothing
  }

-- ** EditMilestoneOption
-- | EditMilestoneOption
-- EditMilestoneOption options for editing a milestone
data EditMilestoneOption = EditMilestoneOption
  { editMilestoneOptionDescription :: !(Maybe Text) -- ^ "description"
  , editMilestoneOptionDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , editMilestoneOptionState :: !(Maybe Text) -- ^ "state"
  , editMilestoneOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditMilestoneOption
instance A.FromJSON EditMilestoneOption where
  parseJSON = A.withObject "EditMilestoneOption" $ \o ->
    EditMilestoneOption
      <$> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON EditMilestoneOption
instance A.ToJSON EditMilestoneOption where
  toJSON EditMilestoneOption {..} =
   _omitNulls
      [ "description" .= editMilestoneOptionDescription
      , "due_on" .= editMilestoneOptionDueOn
      , "state" .= editMilestoneOptionState
      , "title" .= editMilestoneOptionTitle
      ]


-- | Construct a value of type 'EditMilestoneOption' (by applying it's required fields, if any)
mkEditMilestoneOption
  :: EditMilestoneOption
mkEditMilestoneOption =
  EditMilestoneOption
  { editMilestoneOptionDescription = Nothing
  , editMilestoneOptionDueOn = Nothing
  , editMilestoneOptionState = Nothing
  , editMilestoneOptionTitle = Nothing
  }

-- ** EditOrgOption
-- | EditOrgOption
-- EditOrgOption options for editing an organization
data EditOrgOption = EditOrgOption
  { editOrgOptionDescription :: !(Maybe Text) -- ^ "description"
  , editOrgOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , editOrgOptionLocation :: !(Maybe Text) -- ^ "location"
  , editOrgOptionVisibility :: !(Maybe E'Visibility) -- ^ "visibility" - possible values are &#x60;public&#x60;, &#x60;limited&#x60; or &#x60;private&#x60;
  , editOrgOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditOrgOption
instance A.FromJSON EditOrgOption where
  parseJSON = A.withObject "EditOrgOption" $ \o ->
    EditOrgOption
      <$> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON EditOrgOption
instance A.ToJSON EditOrgOption where
  toJSON EditOrgOption {..} =
   _omitNulls
      [ "description" .= editOrgOptionDescription
      , "full_name" .= editOrgOptionFullName
      , "location" .= editOrgOptionLocation
      , "visibility" .= editOrgOptionVisibility
      , "website" .= editOrgOptionWebsite
      ]


-- | Construct a value of type 'EditOrgOption' (by applying it's required fields, if any)
mkEditOrgOption
  :: EditOrgOption
mkEditOrgOption =
  EditOrgOption
  { editOrgOptionDescription = Nothing
  , editOrgOptionFullName = Nothing
  , editOrgOptionLocation = Nothing
  , editOrgOptionVisibility = Nothing
  , editOrgOptionWebsite = Nothing
  }

-- ** EditPullRequestOption
-- | EditPullRequestOption
-- EditPullRequestOption options when modify pull request
data EditPullRequestOption = EditPullRequestOption
  { editPullRequestOptionAssignee :: !(Maybe Text) -- ^ "assignee"
  , editPullRequestOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , editPullRequestOptionBody :: !(Maybe Text) -- ^ "body"
  , editPullRequestOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , editPullRequestOptionLabels :: !(Maybe [Integer]) -- ^ "labels"
  , editPullRequestOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , editPullRequestOptionState :: !(Maybe Text) -- ^ "state"
  , editPullRequestOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditPullRequestOption
instance A.FromJSON EditPullRequestOption where
  parseJSON = A.withObject "EditPullRequestOption" $ \o ->
    EditPullRequestOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON EditPullRequestOption
instance A.ToJSON EditPullRequestOption where
  toJSON EditPullRequestOption {..} =
   _omitNulls
      [ "assignee" .= editPullRequestOptionAssignee
      , "assignees" .= editPullRequestOptionAssignees
      , "body" .= editPullRequestOptionBody
      , "due_date" .= editPullRequestOptionDueDate
      , "labels" .= editPullRequestOptionLabels
      , "milestone" .= editPullRequestOptionMilestone
      , "state" .= editPullRequestOptionState
      , "title" .= editPullRequestOptionTitle
      ]


-- | Construct a value of type 'EditPullRequestOption' (by applying it's required fields, if any)
mkEditPullRequestOption
  :: EditPullRequestOption
mkEditPullRequestOption =
  EditPullRequestOption
  { editPullRequestOptionAssignee = Nothing
  , editPullRequestOptionAssignees = Nothing
  , editPullRequestOptionBody = Nothing
  , editPullRequestOptionDueDate = Nothing
  , editPullRequestOptionLabels = Nothing
  , editPullRequestOptionMilestone = Nothing
  , editPullRequestOptionState = Nothing
  , editPullRequestOptionTitle = Nothing
  }

-- ** EditReleaseOption
-- | EditReleaseOption
-- EditReleaseOption options when editing a release
data EditReleaseOption = EditReleaseOption
  { editReleaseOptionBody :: !(Maybe Text) -- ^ "body"
  , editReleaseOptionDraft :: !(Maybe Bool) -- ^ "draft"
  , editReleaseOptionName :: !(Maybe Text) -- ^ "name"
  , editReleaseOptionPrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , editReleaseOptionTagName :: !(Maybe Text) -- ^ "tag_name"
  , editReleaseOptionTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditReleaseOption
instance A.FromJSON EditReleaseOption where
  parseJSON = A.withObject "EditReleaseOption" $ \o ->
    EditReleaseOption
      <$> (o .:? "body")
      <*> (o .:? "draft")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:? "tag_name")
      <*> (o .:? "target_commitish")

-- | ToJSON EditReleaseOption
instance A.ToJSON EditReleaseOption where
  toJSON EditReleaseOption {..} =
   _omitNulls
      [ "body" .= editReleaseOptionBody
      , "draft" .= editReleaseOptionDraft
      , "name" .= editReleaseOptionName
      , "prerelease" .= editReleaseOptionPrerelease
      , "tag_name" .= editReleaseOptionTagName
      , "target_commitish" .= editReleaseOptionTargetCommitish
      ]


-- | Construct a value of type 'EditReleaseOption' (by applying it's required fields, if any)
mkEditReleaseOption
  :: EditReleaseOption
mkEditReleaseOption =
  EditReleaseOption
  { editReleaseOptionBody = Nothing
  , editReleaseOptionDraft = Nothing
  , editReleaseOptionName = Nothing
  , editReleaseOptionPrerelease = Nothing
  , editReleaseOptionTagName = Nothing
  , editReleaseOptionTargetCommitish = Nothing
  }

-- ** EditRepoOption
-- | EditRepoOption
-- EditRepoOption options when editing a repository's properties
data EditRepoOption = EditRepoOption
  { editRepoOptionAllowMergeCommits :: !(Maybe Bool) -- ^ "allow_merge_commits" - either &#x60;true&#x60; to allow merging pull requests with a merge commit, or &#x60;false&#x60; to prevent merging pull requests with merge commits. &#x60;has_pull_requests&#x60; must be &#x60;true&#x60;.
  , editRepoOptionAllowRebase :: !(Maybe Bool) -- ^ "allow_rebase" - either &#x60;true&#x60; to allow rebase-merging pull requests, or &#x60;false&#x60; to prevent rebase-merging. &#x60;has_pull_requests&#x60; must be &#x60;true&#x60;.
  , editRepoOptionAllowRebaseExplicit :: !(Maybe Bool) -- ^ "allow_rebase_explicit" - either &#x60;true&#x60; to allow rebase with explicit merge commits (--no-ff), or &#x60;false&#x60; to prevent rebase with explicit merge commits. &#x60;has_pull_requests&#x60; must be &#x60;true&#x60;.
  , editRepoOptionAllowSquashMerge :: !(Maybe Bool) -- ^ "allow_squash_merge" - either &#x60;true&#x60; to allow squash-merging pull requests, or &#x60;false&#x60; to prevent squash-merging. &#x60;has_pull_requests&#x60; must be &#x60;true&#x60;.
  , editRepoOptionArchived :: !(Maybe Bool) -- ^ "archived" - set to &#x60;true&#x60; to archive this repository.
  , editRepoOptionDefaultBranch :: !(Maybe Text) -- ^ "default_branch" - sets the default branch for this repository.
  , editRepoOptionDescription :: !(Maybe Text) -- ^ "description" - a short description of the repository.
  , editRepoOptionHasIssues :: !(Maybe Bool) -- ^ "has_issues" - either &#x60;true&#x60; to enable issues for this repository or &#x60;false&#x60; to disable them.
  , editRepoOptionHasPullRequests :: !(Maybe Bool) -- ^ "has_pull_requests" - either &#x60;true&#x60; to allow pull requests, or &#x60;false&#x60; to prevent pull request.
  , editRepoOptionHasWiki :: !(Maybe Bool) -- ^ "has_wiki" - either &#x60;true&#x60; to enable the wiki for this repository or &#x60;false&#x60; to disable it.
  , editRepoOptionIgnoreWhitespaceConflicts :: !(Maybe Bool) -- ^ "ignore_whitespace_conflicts" - either &#x60;true&#x60; to ignore whitespace for conflicts, or &#x60;false&#x60; to not ignore whitespace. &#x60;has_pull_requests&#x60; must be &#x60;true&#x60;.
  , editRepoOptionName :: !(Maybe Text) -- ^ "name" - name of the repository
  , editRepoOptionPrivate :: !(Maybe Bool) -- ^ "private" - either &#x60;true&#x60; to make the repository private or &#x60;false&#x60; to make it public. Note: you will get a 422 error if the organization restricts changing repository visibility to organization owners and a non-owner tries to change the value of private.
  , editRepoOptionWebsite :: !(Maybe Text) -- ^ "website" - a URL with more information about the repository.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditRepoOption
instance A.FromJSON EditRepoOption where
  parseJSON = A.withObject "EditRepoOption" $ \o ->
    EditRepoOption
      <$> (o .:? "allow_merge_commits")
      <*> (o .:? "allow_rebase")
      <*> (o .:? "allow_rebase_explicit")
      <*> (o .:? "allow_squash_merge")
      <*> (o .:? "archived")
      <*> (o .:? "default_branch")
      <*> (o .:? "description")
      <*> (o .:? "has_issues")
      <*> (o .:? "has_pull_requests")
      <*> (o .:? "has_wiki")
      <*> (o .:? "ignore_whitespace_conflicts")
      <*> (o .:? "name")
      <*> (o .:? "private")
      <*> (o .:? "website")

-- | ToJSON EditRepoOption
instance A.ToJSON EditRepoOption where
  toJSON EditRepoOption {..} =
   _omitNulls
      [ "allow_merge_commits" .= editRepoOptionAllowMergeCommits
      , "allow_rebase" .= editRepoOptionAllowRebase
      , "allow_rebase_explicit" .= editRepoOptionAllowRebaseExplicit
      , "allow_squash_merge" .= editRepoOptionAllowSquashMerge
      , "archived" .= editRepoOptionArchived
      , "default_branch" .= editRepoOptionDefaultBranch
      , "description" .= editRepoOptionDescription
      , "has_issues" .= editRepoOptionHasIssues
      , "has_pull_requests" .= editRepoOptionHasPullRequests
      , "has_wiki" .= editRepoOptionHasWiki
      , "ignore_whitespace_conflicts" .= editRepoOptionIgnoreWhitespaceConflicts
      , "name" .= editRepoOptionName
      , "private" .= editRepoOptionPrivate
      , "website" .= editRepoOptionWebsite
      ]


-- | Construct a value of type 'EditRepoOption' (by applying it's required fields, if any)
mkEditRepoOption
  :: EditRepoOption
mkEditRepoOption =
  EditRepoOption
  { editRepoOptionAllowMergeCommits = Nothing
  , editRepoOptionAllowRebase = Nothing
  , editRepoOptionAllowRebaseExplicit = Nothing
  , editRepoOptionAllowSquashMerge = Nothing
  , editRepoOptionArchived = Nothing
  , editRepoOptionDefaultBranch = Nothing
  , editRepoOptionDescription = Nothing
  , editRepoOptionHasIssues = Nothing
  , editRepoOptionHasPullRequests = Nothing
  , editRepoOptionHasWiki = Nothing
  , editRepoOptionIgnoreWhitespaceConflicts = Nothing
  , editRepoOptionName = Nothing
  , editRepoOptionPrivate = Nothing
  , editRepoOptionWebsite = Nothing
  }

-- ** EditTeamOption
-- | EditTeamOption
-- EditTeamOption options for editing a team
data EditTeamOption = EditTeamOption
  { editTeamOptionDescription :: !(Maybe Text) -- ^ "description"
  , editTeamOptionName :: !(Text) -- ^ /Required/ "name"
  , editTeamOptionPermission :: !(Maybe E'Permission) -- ^ "permission"
  , editTeamOptionUnits :: !(Maybe [Text]) -- ^ "units"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditTeamOption
instance A.FromJSON EditTeamOption where
  parseJSON = A.withObject "EditTeamOption" $ \o ->
    EditTeamOption
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "permission")
      <*> (o .:? "units")

-- | ToJSON EditTeamOption
instance A.ToJSON EditTeamOption where
  toJSON EditTeamOption {..} =
   _omitNulls
      [ "description" .= editTeamOptionDescription
      , "name" .= editTeamOptionName
      , "permission" .= editTeamOptionPermission
      , "units" .= editTeamOptionUnits
      ]


-- | Construct a value of type 'EditTeamOption' (by applying it's required fields, if any)
mkEditTeamOption
  :: Text -- ^ 'editTeamOptionName' 
  -> EditTeamOption
mkEditTeamOption editTeamOptionName =
  EditTeamOption
  { editTeamOptionDescription = Nothing
  , editTeamOptionName
  , editTeamOptionPermission = Nothing
  , editTeamOptionUnits = Nothing
  }

-- ** EditUserOption
-- | EditUserOption
-- EditUserOption edit user options
data EditUserOption = EditUserOption
  { editUserOptionActive :: !(Maybe Bool) -- ^ "active"
  , editUserOptionAdmin :: !(Maybe Bool) -- ^ "admin"
  , editUserOptionAllowCreateOrganization :: !(Maybe Bool) -- ^ "allow_create_organization"
  , editUserOptionAllowGitHook :: !(Maybe Bool) -- ^ "allow_git_hook"
  , editUserOptionAllowImportLocal :: !(Maybe Bool) -- ^ "allow_import_local"
  , editUserOptionEmail :: !(Text) -- ^ /Required/ "email"
  , editUserOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , editUserOptionLocation :: !(Maybe Text) -- ^ "location"
  , editUserOptionLoginName :: !(Maybe Text) -- ^ "login_name"
  , editUserOptionMaxRepoCreation :: !(Maybe Integer) -- ^ "max_repo_creation"
  , editUserOptionMustChangePassword :: !(Maybe Bool) -- ^ "must_change_password"
  , editUserOptionPassword :: !(Maybe Text) -- ^ "password"
  , editUserOptionProhibitLogin :: !(Maybe Bool) -- ^ "prohibit_login"
  , editUserOptionSourceId :: !(Maybe Integer) -- ^ "source_id"
  , editUserOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditUserOption
instance A.FromJSON EditUserOption where
  parseJSON = A.withObject "EditUserOption" $ \o ->
    EditUserOption
      <$> (o .:? "active")
      <*> (o .:? "admin")
      <*> (o .:? "allow_create_organization")
      <*> (o .:? "allow_git_hook")
      <*> (o .:? "allow_import_local")
      <*> (o .:  "email")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:? "login_name")
      <*> (o .:? "max_repo_creation")
      <*> (o .:? "must_change_password")
      <*> (o .:? "password")
      <*> (o .:? "prohibit_login")
      <*> (o .:? "source_id")
      <*> (o .:? "website")

-- | ToJSON EditUserOption
instance A.ToJSON EditUserOption where
  toJSON EditUserOption {..} =
   _omitNulls
      [ "active" .= editUserOptionActive
      , "admin" .= editUserOptionAdmin
      , "allow_create_organization" .= editUserOptionAllowCreateOrganization
      , "allow_git_hook" .= editUserOptionAllowGitHook
      , "allow_import_local" .= editUserOptionAllowImportLocal
      , "email" .= editUserOptionEmail
      , "full_name" .= editUserOptionFullName
      , "location" .= editUserOptionLocation
      , "login_name" .= editUserOptionLoginName
      , "max_repo_creation" .= editUserOptionMaxRepoCreation
      , "must_change_password" .= editUserOptionMustChangePassword
      , "password" .= editUserOptionPassword
      , "prohibit_login" .= editUserOptionProhibitLogin
      , "source_id" .= editUserOptionSourceId
      , "website" .= editUserOptionWebsite
      ]


-- | Construct a value of type 'EditUserOption' (by applying it's required fields, if any)
mkEditUserOption
  :: Text -- ^ 'editUserOptionEmail' 
  -> EditUserOption
mkEditUserOption editUserOptionEmail =
  EditUserOption
  { editUserOptionActive = Nothing
  , editUserOptionAdmin = Nothing
  , editUserOptionAllowCreateOrganization = Nothing
  , editUserOptionAllowGitHook = Nothing
  , editUserOptionAllowImportLocal = Nothing
  , editUserOptionEmail
  , editUserOptionFullName = Nothing
  , editUserOptionLocation = Nothing
  , editUserOptionLoginName = Nothing
  , editUserOptionMaxRepoCreation = Nothing
  , editUserOptionMustChangePassword = Nothing
  , editUserOptionPassword = Nothing
  , editUserOptionProhibitLogin = Nothing
  , editUserOptionSourceId = Nothing
  , editUserOptionWebsite = Nothing
  }

-- ** Email
-- | Email
-- Email an email address belonging to a user
data Email = Email
  { emailEmail :: !(Maybe Text) -- ^ "email"
  , emailPrimary :: !(Maybe Bool) -- ^ "primary"
  , emailVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Email
instance A.FromJSON Email where
  parseJSON = A.withObject "Email" $ \o ->
    Email
      <$> (o .:? "email")
      <*> (o .:? "primary")
      <*> (o .:? "verified")

-- | ToJSON Email
instance A.ToJSON Email where
  toJSON Email {..} =
   _omitNulls
      [ "email" .= emailEmail
      , "primary" .= emailPrimary
      , "verified" .= emailVerified
      ]


-- | Construct a value of type 'Email' (by applying it's required fields, if any)
mkEmail
  :: Email
mkEmail =
  Email
  { emailEmail = Nothing
  , emailPrimary = Nothing
  , emailVerified = Nothing
  }

-- ** FileCommitResponse
-- | FileCommitResponse
-- FileCommitResponse contains information generated from a Git commit for a repo's file.
-- 
data FileCommitResponse = FileCommitResponse
  { fileCommitResponseAuthor :: !(Maybe CommitUser) -- ^ "author"
  , fileCommitResponseCommitter :: !(Maybe CommitUser) -- ^ "committer"
  , fileCommitResponseHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , fileCommitResponseMessage :: !(Maybe Text) -- ^ "message"
  , fileCommitResponseParents :: !(Maybe [CommitMeta]) -- ^ "parents"
  , fileCommitResponseSha :: !(Maybe Text) -- ^ "sha"
  , fileCommitResponseTree :: !(Maybe CommitMeta) -- ^ "tree"
  , fileCommitResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileCommitResponse
instance A.FromJSON FileCommitResponse where
  parseJSON = A.withObject "FileCommitResponse" $ \o ->
    FileCommitResponse
      <$> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "html_url")
      <*> (o .:? "message")
      <*> (o .:? "parents")
      <*> (o .:? "sha")
      <*> (o .:? "tree")
      <*> (o .:? "url")

-- | ToJSON FileCommitResponse
instance A.ToJSON FileCommitResponse where
  toJSON FileCommitResponse {..} =
   _omitNulls
      [ "author" .= fileCommitResponseAuthor
      , "committer" .= fileCommitResponseCommitter
      , "html_url" .= fileCommitResponseHtmlUrl
      , "message" .= fileCommitResponseMessage
      , "parents" .= fileCommitResponseParents
      , "sha" .= fileCommitResponseSha
      , "tree" .= fileCommitResponseTree
      , "url" .= fileCommitResponseUrl
      ]


-- | Construct a value of type 'FileCommitResponse' (by applying it's required fields, if any)
mkFileCommitResponse
  :: FileCommitResponse
mkFileCommitResponse =
  FileCommitResponse
  { fileCommitResponseAuthor = Nothing
  , fileCommitResponseCommitter = Nothing
  , fileCommitResponseHtmlUrl = Nothing
  , fileCommitResponseMessage = Nothing
  , fileCommitResponseParents = Nothing
  , fileCommitResponseSha = Nothing
  , fileCommitResponseTree = Nothing
  , fileCommitResponseUrl = Nothing
  }

-- ** FileDeleteResponse
-- | FileDeleteResponse
-- FileDeleteResponse contains information about a repo's file that was deleted
data FileDeleteResponse = FileDeleteResponse
  { fileDeleteResponseCommit :: !(Maybe FileCommitResponse) -- ^ "commit"
  , fileDeleteResponseContent :: !(Maybe A.Value) -- ^ "content"
  , fileDeleteResponseVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileDeleteResponse
instance A.FromJSON FileDeleteResponse where
  parseJSON = A.withObject "FileDeleteResponse" $ \o ->
    FileDeleteResponse
      <$> (o .:? "commit")
      <*> (o .:? "content")
      <*> (o .:? "verification")

-- | ToJSON FileDeleteResponse
instance A.ToJSON FileDeleteResponse where
  toJSON FileDeleteResponse {..} =
   _omitNulls
      [ "commit" .= fileDeleteResponseCommit
      , "content" .= fileDeleteResponseContent
      , "verification" .= fileDeleteResponseVerification
      ]


-- | Construct a value of type 'FileDeleteResponse' (by applying it's required fields, if any)
mkFileDeleteResponse
  :: FileDeleteResponse
mkFileDeleteResponse =
  FileDeleteResponse
  { fileDeleteResponseCommit = Nothing
  , fileDeleteResponseContent = Nothing
  , fileDeleteResponseVerification = Nothing
  }

-- ** FileLinksResponse
-- | FileLinksResponse
-- FileLinksResponse contains the links for a repo's file
data FileLinksResponse = FileLinksResponse
  { fileLinksResponseGit :: !(Maybe Text) -- ^ "git"
  , fileLinksResponseHtml :: !(Maybe Text) -- ^ "html"
  , fileLinksResponseSelf :: !(Maybe Text) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileLinksResponse
instance A.FromJSON FileLinksResponse where
  parseJSON = A.withObject "FileLinksResponse" $ \o ->
    FileLinksResponse
      <$> (o .:? "git")
      <*> (o .:? "html")
      <*> (o .:? "self")

-- | ToJSON FileLinksResponse
instance A.ToJSON FileLinksResponse where
  toJSON FileLinksResponse {..} =
   _omitNulls
      [ "git" .= fileLinksResponseGit
      , "html" .= fileLinksResponseHtml
      , "self" .= fileLinksResponseSelf
      ]


-- | Construct a value of type 'FileLinksResponse' (by applying it's required fields, if any)
mkFileLinksResponse
  :: FileLinksResponse
mkFileLinksResponse =
  FileLinksResponse
  { fileLinksResponseGit = Nothing
  , fileLinksResponseHtml = Nothing
  , fileLinksResponseSelf = Nothing
  }

-- ** FileResponse
-- | FileResponse
-- FileResponse contains information about a repo's file
data FileResponse = FileResponse
  { fileResponseCommit :: !(Maybe FileCommitResponse) -- ^ "commit"
  , fileResponseContent :: !(Maybe ContentsResponse) -- ^ "content"
  , fileResponseVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileResponse
instance A.FromJSON FileResponse where
  parseJSON = A.withObject "FileResponse" $ \o ->
    FileResponse
      <$> (o .:? "commit")
      <*> (o .:? "content")
      <*> (o .:? "verification")

-- | ToJSON FileResponse
instance A.ToJSON FileResponse where
  toJSON FileResponse {..} =
   _omitNulls
      [ "commit" .= fileResponseCommit
      , "content" .= fileResponseContent
      , "verification" .= fileResponseVerification
      ]


-- | Construct a value of type 'FileResponse' (by applying it's required fields, if any)
mkFileResponse
  :: FileResponse
mkFileResponse =
  FileResponse
  { fileResponseCommit = Nothing
  , fileResponseContent = Nothing
  , fileResponseVerification = Nothing
  }

-- ** GPGKey
-- | GPGKey
-- GPGKey a user GPG key to sign commit and tag in repository
data GPGKey = GPGKey
  { gPGKeyCanCertify :: !(Maybe Bool) -- ^ "can_certify"
  , gPGKeyCanEncryptComms :: !(Maybe Bool) -- ^ "can_encrypt_comms"
  , gPGKeyCanEncryptStorage :: !(Maybe Bool) -- ^ "can_encrypt_storage"
  , gPGKeyCanSign :: !(Maybe Bool) -- ^ "can_sign"
  , gPGKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , gPGKeyEmails :: !(Maybe [GPGKeyEmail]) -- ^ "emails"
  , gPGKeyExpiresAt :: !(Maybe DateTime) -- ^ "expires_at"
  , gPGKeyId :: !(Maybe Integer) -- ^ "id"
  , gPGKeyKeyId :: !(Maybe Text) -- ^ "key_id"
  , gPGKeyPrimaryKeyId :: !(Maybe Text) -- ^ "primary_key_id"
  , gPGKeyPublicKey :: !(Maybe Text) -- ^ "public_key"
  , gPGKeySubkeys :: !(Maybe [GPGKey]) -- ^ "subkeys"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GPGKey
instance A.FromJSON GPGKey where
  parseJSON = A.withObject "GPGKey" $ \o ->
    GPGKey
      <$> (o .:? "can_certify")
      <*> (o .:? "can_encrypt_comms")
      <*> (o .:? "can_encrypt_storage")
      <*> (o .:? "can_sign")
      <*> (o .:? "created_at")
      <*> (o .:? "emails")
      <*> (o .:? "expires_at")
      <*> (o .:? "id")
      <*> (o .:? "key_id")
      <*> (o .:? "primary_key_id")
      <*> (o .:? "public_key")
      <*> (o .:? "subkeys")

-- | ToJSON GPGKey
instance A.ToJSON GPGKey where
  toJSON GPGKey {..} =
   _omitNulls
      [ "can_certify" .= gPGKeyCanCertify
      , "can_encrypt_comms" .= gPGKeyCanEncryptComms
      , "can_encrypt_storage" .= gPGKeyCanEncryptStorage
      , "can_sign" .= gPGKeyCanSign
      , "created_at" .= gPGKeyCreatedAt
      , "emails" .= gPGKeyEmails
      , "expires_at" .= gPGKeyExpiresAt
      , "id" .= gPGKeyId
      , "key_id" .= gPGKeyKeyId
      , "primary_key_id" .= gPGKeyPrimaryKeyId
      , "public_key" .= gPGKeyPublicKey
      , "subkeys" .= gPGKeySubkeys
      ]


-- | Construct a value of type 'GPGKey' (by applying it's required fields, if any)
mkGPGKey
  :: GPGKey
mkGPGKey =
  GPGKey
  { gPGKeyCanCertify = Nothing
  , gPGKeyCanEncryptComms = Nothing
  , gPGKeyCanEncryptStorage = Nothing
  , gPGKeyCanSign = Nothing
  , gPGKeyCreatedAt = Nothing
  , gPGKeyEmails = Nothing
  , gPGKeyExpiresAt = Nothing
  , gPGKeyId = Nothing
  , gPGKeyKeyId = Nothing
  , gPGKeyPrimaryKeyId = Nothing
  , gPGKeyPublicKey = Nothing
  , gPGKeySubkeys = Nothing
  }

-- ** GPGKeyEmail
-- | GPGKeyEmail
-- GPGKeyEmail an email attached to a GPGKey
data GPGKeyEmail = GPGKeyEmail
  { gPGKeyEmailEmail :: !(Maybe Text) -- ^ "email"
  , gPGKeyEmailVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GPGKeyEmail
instance A.FromJSON GPGKeyEmail where
  parseJSON = A.withObject "GPGKeyEmail" $ \o ->
    GPGKeyEmail
      <$> (o .:? "email")
      <*> (o .:? "verified")

-- | ToJSON GPGKeyEmail
instance A.ToJSON GPGKeyEmail where
  toJSON GPGKeyEmail {..} =
   _omitNulls
      [ "email" .= gPGKeyEmailEmail
      , "verified" .= gPGKeyEmailVerified
      ]


-- | Construct a value of type 'GPGKeyEmail' (by applying it's required fields, if any)
mkGPGKeyEmail
  :: GPGKeyEmail
mkGPGKeyEmail =
  GPGKeyEmail
  { gPGKeyEmailEmail = Nothing
  , gPGKeyEmailVerified = Nothing
  }

-- ** GitBlobResponse
-- | GitBlobResponse
-- GitBlobResponse represents a git blob
data GitBlobResponse = GitBlobResponse
  { gitBlobResponseContent :: !(Maybe Text) -- ^ "content"
  , gitBlobResponseEncoding :: !(Maybe Text) -- ^ "encoding"
  , gitBlobResponseSha :: !(Maybe Text) -- ^ "sha"
  , gitBlobResponseSize :: !(Maybe Integer) -- ^ "size"
  , gitBlobResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitBlobResponse
instance A.FromJSON GitBlobResponse where
  parseJSON = A.withObject "GitBlobResponse" $ \o ->
    GitBlobResponse
      <$> (o .:? "content")
      <*> (o .:? "encoding")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "url")

-- | ToJSON GitBlobResponse
instance A.ToJSON GitBlobResponse where
  toJSON GitBlobResponse {..} =
   _omitNulls
      [ "content" .= gitBlobResponseContent
      , "encoding" .= gitBlobResponseEncoding
      , "sha" .= gitBlobResponseSha
      , "size" .= gitBlobResponseSize
      , "url" .= gitBlobResponseUrl
      ]


-- | Construct a value of type 'GitBlobResponse' (by applying it's required fields, if any)
mkGitBlobResponse
  :: GitBlobResponse
mkGitBlobResponse =
  GitBlobResponse
  { gitBlobResponseContent = Nothing
  , gitBlobResponseEncoding = Nothing
  , gitBlobResponseSha = Nothing
  , gitBlobResponseSize = Nothing
  , gitBlobResponseUrl = Nothing
  }

-- ** GitEntry
-- | GitEntry
-- GitEntry represents a git tree
data GitEntry = GitEntry
  { gitEntryMode :: !(Maybe Text) -- ^ "mode"
  , gitEntryPath :: !(Maybe Text) -- ^ "path"
  , gitEntrySha :: !(Maybe Text) -- ^ "sha"
  , gitEntrySize :: !(Maybe Integer) -- ^ "size"
  , gitEntryType :: !(Maybe Text) -- ^ "type"
  , gitEntryUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitEntry
instance A.FromJSON GitEntry where
  parseJSON = A.withObject "GitEntry" $ \o ->
    GitEntry
      <$> (o .:? "mode")
      <*> (o .:? "path")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON GitEntry
instance A.ToJSON GitEntry where
  toJSON GitEntry {..} =
   _omitNulls
      [ "mode" .= gitEntryMode
      , "path" .= gitEntryPath
      , "sha" .= gitEntrySha
      , "size" .= gitEntrySize
      , "type" .= gitEntryType
      , "url" .= gitEntryUrl
      ]


-- | Construct a value of type 'GitEntry' (by applying it's required fields, if any)
mkGitEntry
  :: GitEntry
mkGitEntry =
  GitEntry
  { gitEntryMode = Nothing
  , gitEntryPath = Nothing
  , gitEntrySha = Nothing
  , gitEntrySize = Nothing
  , gitEntryType = Nothing
  , gitEntryUrl = Nothing
  }

-- ** GitHook
-- | GitHook
-- GitHook represents a Git repository hook
data GitHook = GitHook
  { gitHookContent :: !(Maybe Text) -- ^ "content"
  , gitHookIsActive :: !(Maybe Bool) -- ^ "is_active"
  , gitHookName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitHook
instance A.FromJSON GitHook where
  parseJSON = A.withObject "GitHook" $ \o ->
    GitHook
      <$> (o .:? "content")
      <*> (o .:? "is_active")
      <*> (o .:? "name")

-- | ToJSON GitHook
instance A.ToJSON GitHook where
  toJSON GitHook {..} =
   _omitNulls
      [ "content" .= gitHookContent
      , "is_active" .= gitHookIsActive
      , "name" .= gitHookName
      ]


-- | Construct a value of type 'GitHook' (by applying it's required fields, if any)
mkGitHook
  :: GitHook
mkGitHook =
  GitHook
  { gitHookContent = Nothing
  , gitHookIsActive = Nothing
  , gitHookName = Nothing
  }

-- ** GitObject
-- | GitObject
-- GitObject represents a Git object.
-- 
data GitObject = GitObject
  { gitObjectSha :: !(Maybe Text) -- ^ "sha"
  , gitObjectType :: !(Maybe Text) -- ^ "type"
  , gitObjectUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitObject
instance A.FromJSON GitObject where
  parseJSON = A.withObject "GitObject" $ \o ->
    GitObject
      <$> (o .:? "sha")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON GitObject
instance A.ToJSON GitObject where
  toJSON GitObject {..} =
   _omitNulls
      [ "sha" .= gitObjectSha
      , "type" .= gitObjectType
      , "url" .= gitObjectUrl
      ]


-- | Construct a value of type 'GitObject' (by applying it's required fields, if any)
mkGitObject
  :: GitObject
mkGitObject =
  GitObject
  { gitObjectSha = Nothing
  , gitObjectType = Nothing
  , gitObjectUrl = Nothing
  }

-- ** GitTreeResponse
-- | GitTreeResponse
-- GitTreeResponse returns a git tree
data GitTreeResponse = GitTreeResponse
  { gitTreeResponsePage :: !(Maybe Integer) -- ^ "page"
  , gitTreeResponseSha :: !(Maybe Text) -- ^ "sha"
  , gitTreeResponseTotalCount :: !(Maybe Integer) -- ^ "total_count"
  , gitTreeResponseTree :: !(Maybe [GitEntry]) -- ^ "tree"
  , gitTreeResponseTruncated :: !(Maybe Bool) -- ^ "truncated"
  , gitTreeResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitTreeResponse
instance A.FromJSON GitTreeResponse where
  parseJSON = A.withObject "GitTreeResponse" $ \o ->
    GitTreeResponse
      <$> (o .:? "page")
      <*> (o .:? "sha")
      <*> (o .:? "total_count")
      <*> (o .:? "tree")
      <*> (o .:? "truncated")
      <*> (o .:? "url")

-- | ToJSON GitTreeResponse
instance A.ToJSON GitTreeResponse where
  toJSON GitTreeResponse {..} =
   _omitNulls
      [ "page" .= gitTreeResponsePage
      , "sha" .= gitTreeResponseSha
      , "total_count" .= gitTreeResponseTotalCount
      , "tree" .= gitTreeResponseTree
      , "truncated" .= gitTreeResponseTruncated
      , "url" .= gitTreeResponseUrl
      ]


-- | Construct a value of type 'GitTreeResponse' (by applying it's required fields, if any)
mkGitTreeResponse
  :: GitTreeResponse
mkGitTreeResponse =
  GitTreeResponse
  { gitTreeResponsePage = Nothing
  , gitTreeResponseSha = Nothing
  , gitTreeResponseTotalCount = Nothing
  , gitTreeResponseTree = Nothing
  , gitTreeResponseTruncated = Nothing
  , gitTreeResponseUrl = Nothing
  }

-- ** Hook
-- | Hook
-- Hook a hook is a web hook when one repository changed
data Hook = Hook
  { hookActive :: !(Maybe Bool) -- ^ "active"
  , hookConfig :: !(Maybe (Map.Map String Text)) -- ^ "config"
  , hookCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , hookEvents :: !(Maybe [Text]) -- ^ "events"
  , hookId :: !(Maybe Integer) -- ^ "id"
  , hookType :: !(Maybe Text) -- ^ "type"
  , hookUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Hook
instance A.FromJSON Hook where
  parseJSON = A.withObject "Hook" $ \o ->
    Hook
      <$> (o .:? "active")
      <*> (o .:? "config")
      <*> (o .:? "created_at")
      <*> (o .:? "events")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "updated_at")

-- | ToJSON Hook
instance A.ToJSON Hook where
  toJSON Hook {..} =
   _omitNulls
      [ "active" .= hookActive
      , "config" .= hookConfig
      , "created_at" .= hookCreatedAt
      , "events" .= hookEvents
      , "id" .= hookId
      , "type" .= hookType
      , "updated_at" .= hookUpdatedAt
      ]


-- | Construct a value of type 'Hook' (by applying it's required fields, if any)
mkHook
  :: Hook
mkHook =
  Hook
  { hookActive = Nothing
  , hookConfig = Nothing
  , hookCreatedAt = Nothing
  , hookEvents = Nothing
  , hookId = Nothing
  , hookType = Nothing
  , hookUpdatedAt = Nothing
  }

-- ** Identity
-- | Identity
-- Identity for a person's identity like an author or committer
data Identity = Identity
  { identityEmail :: !(Maybe Text) -- ^ "email"
  , identityName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Identity
instance A.FromJSON Identity where
  parseJSON = A.withObject "Identity" $ \o ->
    Identity
      <$> (o .:? "email")
      <*> (o .:? "name")

-- | ToJSON Identity
instance A.ToJSON Identity where
  toJSON Identity {..} =
   _omitNulls
      [ "email" .= identityEmail
      , "name" .= identityName
      ]


-- | Construct a value of type 'Identity' (by applying it's required fields, if any)
mkIdentity
  :: Identity
mkIdentity =
  Identity
  { identityEmail = Nothing
  , identityName = Nothing
  }

-- ** InlineObject
-- | InlineObject
data InlineObject = InlineObject
  { inlineObjectName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineObject
instance A.FromJSON InlineObject where
  parseJSON = A.withObject "InlineObject" $ \o ->
    InlineObject
      <$> (o .:  "name")

-- | ToJSON InlineObject
instance A.ToJSON InlineObject where
  toJSON InlineObject {..} =
   _omitNulls
      [ "name" .= inlineObjectName
      ]


-- | Construct a value of type 'InlineObject' (by applying it's required fields, if any)
mkInlineObject
  :: Text -- ^ 'inlineObjectName' 
  -> InlineObject
mkInlineObject inlineObjectName =
  InlineObject
  { inlineObjectName
  }

-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Data :: !(Maybe [User]) -- ^ "data"
  , inlineResponse200Ok :: !(Maybe Bool) -- ^ "ok"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "data")
      <*> (o .:? "ok")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "data" .= inlineResponse200Data
      , "ok" .= inlineResponse200Ok
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200Data = Nothing
  , inlineResponse200Ok = Nothing
  }

-- ** Issue
-- | Issue
-- Issue represents an issue in a repository
data Issue = Issue
  { issueAssignee :: !(Maybe User) -- ^ "assignee"
  , issueAssignees :: !(Maybe [User]) -- ^ "assignees"
  , issueBody :: !(Maybe Text) -- ^ "body"
  , issueClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , issueComments :: !(Maybe Integer) -- ^ "comments"
  , issueCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , issueDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , issueId :: !(Maybe Integer) -- ^ "id"
  , issueLabels :: !(Maybe [Label]) -- ^ "labels"
  , issueMilestone :: !(Maybe Milestone) -- ^ "milestone"
  , issueNumber :: !(Maybe Integer) -- ^ "number"
  , issuePullRequest :: !(Maybe PullRequestMeta) -- ^ "pull_request"
  , issueState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , issueTitle :: !(Maybe Text) -- ^ "title"
  , issueUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , issueUrl :: !(Maybe Text) -- ^ "url"
  , issueUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Issue
instance A.FromJSON Issue where
  parseJSON = A.withObject "Issue" $ \o ->
    Issue
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "closed_at")
      <*> (o .:? "comments")
      <*> (o .:? "created_at")
      <*> (o .:? "due_date")
      <*> (o .:? "id")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "number")
      <*> (o .:? "pull_request")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON Issue
instance A.ToJSON Issue where
  toJSON Issue {..} =
   _omitNulls
      [ "assignee" .= issueAssignee
      , "assignees" .= issueAssignees
      , "body" .= issueBody
      , "closed_at" .= issueClosedAt
      , "comments" .= issueComments
      , "created_at" .= issueCreatedAt
      , "due_date" .= issueDueDate
      , "id" .= issueId
      , "labels" .= issueLabels
      , "milestone" .= issueMilestone
      , "number" .= issueNumber
      , "pull_request" .= issuePullRequest
      , "state" .= issueState
      , "title" .= issueTitle
      , "updated_at" .= issueUpdatedAt
      , "url" .= issueUrl
      , "user" .= issueUser
      ]


-- | Construct a value of type 'Issue' (by applying it's required fields, if any)
mkIssue
  :: Issue
mkIssue =
  Issue
  { issueAssignee = Nothing
  , issueAssignees = Nothing
  , issueBody = Nothing
  , issueClosedAt = Nothing
  , issueComments = Nothing
  , issueCreatedAt = Nothing
  , issueDueDate = Nothing
  , issueId = Nothing
  , issueLabels = Nothing
  , issueMilestone = Nothing
  , issueNumber = Nothing
  , issuePullRequest = Nothing
  , issueState = Nothing
  , issueTitle = Nothing
  , issueUpdatedAt = Nothing
  , issueUrl = Nothing
  , issueUser = Nothing
  }

-- ** IssueDeadline
-- | IssueDeadline
-- IssueDeadline represents an issue deadline
data IssueDeadline = IssueDeadline
  { issueDeadlineDueDate :: !(Maybe DateTime) -- ^ "due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueDeadline
instance A.FromJSON IssueDeadline where
  parseJSON = A.withObject "IssueDeadline" $ \o ->
    IssueDeadline
      <$> (o .:? "due_date")

-- | ToJSON IssueDeadline
instance A.ToJSON IssueDeadline where
  toJSON IssueDeadline {..} =
   _omitNulls
      [ "due_date" .= issueDeadlineDueDate
      ]


-- | Construct a value of type 'IssueDeadline' (by applying it's required fields, if any)
mkIssueDeadline
  :: IssueDeadline
mkIssueDeadline =
  IssueDeadline
  { issueDeadlineDueDate = Nothing
  }

-- ** IssueLabelsOption
-- | IssueLabelsOption
-- IssueLabelsOption a collection of labels
data IssueLabelsOption = IssueLabelsOption
  { issueLabelsOptionLabels :: !(Maybe [Integer]) -- ^ "labels" - list of label IDs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueLabelsOption
instance A.FromJSON IssueLabelsOption where
  parseJSON = A.withObject "IssueLabelsOption" $ \o ->
    IssueLabelsOption
      <$> (o .:? "labels")

-- | ToJSON IssueLabelsOption
instance A.ToJSON IssueLabelsOption where
  toJSON IssueLabelsOption {..} =
   _omitNulls
      [ "labels" .= issueLabelsOptionLabels
      ]


-- | Construct a value of type 'IssueLabelsOption' (by applying it's required fields, if any)
mkIssueLabelsOption
  :: IssueLabelsOption
mkIssueLabelsOption =
  IssueLabelsOption
  { issueLabelsOptionLabels = Nothing
  }

-- ** Label
-- | Label
-- Label a label to an issue or a pr
data Label = Label
  { labelColor :: !(Maybe Text) -- ^ "color"
  , labelDescription :: !(Maybe Text) -- ^ "description"
  , labelId :: !(Maybe Integer) -- ^ "id"
  , labelName :: !(Maybe Text) -- ^ "name"
  , labelUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Label
instance A.FromJSON Label where
  parseJSON = A.withObject "Label" $ \o ->
    Label
      <$> (o .:? "color")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON Label
instance A.ToJSON Label where
  toJSON Label {..} =
   _omitNulls
      [ "color" .= labelColor
      , "description" .= labelDescription
      , "id" .= labelId
      , "name" .= labelName
      , "url" .= labelUrl
      ]


-- | Construct a value of type 'Label' (by applying it's required fields, if any)
mkLabel
  :: Label
mkLabel =
  Label
  { labelColor = Nothing
  , labelDescription = Nothing
  , labelId = Nothing
  , labelName = Nothing
  , labelUrl = Nothing
  }

-- ** MarkdownOption
-- | MarkdownOption
-- MarkdownOption markdown options
data MarkdownOption = MarkdownOption
  { markdownOptionContext :: !(Maybe Text) -- ^ "Context" - Context to render  in: body
  , markdownOptionMode :: !(Maybe Text) -- ^ "Mode" - Mode to render  in: body
  , markdownOptionText :: !(Maybe Text) -- ^ "Text" - Text markdown to render  in: body
  , markdownOptionWiki :: !(Maybe Bool) -- ^ "Wiki" - Is it a wiki page ?  in: body
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MarkdownOption
instance A.FromJSON MarkdownOption where
  parseJSON = A.withObject "MarkdownOption" $ \o ->
    MarkdownOption
      <$> (o .:? "Context")
      <*> (o .:? "Mode")
      <*> (o .:? "Text")
      <*> (o .:? "Wiki")

-- | ToJSON MarkdownOption
instance A.ToJSON MarkdownOption where
  toJSON MarkdownOption {..} =
   _omitNulls
      [ "Context" .= markdownOptionContext
      , "Mode" .= markdownOptionMode
      , "Text" .= markdownOptionText
      , "Wiki" .= markdownOptionWiki
      ]


-- | Construct a value of type 'MarkdownOption' (by applying it's required fields, if any)
mkMarkdownOption
  :: MarkdownOption
mkMarkdownOption =
  MarkdownOption
  { markdownOptionContext = Nothing
  , markdownOptionMode = Nothing
  , markdownOptionText = Nothing
  , markdownOptionWiki = Nothing
  }

-- ** MergePullRequestOption
-- | MergePullRequestOption
-- MergePullRequestForm form for merging Pull Request
data MergePullRequestOption = MergePullRequestOption
  { mergePullRequestOptionDo :: !(E'Do) -- ^ /Required/ "Do"
  , mergePullRequestOptionMergeMessageField :: !(Maybe Text) -- ^ "MergeMessageField"
  , mergePullRequestOptionMergeTitleField :: !(Maybe Text) -- ^ "MergeTitleField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MergePullRequestOption
instance A.FromJSON MergePullRequestOption where
  parseJSON = A.withObject "MergePullRequestOption" $ \o ->
    MergePullRequestOption
      <$> (o .:  "Do")
      <*> (o .:? "MergeMessageField")
      <*> (o .:? "MergeTitleField")

-- | ToJSON MergePullRequestOption
instance A.ToJSON MergePullRequestOption where
  toJSON MergePullRequestOption {..} =
   _omitNulls
      [ "Do" .= mergePullRequestOptionDo
      , "MergeMessageField" .= mergePullRequestOptionMergeMessageField
      , "MergeTitleField" .= mergePullRequestOptionMergeTitleField
      ]


-- | Construct a value of type 'MergePullRequestOption' (by applying it's required fields, if any)
mkMergePullRequestOption
  :: E'Do -- ^ 'mergePullRequestOptionDo' 
  -> MergePullRequestOption
mkMergePullRequestOption mergePullRequestOptionDo =
  MergePullRequestOption
  { mergePullRequestOptionDo
  , mergePullRequestOptionMergeMessageField = Nothing
  , mergePullRequestOptionMergeTitleField = Nothing
  }

-- ** MigrateRepoForm
-- | MigrateRepoForm
-- MigrateRepoForm form for migrating repository
data MigrateRepoForm = MigrateRepoForm
  { migrateRepoFormAuthPassword :: !(Maybe Text) -- ^ "auth_password"
  , migrateRepoFormAuthUsername :: !(Maybe Text) -- ^ "auth_username"
  , migrateRepoFormCloneAddr :: !(Text) -- ^ /Required/ "clone_addr"
  , migrateRepoFormDescription :: !(Maybe Text) -- ^ "description"
  , migrateRepoFormIssues :: !(Maybe Bool) -- ^ "issues"
  , migrateRepoFormLabels :: !(Maybe Bool) -- ^ "labels"
  , migrateRepoFormMilestones :: !(Maybe Bool) -- ^ "milestones"
  , migrateRepoFormMirror :: !(Maybe Bool) -- ^ "mirror"
  , migrateRepoFormPrivate :: !(Maybe Bool) -- ^ "private"
  , migrateRepoFormPullRequests :: !(Maybe Bool) -- ^ "pull_requests"
  , migrateRepoFormReleases :: !(Maybe Bool) -- ^ "releases"
  , migrateRepoFormRepoName :: !(Text) -- ^ /Required/ "repo_name"
  , migrateRepoFormUid :: !(Integer) -- ^ /Required/ "uid"
  , migrateRepoFormWiki :: !(Maybe Bool) -- ^ "wiki"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MigrateRepoForm
instance A.FromJSON MigrateRepoForm where
  parseJSON = A.withObject "MigrateRepoForm" $ \o ->
    MigrateRepoForm
      <$> (o .:? "auth_password")
      <*> (o .:? "auth_username")
      <*> (o .:  "clone_addr")
      <*> (o .:? "description")
      <*> (o .:? "issues")
      <*> (o .:? "labels")
      <*> (o .:? "milestones")
      <*> (o .:? "mirror")
      <*> (o .:? "private")
      <*> (o .:? "pull_requests")
      <*> (o .:? "releases")
      <*> (o .:  "repo_name")
      <*> (o .:  "uid")
      <*> (o .:? "wiki")

-- | ToJSON MigrateRepoForm
instance A.ToJSON MigrateRepoForm where
  toJSON MigrateRepoForm {..} =
   _omitNulls
      [ "auth_password" .= migrateRepoFormAuthPassword
      , "auth_username" .= migrateRepoFormAuthUsername
      , "clone_addr" .= migrateRepoFormCloneAddr
      , "description" .= migrateRepoFormDescription
      , "issues" .= migrateRepoFormIssues
      , "labels" .= migrateRepoFormLabels
      , "milestones" .= migrateRepoFormMilestones
      , "mirror" .= migrateRepoFormMirror
      , "private" .= migrateRepoFormPrivate
      , "pull_requests" .= migrateRepoFormPullRequests
      , "releases" .= migrateRepoFormReleases
      , "repo_name" .= migrateRepoFormRepoName
      , "uid" .= migrateRepoFormUid
      , "wiki" .= migrateRepoFormWiki
      ]


-- | Construct a value of type 'MigrateRepoForm' (by applying it's required fields, if any)
mkMigrateRepoForm
  :: Text -- ^ 'migrateRepoFormCloneAddr' 
  -> Text -- ^ 'migrateRepoFormRepoName' 
  -> Integer -- ^ 'migrateRepoFormUid' 
  -> MigrateRepoForm
mkMigrateRepoForm migrateRepoFormCloneAddr migrateRepoFormRepoName migrateRepoFormUid =
  MigrateRepoForm
  { migrateRepoFormAuthPassword = Nothing
  , migrateRepoFormAuthUsername = Nothing
  , migrateRepoFormCloneAddr
  , migrateRepoFormDescription = Nothing
  , migrateRepoFormIssues = Nothing
  , migrateRepoFormLabels = Nothing
  , migrateRepoFormMilestones = Nothing
  , migrateRepoFormMirror = Nothing
  , migrateRepoFormPrivate = Nothing
  , migrateRepoFormPullRequests = Nothing
  , migrateRepoFormReleases = Nothing
  , migrateRepoFormRepoName
  , migrateRepoFormUid
  , migrateRepoFormWiki = Nothing
  }

-- ** Milestone
-- | Milestone
-- Milestone milestone is a collection of issues on one repository
data Milestone = Milestone
  { milestoneClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , milestoneClosedIssues :: !(Maybe Integer) -- ^ "closed_issues"
  , milestoneDescription :: !(Maybe Text) -- ^ "description"
  , milestoneDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , milestoneId :: !(Maybe Integer) -- ^ "id"
  , milestoneOpenIssues :: !(Maybe Integer) -- ^ "open_issues"
  , milestoneState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , milestoneTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Milestone
instance A.FromJSON Milestone where
  parseJSON = A.withObject "Milestone" $ \o ->
    Milestone
      <$> (o .:? "closed_at")
      <*> (o .:? "closed_issues")
      <*> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "id")
      <*> (o .:? "open_issues")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON Milestone
instance A.ToJSON Milestone where
  toJSON Milestone {..} =
   _omitNulls
      [ "closed_at" .= milestoneClosedAt
      , "closed_issues" .= milestoneClosedIssues
      , "description" .= milestoneDescription
      , "due_on" .= milestoneDueOn
      , "id" .= milestoneId
      , "open_issues" .= milestoneOpenIssues
      , "state" .= milestoneState
      , "title" .= milestoneTitle
      ]


-- | Construct a value of type 'Milestone' (by applying it's required fields, if any)
mkMilestone
  :: Milestone
mkMilestone =
  Milestone
  { milestoneClosedAt = Nothing
  , milestoneClosedIssues = Nothing
  , milestoneDescription = Nothing
  , milestoneDueOn = Nothing
  , milestoneId = Nothing
  , milestoneOpenIssues = Nothing
  , milestoneState = Nothing
  , milestoneTitle = Nothing
  }

-- ** Organization
-- | Organization
-- Organization represents an organization
data Organization = Organization
  { organizationAvatarUrl :: !(Maybe Text) -- ^ "avatar_url"
  , organizationDescription :: !(Maybe Text) -- ^ "description"
  , organizationFullName :: !(Maybe Text) -- ^ "full_name"
  , organizationId :: !(Maybe Integer) -- ^ "id"
  , organizationLocation :: !(Maybe Text) -- ^ "location"
  , organizationUsername :: !(Maybe Text) -- ^ "username"
  , organizationVisibility :: !(Maybe Text) -- ^ "visibility"
  , organizationWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Organization
instance A.FromJSON Organization where
  parseJSON = A.withObject "Organization" $ \o ->
    Organization
      <$> (o .:? "avatar_url")
      <*> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "id")
      <*> (o .:? "location")
      <*> (o .:? "username")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON Organization
instance A.ToJSON Organization where
  toJSON Organization {..} =
   _omitNulls
      [ "avatar_url" .= organizationAvatarUrl
      , "description" .= organizationDescription
      , "full_name" .= organizationFullName
      , "id" .= organizationId
      , "location" .= organizationLocation
      , "username" .= organizationUsername
      , "visibility" .= organizationVisibility
      , "website" .= organizationWebsite
      ]


-- | Construct a value of type 'Organization' (by applying it's required fields, if any)
mkOrganization
  :: Organization
mkOrganization =
  Organization
  { organizationAvatarUrl = Nothing
  , organizationDescription = Nothing
  , organizationFullName = Nothing
  , organizationId = Nothing
  , organizationLocation = Nothing
  , organizationUsername = Nothing
  , organizationVisibility = Nothing
  , organizationWebsite = Nothing
  }

-- ** PRBranchInfo
-- | PRBranchInfo
-- PRBranchInfo information about a branch
data PRBranchInfo = PRBranchInfo
  { pRBranchInfoLabel :: !(Maybe Text) -- ^ "label"
  , pRBranchInfoRef :: !(Maybe Text) -- ^ "ref"
  , pRBranchInfoRepo :: !(Maybe Repository) -- ^ "repo"
  , pRBranchInfoRepoId :: !(Maybe Integer) -- ^ "repo_id"
  , pRBranchInfoSha :: !(Maybe Text) -- ^ "sha"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PRBranchInfo
instance A.FromJSON PRBranchInfo where
  parseJSON = A.withObject "PRBranchInfo" $ \o ->
    PRBranchInfo
      <$> (o .:? "label")
      <*> (o .:? "ref")
      <*> (o .:? "repo")
      <*> (o .:? "repo_id")
      <*> (o .:? "sha")

-- | ToJSON PRBranchInfo
instance A.ToJSON PRBranchInfo where
  toJSON PRBranchInfo {..} =
   _omitNulls
      [ "label" .= pRBranchInfoLabel
      , "ref" .= pRBranchInfoRef
      , "repo" .= pRBranchInfoRepo
      , "repo_id" .= pRBranchInfoRepoId
      , "sha" .= pRBranchInfoSha
      ]


-- | Construct a value of type 'PRBranchInfo' (by applying it's required fields, if any)
mkPRBranchInfo
  :: PRBranchInfo
mkPRBranchInfo =
  PRBranchInfo
  { pRBranchInfoLabel = Nothing
  , pRBranchInfoRef = Nothing
  , pRBranchInfoRepo = Nothing
  , pRBranchInfoRepoId = Nothing
  , pRBranchInfoSha = Nothing
  }

-- ** PayloadCommit
-- | PayloadCommit
-- PayloadCommit represents a commit
data PayloadCommit = PayloadCommit
  { payloadCommitAdded :: !(Maybe [Text]) -- ^ "added"
  , payloadCommitAuthor :: !(Maybe PayloadUser) -- ^ "author"
  , payloadCommitCommitter :: !(Maybe PayloadUser) -- ^ "committer"
  , payloadCommitId :: !(Maybe Text) -- ^ "id" - sha1 hash of the commit
  , payloadCommitMessage :: !(Maybe Text) -- ^ "message"
  , payloadCommitModified :: !(Maybe [Text]) -- ^ "modified"
  , payloadCommitRemoved :: !(Maybe [Text]) -- ^ "removed"
  , payloadCommitTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , payloadCommitUrl :: !(Maybe Text) -- ^ "url"
  , payloadCommitVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadCommit
instance A.FromJSON PayloadCommit where
  parseJSON = A.withObject "PayloadCommit" $ \o ->
    PayloadCommit
      <$> (o .:? "added")
      <*> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "id")
      <*> (o .:? "message")
      <*> (o .:? "modified")
      <*> (o .:? "removed")
      <*> (o .:? "timestamp")
      <*> (o .:? "url")
      <*> (o .:? "verification")

-- | ToJSON PayloadCommit
instance A.ToJSON PayloadCommit where
  toJSON PayloadCommit {..} =
   _omitNulls
      [ "added" .= payloadCommitAdded
      , "author" .= payloadCommitAuthor
      , "committer" .= payloadCommitCommitter
      , "id" .= payloadCommitId
      , "message" .= payloadCommitMessage
      , "modified" .= payloadCommitModified
      , "removed" .= payloadCommitRemoved
      , "timestamp" .= payloadCommitTimestamp
      , "url" .= payloadCommitUrl
      , "verification" .= payloadCommitVerification
      ]


-- | Construct a value of type 'PayloadCommit' (by applying it's required fields, if any)
mkPayloadCommit
  :: PayloadCommit
mkPayloadCommit =
  PayloadCommit
  { payloadCommitAdded = Nothing
  , payloadCommitAuthor = Nothing
  , payloadCommitCommitter = Nothing
  , payloadCommitId = Nothing
  , payloadCommitMessage = Nothing
  , payloadCommitModified = Nothing
  , payloadCommitRemoved = Nothing
  , payloadCommitTimestamp = Nothing
  , payloadCommitUrl = Nothing
  , payloadCommitVerification = Nothing
  }

-- ** PayloadCommitVerification
-- | PayloadCommitVerification
-- PayloadCommitVerification represents the GPG verification of a commit
data PayloadCommitVerification = PayloadCommitVerification
  { payloadCommitVerificationPayload :: !(Maybe Text) -- ^ "payload"
  , payloadCommitVerificationReason :: !(Maybe Text) -- ^ "reason"
  , payloadCommitVerificationSignature :: !(Maybe Text) -- ^ "signature"
  , payloadCommitVerificationVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadCommitVerification
instance A.FromJSON PayloadCommitVerification where
  parseJSON = A.withObject "PayloadCommitVerification" $ \o ->
    PayloadCommitVerification
      <$> (o .:? "payload")
      <*> (o .:? "reason")
      <*> (o .:? "signature")
      <*> (o .:? "verified")

-- | ToJSON PayloadCommitVerification
instance A.ToJSON PayloadCommitVerification where
  toJSON PayloadCommitVerification {..} =
   _omitNulls
      [ "payload" .= payloadCommitVerificationPayload
      , "reason" .= payloadCommitVerificationReason
      , "signature" .= payloadCommitVerificationSignature
      , "verified" .= payloadCommitVerificationVerified
      ]


-- | Construct a value of type 'PayloadCommitVerification' (by applying it's required fields, if any)
mkPayloadCommitVerification
  :: PayloadCommitVerification
mkPayloadCommitVerification =
  PayloadCommitVerification
  { payloadCommitVerificationPayload = Nothing
  , payloadCommitVerificationReason = Nothing
  , payloadCommitVerificationSignature = Nothing
  , payloadCommitVerificationVerified = Nothing
  }

-- ** PayloadUser
-- | PayloadUser
-- PayloadUser represents the author or committer of a commit
data PayloadUser = PayloadUser
  { payloadUserEmail :: !(Maybe Text) -- ^ "email"
  , payloadUserName :: !(Maybe Text) -- ^ "name" - Full name of the commit author
  , payloadUserUsername :: !(Maybe Text) -- ^ "username"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadUser
instance A.FromJSON PayloadUser where
  parseJSON = A.withObject "PayloadUser" $ \o ->
    PayloadUser
      <$> (o .:? "email")
      <*> (o .:? "name")
      <*> (o .:? "username")

-- | ToJSON PayloadUser
instance A.ToJSON PayloadUser where
  toJSON PayloadUser {..} =
   _omitNulls
      [ "email" .= payloadUserEmail
      , "name" .= payloadUserName
      , "username" .= payloadUserUsername
      ]


-- | Construct a value of type 'PayloadUser' (by applying it's required fields, if any)
mkPayloadUser
  :: PayloadUser
mkPayloadUser =
  PayloadUser
  { payloadUserEmail = Nothing
  , payloadUserName = Nothing
  , payloadUserUsername = Nothing
  }

-- ** Permission
-- | Permission
-- Permission represents a set of permissions
data Permission = Permission
  { permissionAdmin :: !(Maybe Bool) -- ^ "admin"
  , permissionPull :: !(Maybe Bool) -- ^ "pull"
  , permissionPush :: !(Maybe Bool) -- ^ "push"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Permission
instance A.FromJSON Permission where
  parseJSON = A.withObject "Permission" $ \o ->
    Permission
      <$> (o .:? "admin")
      <*> (o .:? "pull")
      <*> (o .:? "push")

-- | ToJSON Permission
instance A.ToJSON Permission where
  toJSON Permission {..} =
   _omitNulls
      [ "admin" .= permissionAdmin
      , "pull" .= permissionPull
      , "push" .= permissionPush
      ]


-- | Construct a value of type 'Permission' (by applying it's required fields, if any)
mkPermission
  :: Permission
mkPermission =
  Permission
  { permissionAdmin = Nothing
  , permissionPull = Nothing
  , permissionPush = Nothing
  }

-- ** PublicKey
-- | PublicKey
-- PublicKey publickey is a user key to push code to repository
data PublicKey = PublicKey
  { publicKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , publicKeyFingerprint :: !(Maybe Text) -- ^ "fingerprint"
  , publicKeyId :: !(Maybe Integer) -- ^ "id"
  , publicKeyKey :: !(Maybe Text) -- ^ "key"
  , publicKeyKeyType :: !(Maybe Text) -- ^ "key_type"
  , publicKeyReadOnly :: !(Maybe Bool) -- ^ "read_only"
  , publicKeyTitle :: !(Maybe Text) -- ^ "title"
  , publicKeyUrl :: !(Maybe Text) -- ^ "url"
  , publicKeyUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PublicKey
instance A.FromJSON PublicKey where
  parseJSON = A.withObject "PublicKey" $ \o ->
    PublicKey
      <$> (o .:? "created_at")
      <*> (o .:? "fingerprint")
      <*> (o .:? "id")
      <*> (o .:? "key")
      <*> (o .:? "key_type")
      <*> (o .:? "read_only")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON PublicKey
instance A.ToJSON PublicKey where
  toJSON PublicKey {..} =
   _omitNulls
      [ "created_at" .= publicKeyCreatedAt
      , "fingerprint" .= publicKeyFingerprint
      , "id" .= publicKeyId
      , "key" .= publicKeyKey
      , "key_type" .= publicKeyKeyType
      , "read_only" .= publicKeyReadOnly
      , "title" .= publicKeyTitle
      , "url" .= publicKeyUrl
      , "user" .= publicKeyUser
      ]


-- | Construct a value of type 'PublicKey' (by applying it's required fields, if any)
mkPublicKey
  :: PublicKey
mkPublicKey =
  PublicKey
  { publicKeyCreatedAt = Nothing
  , publicKeyFingerprint = Nothing
  , publicKeyId = Nothing
  , publicKeyKey = Nothing
  , publicKeyKeyType = Nothing
  , publicKeyReadOnly = Nothing
  , publicKeyTitle = Nothing
  , publicKeyUrl = Nothing
  , publicKeyUser = Nothing
  }

-- ** PullRequest
-- | PullRequest
-- PullRequest represents a pull request
data PullRequest = PullRequest
  { pullRequestAssignee :: !(Maybe User) -- ^ "assignee"
  , pullRequestAssignees :: !(Maybe [User]) -- ^ "assignees"
  , pullRequestBase :: !(Maybe PRBranchInfo) -- ^ "base"
  , pullRequestBody :: !(Maybe Text) -- ^ "body"
  , pullRequestClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , pullRequestComments :: !(Maybe Integer) -- ^ "comments"
  , pullRequestCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , pullRequestDiffUrl :: !(Maybe Text) -- ^ "diff_url"
  , pullRequestDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , pullRequestHead :: !(Maybe PRBranchInfo) -- ^ "head"
  , pullRequestHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , pullRequestId :: !(Maybe Integer) -- ^ "id"
  , pullRequestLabels :: !(Maybe [Label]) -- ^ "labels"
  , pullRequestMergeBase :: !(Maybe Text) -- ^ "merge_base"
  , pullRequestMergeCommitSha :: !(Maybe Text) -- ^ "merge_commit_sha"
  , pullRequestMergeable :: !(Maybe Bool) -- ^ "mergeable"
  , pullRequestMerged :: !(Maybe Bool) -- ^ "merged"
  , pullRequestMergedAt :: !(Maybe DateTime) -- ^ "merged_at"
  , pullRequestMergedBy :: !(Maybe User) -- ^ "merged_by"
  , pullRequestMilestone :: !(Maybe Milestone) -- ^ "milestone"
  , pullRequestNumber :: !(Maybe Integer) -- ^ "number"
  , pullRequestPatchUrl :: !(Maybe Text) -- ^ "patch_url"
  , pullRequestState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , pullRequestTitle :: !(Maybe Text) -- ^ "title"
  , pullRequestUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , pullRequestUrl :: !(Maybe Text) -- ^ "url"
  , pullRequestUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullRequest
instance A.FromJSON PullRequest where
  parseJSON = A.withObject "PullRequest" $ \o ->
    PullRequest
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "base")
      <*> (o .:? "body")
      <*> (o .:? "closed_at")
      <*> (o .:? "comments")
      <*> (o .:? "created_at")
      <*> (o .:? "diff_url")
      <*> (o .:? "due_date")
      <*> (o .:? "head")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "labels")
      <*> (o .:? "merge_base")
      <*> (o .:? "merge_commit_sha")
      <*> (o .:? "mergeable")
      <*> (o .:? "merged")
      <*> (o .:? "merged_at")
      <*> (o .:? "merged_by")
      <*> (o .:? "milestone")
      <*> (o .:? "number")
      <*> (o .:? "patch_url")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON PullRequest
instance A.ToJSON PullRequest where
  toJSON PullRequest {..} =
   _omitNulls
      [ "assignee" .= pullRequestAssignee
      , "assignees" .= pullRequestAssignees
      , "base" .= pullRequestBase
      , "body" .= pullRequestBody
      , "closed_at" .= pullRequestClosedAt
      , "comments" .= pullRequestComments
      , "created_at" .= pullRequestCreatedAt
      , "diff_url" .= pullRequestDiffUrl
      , "due_date" .= pullRequestDueDate
      , "head" .= pullRequestHead
      , "html_url" .= pullRequestHtmlUrl
      , "id" .= pullRequestId
      , "labels" .= pullRequestLabels
      , "merge_base" .= pullRequestMergeBase
      , "merge_commit_sha" .= pullRequestMergeCommitSha
      , "mergeable" .= pullRequestMergeable
      , "merged" .= pullRequestMerged
      , "merged_at" .= pullRequestMergedAt
      , "merged_by" .= pullRequestMergedBy
      , "milestone" .= pullRequestMilestone
      , "number" .= pullRequestNumber
      , "patch_url" .= pullRequestPatchUrl
      , "state" .= pullRequestState
      , "title" .= pullRequestTitle
      , "updated_at" .= pullRequestUpdatedAt
      , "url" .= pullRequestUrl
      , "user" .= pullRequestUser
      ]


-- | Construct a value of type 'PullRequest' (by applying it's required fields, if any)
mkPullRequest
  :: PullRequest
mkPullRequest =
  PullRequest
  { pullRequestAssignee = Nothing
  , pullRequestAssignees = Nothing
  , pullRequestBase = Nothing
  , pullRequestBody = Nothing
  , pullRequestClosedAt = Nothing
  , pullRequestComments = Nothing
  , pullRequestCreatedAt = Nothing
  , pullRequestDiffUrl = Nothing
  , pullRequestDueDate = Nothing
  , pullRequestHead = Nothing
  , pullRequestHtmlUrl = Nothing
  , pullRequestId = Nothing
  , pullRequestLabels = Nothing
  , pullRequestMergeBase = Nothing
  , pullRequestMergeCommitSha = Nothing
  , pullRequestMergeable = Nothing
  , pullRequestMerged = Nothing
  , pullRequestMergedAt = Nothing
  , pullRequestMergedBy = Nothing
  , pullRequestMilestone = Nothing
  , pullRequestNumber = Nothing
  , pullRequestPatchUrl = Nothing
  , pullRequestState = Nothing
  , pullRequestTitle = Nothing
  , pullRequestUpdatedAt = Nothing
  , pullRequestUrl = Nothing
  , pullRequestUser = Nothing
  }

-- ** PullRequestMeta
-- | PullRequestMeta
-- PullRequestMeta PR info if an issue is a PR
data PullRequestMeta = PullRequestMeta
  { pullRequestMetaMerged :: !(Maybe Bool) -- ^ "merged"
  , pullRequestMetaMergedAt :: !(Maybe DateTime) -- ^ "merged_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullRequestMeta
instance A.FromJSON PullRequestMeta where
  parseJSON = A.withObject "PullRequestMeta" $ \o ->
    PullRequestMeta
      <$> (o .:? "merged")
      <*> (o .:? "merged_at")

-- | ToJSON PullRequestMeta
instance A.ToJSON PullRequestMeta where
  toJSON PullRequestMeta {..} =
   _omitNulls
      [ "merged" .= pullRequestMetaMerged
      , "merged_at" .= pullRequestMetaMergedAt
      ]


-- | Construct a value of type 'PullRequestMeta' (by applying it's required fields, if any)
mkPullRequestMeta
  :: PullRequestMeta
mkPullRequestMeta =
  PullRequestMeta
  { pullRequestMetaMerged = Nothing
  , pullRequestMetaMergedAt = Nothing
  }

-- ** Reference
-- | Reference
-- Reference represents a Git reference.
-- 
data Reference = Reference
  { referenceObject :: !(Maybe GitObject) -- ^ "object"
  , referenceRef :: !(Maybe Text) -- ^ "ref"
  , referenceUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Reference
instance A.FromJSON Reference where
  parseJSON = A.withObject "Reference" $ \o ->
    Reference
      <$> (o .:? "object")
      <*> (o .:? "ref")
      <*> (o .:? "url")

-- | ToJSON Reference
instance A.ToJSON Reference where
  toJSON Reference {..} =
   _omitNulls
      [ "object" .= referenceObject
      , "ref" .= referenceRef
      , "url" .= referenceUrl
      ]


-- | Construct a value of type 'Reference' (by applying it's required fields, if any)
mkReference
  :: Reference
mkReference =
  Reference
  { referenceObject = Nothing
  , referenceRef = Nothing
  , referenceUrl = Nothing
  }

-- ** Release
-- | Release
-- Release represents a repository release
data Release = Release
  { releaseAssets :: !(Maybe [Attachment]) -- ^ "assets"
  , releaseAuthor :: !(Maybe User) -- ^ "author"
  , releaseBody :: !(Maybe Text) -- ^ "body"
  , releaseCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , releaseDraft :: !(Maybe Bool) -- ^ "draft"
  , releaseId :: !(Maybe Integer) -- ^ "id"
  , releaseName :: !(Maybe Text) -- ^ "name"
  , releasePrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , releasePublishedAt :: !(Maybe DateTime) -- ^ "published_at"
  , releaseTagName :: !(Maybe Text) -- ^ "tag_name"
  , releaseTarballUrl :: !(Maybe Text) -- ^ "tarball_url"
  , releaseTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  , releaseUrl :: !(Maybe Text) -- ^ "url"
  , releaseZipballUrl :: !(Maybe Text) -- ^ "zipball_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Release
instance A.FromJSON Release where
  parseJSON = A.withObject "Release" $ \o ->
    Release
      <$> (o .:? "assets")
      <*> (o .:? "author")
      <*> (o .:? "body")
      <*> (o .:? "created_at")
      <*> (o .:? "draft")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:? "published_at")
      <*> (o .:? "tag_name")
      <*> (o .:? "tarball_url")
      <*> (o .:? "target_commitish")
      <*> (o .:? "url")
      <*> (o .:? "zipball_url")

-- | ToJSON Release
instance A.ToJSON Release where
  toJSON Release {..} =
   _omitNulls
      [ "assets" .= releaseAssets
      , "author" .= releaseAuthor
      , "body" .= releaseBody
      , "created_at" .= releaseCreatedAt
      , "draft" .= releaseDraft
      , "id" .= releaseId
      , "name" .= releaseName
      , "prerelease" .= releasePrerelease
      , "published_at" .= releasePublishedAt
      , "tag_name" .= releaseTagName
      , "tarball_url" .= releaseTarballUrl
      , "target_commitish" .= releaseTargetCommitish
      , "url" .= releaseUrl
      , "zipball_url" .= releaseZipballUrl
      ]


-- | Construct a value of type 'Release' (by applying it's required fields, if any)
mkRelease
  :: Release
mkRelease =
  Release
  { releaseAssets = Nothing
  , releaseAuthor = Nothing
  , releaseBody = Nothing
  , releaseCreatedAt = Nothing
  , releaseDraft = Nothing
  , releaseId = Nothing
  , releaseName = Nothing
  , releasePrerelease = Nothing
  , releasePublishedAt = Nothing
  , releaseTagName = Nothing
  , releaseTarballUrl = Nothing
  , releaseTargetCommitish = Nothing
  , releaseUrl = Nothing
  , releaseZipballUrl = Nothing
  }

-- ** RepoCommit
-- | RepoCommit
-- RepoCommit contains information of a commit in the context of a repository.
-- 
data RepoCommit = RepoCommit
  { repoCommitAuthor :: !(Maybe CommitUser) -- ^ "author"
  , repoCommitCommitter :: !(Maybe CommitUser) -- ^ "committer"
  , repoCommitMessage :: !(Maybe Text) -- ^ "message"
  , repoCommitTree :: !(Maybe CommitMeta) -- ^ "tree"
  , repoCommitUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepoCommit
instance A.FromJSON RepoCommit where
  parseJSON = A.withObject "RepoCommit" $ \o ->
    RepoCommit
      <$> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "message")
      <*> (o .:? "tree")
      <*> (o .:? "url")

-- | ToJSON RepoCommit
instance A.ToJSON RepoCommit where
  toJSON RepoCommit {..} =
   _omitNulls
      [ "author" .= repoCommitAuthor
      , "committer" .= repoCommitCommitter
      , "message" .= repoCommitMessage
      , "tree" .= repoCommitTree
      , "url" .= repoCommitUrl
      ]


-- | Construct a value of type 'RepoCommit' (by applying it's required fields, if any)
mkRepoCommit
  :: RepoCommit
mkRepoCommit =
  RepoCommit
  { repoCommitAuthor = Nothing
  , repoCommitCommitter = Nothing
  , repoCommitMessage = Nothing
  , repoCommitTree = Nothing
  , repoCommitUrl = Nothing
  }

-- ** Repository
-- | Repository
-- Repository represents a repository
data Repository = Repository
  { repositoryAllowMergeCommits :: !(Maybe Bool) -- ^ "allow_merge_commits"
  , repositoryAllowRebase :: !(Maybe Bool) -- ^ "allow_rebase"
  , repositoryAllowRebaseExplicit :: !(Maybe Bool) -- ^ "allow_rebase_explicit"
  , repositoryAllowSquashMerge :: !(Maybe Bool) -- ^ "allow_squash_merge"
  , repositoryArchived :: !(Maybe Bool) -- ^ "archived"
  , repositoryAvatarUrl :: !(Maybe Text) -- ^ "avatar_url"
  , repositoryCloneUrl :: !(Maybe Text) -- ^ "clone_url"
  , repositoryCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , repositoryDefaultBranch :: !(Maybe Text) -- ^ "default_branch"
  , repositoryDescription :: !(Maybe Text) -- ^ "description"
  , repositoryEmpty :: !(Maybe Bool) -- ^ "empty"
  , repositoryFork :: !(Maybe Bool) -- ^ "fork"
  , repositoryForksCount :: !(Maybe Integer) -- ^ "forks_count"
  , repositoryFullName :: !(Maybe Text) -- ^ "full_name"
  , repositoryHasIssues :: !(Maybe Bool) -- ^ "has_issues"
  , repositoryHasPullRequests :: !(Maybe Bool) -- ^ "has_pull_requests"
  , repositoryHasWiki :: !(Maybe Bool) -- ^ "has_wiki"
  , repositoryHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , repositoryId :: !(Maybe Integer) -- ^ "id"
  , repositoryIgnoreWhitespaceConflicts :: !(Maybe Bool) -- ^ "ignore_whitespace_conflicts"
  , repositoryMirror :: !(Maybe Bool) -- ^ "mirror"
  , repositoryName :: !(Maybe Text) -- ^ "name"
  , repositoryOpenIssuesCount :: !(Maybe Integer) -- ^ "open_issues_count"
  , repositoryOwner :: !(Maybe User) -- ^ "owner"
  , repositoryParent :: !(Maybe Repository) -- ^ "parent"
  , repositoryPermissions :: !(Maybe Permission) -- ^ "permissions"
  , repositoryPrivate :: !(Maybe Bool) -- ^ "private"
  , repositorySize :: !(Maybe Integer) -- ^ "size"
  , repositorySshUrl :: !(Maybe Text) -- ^ "ssh_url"
  , repositoryStarsCount :: !(Maybe Integer) -- ^ "stars_count"
  , repositoryUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , repositoryWatchersCount :: !(Maybe Integer) -- ^ "watchers_count"
  , repositoryWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Repository
instance A.FromJSON Repository where
  parseJSON = A.withObject "Repository" $ \o ->
    Repository
      <$> (o .:? "allow_merge_commits")
      <*> (o .:? "allow_rebase")
      <*> (o .:? "allow_rebase_explicit")
      <*> (o .:? "allow_squash_merge")
      <*> (o .:? "archived")
      <*> (o .:? "avatar_url")
      <*> (o .:? "clone_url")
      <*> (o .:? "created_at")
      <*> (o .:? "default_branch")
      <*> (o .:? "description")
      <*> (o .:? "empty")
      <*> (o .:? "fork")
      <*> (o .:? "forks_count")
      <*> (o .:? "full_name")
      <*> (o .:? "has_issues")
      <*> (o .:? "has_pull_requests")
      <*> (o .:? "has_wiki")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "ignore_whitespace_conflicts")
      <*> (o .:? "mirror")
      <*> (o .:? "name")
      <*> (o .:? "open_issues_count")
      <*> (o .:? "owner")
      <*> (o .:? "parent")
      <*> (o .:? "permissions")
      <*> (o .:? "private")
      <*> (o .:? "size")
      <*> (o .:? "ssh_url")
      <*> (o .:? "stars_count")
      <*> (o .:? "updated_at")
      <*> (o .:? "watchers_count")
      <*> (o .:? "website")

-- | ToJSON Repository
instance A.ToJSON Repository where
  toJSON Repository {..} =
   _omitNulls
      [ "allow_merge_commits" .= repositoryAllowMergeCommits
      , "allow_rebase" .= repositoryAllowRebase
      , "allow_rebase_explicit" .= repositoryAllowRebaseExplicit
      , "allow_squash_merge" .= repositoryAllowSquashMerge
      , "archived" .= repositoryArchived
      , "avatar_url" .= repositoryAvatarUrl
      , "clone_url" .= repositoryCloneUrl
      , "created_at" .= repositoryCreatedAt
      , "default_branch" .= repositoryDefaultBranch
      , "description" .= repositoryDescription
      , "empty" .= repositoryEmpty
      , "fork" .= repositoryFork
      , "forks_count" .= repositoryForksCount
      , "full_name" .= repositoryFullName
      , "has_issues" .= repositoryHasIssues
      , "has_pull_requests" .= repositoryHasPullRequests
      , "has_wiki" .= repositoryHasWiki
      , "html_url" .= repositoryHtmlUrl
      , "id" .= repositoryId
      , "ignore_whitespace_conflicts" .= repositoryIgnoreWhitespaceConflicts
      , "mirror" .= repositoryMirror
      , "name" .= repositoryName
      , "open_issues_count" .= repositoryOpenIssuesCount
      , "owner" .= repositoryOwner
      , "parent" .= repositoryParent
      , "permissions" .= repositoryPermissions
      , "private" .= repositoryPrivate
      , "size" .= repositorySize
      , "ssh_url" .= repositorySshUrl
      , "stars_count" .= repositoryStarsCount
      , "updated_at" .= repositoryUpdatedAt
      , "watchers_count" .= repositoryWatchersCount
      , "website" .= repositoryWebsite
      ]


-- | Construct a value of type 'Repository' (by applying it's required fields, if any)
mkRepository
  :: Repository
mkRepository =
  Repository
  { repositoryAllowMergeCommits = Nothing
  , repositoryAllowRebase = Nothing
  , repositoryAllowRebaseExplicit = Nothing
  , repositoryAllowSquashMerge = Nothing
  , repositoryArchived = Nothing
  , repositoryAvatarUrl = Nothing
  , repositoryCloneUrl = Nothing
  , repositoryCreatedAt = Nothing
  , repositoryDefaultBranch = Nothing
  , repositoryDescription = Nothing
  , repositoryEmpty = Nothing
  , repositoryFork = Nothing
  , repositoryForksCount = Nothing
  , repositoryFullName = Nothing
  , repositoryHasIssues = Nothing
  , repositoryHasPullRequests = Nothing
  , repositoryHasWiki = Nothing
  , repositoryHtmlUrl = Nothing
  , repositoryId = Nothing
  , repositoryIgnoreWhitespaceConflicts = Nothing
  , repositoryMirror = Nothing
  , repositoryName = Nothing
  , repositoryOpenIssuesCount = Nothing
  , repositoryOwner = Nothing
  , repositoryParent = Nothing
  , repositoryPermissions = Nothing
  , repositoryPrivate = Nothing
  , repositorySize = Nothing
  , repositorySshUrl = Nothing
  , repositoryStarsCount = Nothing
  , repositoryUpdatedAt = Nothing
  , repositoryWatchersCount = Nothing
  , repositoryWebsite = Nothing
  }

-- ** SearchResults
-- | SearchResults
-- SearchResults results of a successful search
data SearchResults = SearchResults
  { searchResultsData :: !(Maybe [Repository]) -- ^ "data"
  , searchResultsOk :: !(Maybe Bool) -- ^ "ok"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchResults
instance A.FromJSON SearchResults where
  parseJSON = A.withObject "SearchResults" $ \o ->
    SearchResults
      <$> (o .:? "data")
      <*> (o .:? "ok")

-- | ToJSON SearchResults
instance A.ToJSON SearchResults where
  toJSON SearchResults {..} =
   _omitNulls
      [ "data" .= searchResultsData
      , "ok" .= searchResultsOk
      ]


-- | Construct a value of type 'SearchResults' (by applying it's required fields, if any)
mkSearchResults
  :: SearchResults
mkSearchResults =
  SearchResults
  { searchResultsData = Nothing
  , searchResultsOk = Nothing
  }

-- ** ServerVersion
-- | ServerVersion
-- ServerVersion wraps the version of the server
data ServerVersion = ServerVersion
  { serverVersionVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServerVersion
instance A.FromJSON ServerVersion where
  parseJSON = A.withObject "ServerVersion" $ \o ->
    ServerVersion
      <$> (o .:? "version")

-- | ToJSON ServerVersion
instance A.ToJSON ServerVersion where
  toJSON ServerVersion {..} =
   _omitNulls
      [ "version" .= serverVersionVersion
      ]


-- | Construct a value of type 'ServerVersion' (by applying it's required fields, if any)
mkServerVersion
  :: ServerVersion
mkServerVersion =
  ServerVersion
  { serverVersionVersion = Nothing
  }

-- ** Status
-- | Status
-- Status holds a single Status of a single Commit
data Status = Status
  { statusContext :: !(Maybe Text) -- ^ "context"
  , statusCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , statusCreator :: !(Maybe User) -- ^ "creator"
  , statusDescription :: !(Maybe Text) -- ^ "description"
  , statusId :: !(Maybe Integer) -- ^ "id"
  , statusStatus :: !(Maybe Text) -- ^ "status" - StatusState holds the state of a Status It can be \&quot;pending\&quot;, \&quot;success\&quot;, \&quot;error\&quot;, \&quot;failure\&quot;, and \&quot;warning\&quot;
  , statusTargetUrl :: !(Maybe Text) -- ^ "target_url"
  , statusUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , statusUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Status
instance A.FromJSON Status where
  parseJSON = A.withObject "Status" $ \o ->
    Status
      <$> (o .:? "context")
      <*> (o .:? "created_at")
      <*> (o .:? "creator")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "status")
      <*> (o .:? "target_url")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")

-- | ToJSON Status
instance A.ToJSON Status where
  toJSON Status {..} =
   _omitNulls
      [ "context" .= statusContext
      , "created_at" .= statusCreatedAt
      , "creator" .= statusCreator
      , "description" .= statusDescription
      , "id" .= statusId
      , "status" .= statusStatus
      , "target_url" .= statusTargetUrl
      , "updated_at" .= statusUpdatedAt
      , "url" .= statusUrl
      ]


-- | Construct a value of type 'Status' (by applying it's required fields, if any)
mkStatus
  :: Status
mkStatus =
  Status
  { statusContext = Nothing
  , statusCreatedAt = Nothing
  , statusCreator = Nothing
  , statusDescription = Nothing
  , statusId = Nothing
  , statusStatus = Nothing
  , statusTargetUrl = Nothing
  , statusUpdatedAt = Nothing
  , statusUrl = Nothing
  }

-- ** Tag
-- | Tag
-- Tag represents a repository tag
data Tag = Tag
  { tagCommit :: !(Maybe CommitMeta) -- ^ "commit"
  , tagId :: !(Maybe Text) -- ^ "id"
  , tagName :: !(Maybe Text) -- ^ "name"
  , tagTarballUrl :: !(Maybe Text) -- ^ "tarball_url"
  , tagZipballUrl :: !(Maybe Text) -- ^ "zipball_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Tag
instance A.FromJSON Tag where
  parseJSON = A.withObject "Tag" $ \o ->
    Tag
      <$> (o .:? "commit")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "tarball_url")
      <*> (o .:? "zipball_url")

-- | ToJSON Tag
instance A.ToJSON Tag where
  toJSON Tag {..} =
   _omitNulls
      [ "commit" .= tagCommit
      , "id" .= tagId
      , "name" .= tagName
      , "tarball_url" .= tagTarballUrl
      , "zipball_url" .= tagZipballUrl
      ]


-- | Construct a value of type 'Tag' (by applying it's required fields, if any)
mkTag
  :: Tag
mkTag =
  Tag
  { tagCommit = Nothing
  , tagId = Nothing
  , tagName = Nothing
  , tagTarballUrl = Nothing
  , tagZipballUrl = Nothing
  }

-- ** Team
-- | Team
-- Team represents a team in an organization
data Team = Team
  { teamDescription :: !(Maybe Text) -- ^ "description"
  , teamId :: !(Maybe Integer) -- ^ "id"
  , teamName :: !(Maybe Text) -- ^ "name"
  , teamOrganization :: !(Maybe Organization) -- ^ "organization"
  , teamPermission :: !(Maybe E'Permission2) -- ^ "permission"
  , teamUnits :: !(Maybe [Text]) -- ^ "units"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Team
instance A.FromJSON Team where
  parseJSON = A.withObject "Team" $ \o ->
    Team
      <$> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "permission")
      <*> (o .:? "units")

-- | ToJSON Team
instance A.ToJSON Team where
  toJSON Team {..} =
   _omitNulls
      [ "description" .= teamDescription
      , "id" .= teamId
      , "name" .= teamName
      , "organization" .= teamOrganization
      , "permission" .= teamPermission
      , "units" .= teamUnits
      ]


-- | Construct a value of type 'Team' (by applying it's required fields, if any)
mkTeam
  :: Team
mkTeam =
  Team
  { teamDescription = Nothing
  , teamId = Nothing
  , teamName = Nothing
  , teamOrganization = Nothing
  , teamPermission = Nothing
  , teamUnits = Nothing
  }

-- ** TrackedTime
-- | TrackedTime
-- TrackedTime worked time for an issue / pr
data TrackedTime = TrackedTime
  { trackedTimeCreated :: !(Maybe DateTime) -- ^ "created"
  , trackedTimeId :: !(Maybe Integer) -- ^ "id"
  , trackedTimeIssueId :: !(Maybe Integer) -- ^ "issue_id"
  , trackedTimeTime :: !(Maybe Integer) -- ^ "time" - Time in seconds
  , trackedTimeUserId :: !(Maybe Integer) -- ^ "user_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrackedTime
instance A.FromJSON TrackedTime where
  parseJSON = A.withObject "TrackedTime" $ \o ->
    TrackedTime
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "issue_id")
      <*> (o .:? "time")
      <*> (o .:? "user_id")

-- | ToJSON TrackedTime
instance A.ToJSON TrackedTime where
  toJSON TrackedTime {..} =
   _omitNulls
      [ "created" .= trackedTimeCreated
      , "id" .= trackedTimeId
      , "issue_id" .= trackedTimeIssueId
      , "time" .= trackedTimeTime
      , "user_id" .= trackedTimeUserId
      ]


-- | Construct a value of type 'TrackedTime' (by applying it's required fields, if any)
mkTrackedTime
  :: TrackedTime
mkTrackedTime =
  TrackedTime
  { trackedTimeCreated = Nothing
  , trackedTimeId = Nothing
  , trackedTimeIssueId = Nothing
  , trackedTimeTime = Nothing
  , trackedTimeUserId = Nothing
  }

-- ** UpdateFileOptions
-- | UpdateFileOptions
-- UpdateFileOptions options for updating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data UpdateFileOptions = UpdateFileOptions
  { updateFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , updateFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , updateFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , updateFileOptionsContent :: !(Text) -- ^ /Required/ "content" - content must be base64 encoded
  , updateFileOptionsFromPath :: !(Maybe Text) -- ^ "from_path" - from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
  , updateFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , updateFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , updateFileOptionsSha :: !(Text) -- ^ /Required/ "sha" - sha is the SHA for the file that already exists
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateFileOptions
instance A.FromJSON UpdateFileOptions where
  parseJSON = A.withObject "UpdateFileOptions" $ \o ->
    UpdateFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:  "content")
      <*> (o .:? "from_path")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:  "sha")

-- | ToJSON UpdateFileOptions
instance A.ToJSON UpdateFileOptions where
  toJSON UpdateFileOptions {..} =
   _omitNulls
      [ "author" .= updateFileOptionsAuthor
      , "branch" .= updateFileOptionsBranch
      , "committer" .= updateFileOptionsCommitter
      , "content" .= updateFileOptionsContent
      , "from_path" .= updateFileOptionsFromPath
      , "message" .= updateFileOptionsMessage
      , "new_branch" .= updateFileOptionsNewBranch
      , "sha" .= updateFileOptionsSha
      ]


-- | Construct a value of type 'UpdateFileOptions' (by applying it's required fields, if any)
mkUpdateFileOptions
  :: Text -- ^ 'updateFileOptionsContent': content must be base64 encoded
  -> Text -- ^ 'updateFileOptionsSha': sha is the SHA for the file that already exists
  -> UpdateFileOptions
mkUpdateFileOptions updateFileOptionsContent updateFileOptionsSha =
  UpdateFileOptions
  { updateFileOptionsAuthor = Nothing
  , updateFileOptionsBranch = Nothing
  , updateFileOptionsCommitter = Nothing
  , updateFileOptionsContent
  , updateFileOptionsFromPath = Nothing
  , updateFileOptionsMessage = Nothing
  , updateFileOptionsNewBranch = Nothing
  , updateFileOptionsSha
  }

-- ** User
-- | User
-- User represents a user
data User = User
  { userAvatarUrl :: !(Maybe Text) -- ^ "avatar_url" - URL to the user&#39;s avatar
  , userCreated :: !(Maybe DateTime) -- ^ "created"
  , userEmail :: !(Maybe Text) -- ^ "email"
  , userFullName :: !(Maybe Text) -- ^ "full_name" - the user&#39;s full name
  , userId :: !(Maybe Integer) -- ^ "id" - the user&#39;s id
  , userIsAdmin :: !(Maybe Bool) -- ^ "is_admin" - Is the user an administrator
  , userLanguage :: !(Maybe Text) -- ^ "language" - User locale
  , userLastLogin :: !(Maybe DateTime) -- ^ "last_login"
  , userLogin :: !(Maybe Text) -- ^ "login" - the user&#39;s username
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "avatar_url")
      <*> (o .:? "created")
      <*> (o .:? "email")
      <*> (o .:? "full_name")
      <*> (o .:? "id")
      <*> (o .:? "is_admin")
      <*> (o .:? "language")
      <*> (o .:? "last_login")
      <*> (o .:? "login")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "avatar_url" .= userAvatarUrl
      , "created" .= userCreated
      , "email" .= userEmail
      , "full_name" .= userFullName
      , "id" .= userId
      , "is_admin" .= userIsAdmin
      , "language" .= userLanguage
      , "last_login" .= userLastLogin
      , "login" .= userLogin
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userAvatarUrl = Nothing
  , userCreated = Nothing
  , userEmail = Nothing
  , userFullName = Nothing
  , userId = Nothing
  , userIsAdmin = Nothing
  , userLanguage = Nothing
  , userLastLogin = Nothing
  , userLogin = Nothing
  }

-- ** UserHeatmapData
-- | UserHeatmapData
-- UserHeatmapData represents the data needed to create a heatmap
data UserHeatmapData = UserHeatmapData
  { userHeatmapDataContributions :: !(Maybe Integer) -- ^ "contributions"
  , userHeatmapDataTimestamp :: !(Maybe Integer) -- ^ "timestamp" - TimeStamp defines a timestamp
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserHeatmapData
instance A.FromJSON UserHeatmapData where
  parseJSON = A.withObject "UserHeatmapData" $ \o ->
    UserHeatmapData
      <$> (o .:? "contributions")
      <*> (o .:? "timestamp")

-- | ToJSON UserHeatmapData
instance A.ToJSON UserHeatmapData where
  toJSON UserHeatmapData {..} =
   _omitNulls
      [ "contributions" .= userHeatmapDataContributions
      , "timestamp" .= userHeatmapDataTimestamp
      ]


-- | Construct a value of type 'UserHeatmapData' (by applying it's required fields, if any)
mkUserHeatmapData
  :: UserHeatmapData
mkUserHeatmapData =
  UserHeatmapData
  { userHeatmapDataContributions = Nothing
  , userHeatmapDataTimestamp = Nothing
  }

-- ** WatchInfo
-- | WatchInfo
-- WatchInfo represents an API watch status of one repository
data WatchInfo = WatchInfo
  { watchInfoCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , watchInfoIgnored :: !(Maybe Bool) -- ^ "ignored"
  , watchInfoReason :: !(Maybe A.Value) -- ^ "reason"
  , watchInfoRepositoryUrl :: !(Maybe Text) -- ^ "repository_url"
  , watchInfoSubscribed :: !(Maybe Bool) -- ^ "subscribed"
  , watchInfoUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WatchInfo
instance A.FromJSON WatchInfo where
  parseJSON = A.withObject "WatchInfo" $ \o ->
    WatchInfo
      <$> (o .:? "created_at")
      <*> (o .:? "ignored")
      <*> (o .:? "reason")
      <*> (o .:? "repository_url")
      <*> (o .:? "subscribed")
      <*> (o .:? "url")

-- | ToJSON WatchInfo
instance A.ToJSON WatchInfo where
  toJSON WatchInfo {..} =
   _omitNulls
      [ "created_at" .= watchInfoCreatedAt
      , "ignored" .= watchInfoIgnored
      , "reason" .= watchInfoReason
      , "repository_url" .= watchInfoRepositoryUrl
      , "subscribed" .= watchInfoSubscribed
      , "url" .= watchInfoUrl
      ]


-- | Construct a value of type 'WatchInfo' (by applying it's required fields, if any)
mkWatchInfo
  :: WatchInfo
mkWatchInfo =
  WatchInfo
  { watchInfoCreatedAt = Nothing
  , watchInfoIgnored = Nothing
  , watchInfoReason = Nothing
  , watchInfoRepositoryUrl = Nothing
  , watchInfoSubscribed = Nothing
  , watchInfoUrl = Nothing
  }


-- * Enums


-- ** E'Do

-- | Enum of 'Text'
data E'Do
  = E'Do'Merge -- ^ @"merge"@
  | E'Do'Rebase -- ^ @"rebase"@
  | E'Do'Rebase_merge -- ^ @"rebase-merge"@
  | E'Do'Squash -- ^ @"squash"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Do where toJSON = A.toJSON . fromE'Do
instance A.FromJSON E'Do where parseJSON o = P.either P.fail (pure . P.id) . toE'Do =<< A.parseJSON o
instance WH.ToHttpApiData E'Do where toQueryParam = WH.toQueryParam . fromE'Do
instance WH.FromHttpApiData E'Do where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Do
instance MimeRender MimeMultipartFormData E'Do where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Do' enum
fromE'Do :: E'Do -> Text
fromE'Do = \case
  E'Do'Merge -> "merge"
  E'Do'Rebase -> "rebase"
  E'Do'Rebase_merge -> "rebase-merge"
  E'Do'Squash -> "squash"

-- | parse 'E'Do' enum
toE'Do :: Text -> P.Either String E'Do
toE'Do = \case
  "merge" -> P.Right E'Do'Merge
  "rebase" -> P.Right E'Do'Rebase
  "rebase-merge" -> P.Right E'Do'Rebase_merge
  "squash" -> P.Right E'Do'Squash
  s -> P.Left $ "toE'Do: enum parse failure: " P.++ P.show s


-- ** E'Permission

-- | Enum of 'Text'
data E'Permission
  = E'Permission'Read -- ^ @"read"@
  | E'Permission'Write -- ^ @"write"@
  | E'Permission'Admin -- ^ @"admin"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Permission where toJSON = A.toJSON . fromE'Permission
instance A.FromJSON E'Permission where parseJSON o = P.either P.fail (pure . P.id) . toE'Permission =<< A.parseJSON o
instance WH.ToHttpApiData E'Permission where toQueryParam = WH.toQueryParam . fromE'Permission
instance WH.FromHttpApiData E'Permission where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Permission
instance MimeRender MimeMultipartFormData E'Permission where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Permission' enum
fromE'Permission :: E'Permission -> Text
fromE'Permission = \case
  E'Permission'Read -> "read"
  E'Permission'Write -> "write"
  E'Permission'Admin -> "admin"

-- | parse 'E'Permission' enum
toE'Permission :: Text -> P.Either String E'Permission
toE'Permission = \case
  "read" -> P.Right E'Permission'Read
  "write" -> P.Right E'Permission'Write
  "admin" -> P.Right E'Permission'Admin
  s -> P.Left $ "toE'Permission: enum parse failure: " P.++ P.show s


-- ** E'Permission2

-- | Enum of 'Text'
data E'Permission2
  = E'Permission2'None -- ^ @"none"@
  | E'Permission2'Read -- ^ @"read"@
  | E'Permission2'Write -- ^ @"write"@
  | E'Permission2'Admin -- ^ @"admin"@
  | E'Permission2'Owner -- ^ @"owner"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Permission2 where toJSON = A.toJSON . fromE'Permission2
instance A.FromJSON E'Permission2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Permission2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Permission2 where toQueryParam = WH.toQueryParam . fromE'Permission2
instance WH.FromHttpApiData E'Permission2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Permission2
instance MimeRender MimeMultipartFormData E'Permission2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Permission2' enum
fromE'Permission2 :: E'Permission2 -> Text
fromE'Permission2 = \case
  E'Permission2'None -> "none"
  E'Permission2'Read -> "read"
  E'Permission2'Write -> "write"
  E'Permission2'Admin -> "admin"
  E'Permission2'Owner -> "owner"

-- | parse 'E'Permission2' enum
toE'Permission2 :: Text -> P.Either String E'Permission2
toE'Permission2 = \case
  "none" -> P.Right E'Permission2'None
  "read" -> P.Right E'Permission2'Read
  "write" -> P.Right E'Permission2'Write
  "admin" -> P.Right E'Permission2'Admin
  "owner" -> P.Right E'Permission2'Owner
  s -> P.Left $ "toE'Permission2: enum parse failure: " P.++ P.show s


-- ** E'Sort

-- | Enum of 'Text'
data E'Sort
  = E'Sort'Oldest -- ^ @"oldest"@
  | E'Sort'Recentupdate -- ^ @"recentupdate"@
  | E'Sort'Leastupdate -- ^ @"leastupdate"@
  | E'Sort'Mostcomment -- ^ @"mostcomment"@
  | E'Sort'Leastcomment -- ^ @"leastcomment"@
  | E'Sort'Priority -- ^ @"priority"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sort where toJSON = A.toJSON . fromE'Sort
instance A.FromJSON E'Sort where parseJSON o = P.either P.fail (pure . P.id) . toE'Sort =<< A.parseJSON o
instance WH.ToHttpApiData E'Sort where toQueryParam = WH.toQueryParam . fromE'Sort
instance WH.FromHttpApiData E'Sort where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sort
instance MimeRender MimeMultipartFormData E'Sort where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sort' enum
fromE'Sort :: E'Sort -> Text
fromE'Sort = \case
  E'Sort'Oldest -> "oldest"
  E'Sort'Recentupdate -> "recentupdate"
  E'Sort'Leastupdate -> "leastupdate"
  E'Sort'Mostcomment -> "mostcomment"
  E'Sort'Leastcomment -> "leastcomment"
  E'Sort'Priority -> "priority"

-- | parse 'E'Sort' enum
toE'Sort :: Text -> P.Either String E'Sort
toE'Sort = \case
  "oldest" -> P.Right E'Sort'Oldest
  "recentupdate" -> P.Right E'Sort'Recentupdate
  "leastupdate" -> P.Right E'Sort'Leastupdate
  "mostcomment" -> P.Right E'Sort'Mostcomment
  "leastcomment" -> P.Right E'Sort'Leastcomment
  "priority" -> P.Right E'Sort'Priority
  s -> P.Left $ "toE'Sort: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Closed -- ^ @"closed"@
  | E'State'Open -- ^ @"open"@
  | E'State'All -- ^ @"all"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Closed -> "closed"
  E'State'Open -> "open"
  E'State'All -> "all"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "closed" -> P.Right E'State'Closed
  "open" -> P.Right E'State'Open
  "all" -> P.Right E'State'All
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Gitea -- ^ @"gitea"@
  | E'Type'Gogs -- ^ @"gogs"@
  | E'Type'Slack -- ^ @"slack"@
  | E'Type'Discord -- ^ @"discord"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Gitea -> "gitea"
  E'Type'Gogs -> "gogs"
  E'Type'Slack -> "slack"
  E'Type'Discord -> "discord"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "gitea" -> P.Right E'Type'Gitea
  "gogs" -> P.Right E'Type'Gogs
  "slack" -> P.Right E'Type'Slack
  "discord" -> P.Right E'Type'Discord
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Visibility

-- | Enum of 'Text' . 
-- possible values are `public` (default), `limited` or `private`
data E'Visibility
  = E'Visibility'Public -- ^ @"public"@
  | E'Visibility'Limited -- ^ @"limited"@
  | E'Visibility'Private -- ^ @"private"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Visibility where toJSON = A.toJSON . fromE'Visibility
instance A.FromJSON E'Visibility where parseJSON o = P.either P.fail (pure . P.id) . toE'Visibility =<< A.parseJSON o
instance WH.ToHttpApiData E'Visibility where toQueryParam = WH.toQueryParam . fromE'Visibility
instance WH.FromHttpApiData E'Visibility where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Visibility
instance MimeRender MimeMultipartFormData E'Visibility where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Visibility' enum
fromE'Visibility :: E'Visibility -> Text
fromE'Visibility = \case
  E'Visibility'Public -> "public"
  E'Visibility'Limited -> "limited"
  E'Visibility'Private -> "private"

-- | parse 'E'Visibility' enum
toE'Visibility :: Text -> P.Either String E'Visibility
toE'Visibility = \case
  "public" -> P.Right E'Visibility'Public
  "limited" -> P.Right E'Visibility'Limited
  "private" -> P.Right E'Visibility'Private
  s -> P.Left $ "toE'Visibility: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyAccessToken
data AuthApiKeyAccessToken =
  AuthApiKeyAccessToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAccessToken where
  applyAuthMethod _ a@(AuthApiKeyAccessToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("access_token", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyAuthorizationHeaderToken
data AuthApiKeyAuthorizationHeaderToken =
  AuthApiKeyAuthorizationHeaderToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAuthorizationHeaderToken where
  applyAuthMethod _ a@(AuthApiKeyAuthorizationHeaderToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

-- ** AuthApiKeySudoHeader
data AuthApiKeySudoHeader =
  AuthApiKeySudoHeader Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySudoHeader where
  applyAuthMethod _ a@(AuthApiKeySudoHeader secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Sudo", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeySudoParam
data AuthApiKeySudoParam =
  AuthApiKeySudoParam Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySudoParam where
  applyAuthMethod _ a@(AuthApiKeySudoParam secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("sudo", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyToken
data AuthApiKeyToken =
  AuthApiKeyToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyToken where
  applyAuthMethod _ a@(AuthApiKeyToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("token", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


