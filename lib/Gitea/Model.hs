{-
   Gitea API.

   This documentation describes the Gitea API.

   OpenAPI Version: 3.0.1
   Gitea API. API version: 1.20.6
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Gitea.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Gitea.Model where

import Gitea.Core
import Gitea.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** All
newtype All = All { unAll :: Bool } deriving (P.Eq, P.Show)

-- ** AllText
newtype AllText = AllText { unAllText :: Text } deriving (P.Eq, P.Show)

-- ** Archive
newtype Archive = Archive { unArchive :: Text } deriving (P.Eq, P.Show)

-- ** Archived
newtype Archived = Archived { unArchived :: Bool } deriving (P.Eq, P.Show)

-- ** Assigned
newtype Assigned = Assigned { unAssigned :: Bool } deriving (P.Eq, P.Show)

-- ** AssignedBy
newtype AssignedBy = AssignedBy { unAssignedBy :: Text } deriving (P.Eq, P.Show)

-- ** Attachment2
newtype Attachment2 = Attachment2 { unAttachment2 :: FilePath } deriving (P.Eq, P.Show)

-- ** AttachmentId
newtype AttachmentId = AttachmentId { unAttachmentId :: Integer } deriving (P.Eq, P.Show)

-- ** Before
newtype Before = Before { unBefore :: DateTime } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Branch2
newtype Branch2 = Branch2 { unBranch2 :: Text } deriving (P.Eq, P.Show)

-- ** Collaborator
newtype Collaborator = Collaborator { unCollaborator :: Text } deriving (P.Eq, P.Show)

-- ** Created
newtype Created = Created { unCreated :: Bool } deriving (P.Eq, P.Show)

-- ** CreatedBy
newtype CreatedBy = CreatedBy { unCreatedBy :: Text } deriving (P.Eq, P.Show)

-- ** DiffType
newtype DiffType = DiffType { unDiffType :: E'DiffType } deriving (P.Eq, P.Show)

-- ** Draft
newtype Draft = Draft { unDraft :: Bool } deriving (P.Eq, P.Show)

-- ** Exclusive
newtype Exclusive = Exclusive { unExclusive :: Bool } deriving (P.Eq, P.Show)

-- ** Filepath
newtype Filepath = Filepath { unFilepath :: Text } deriving (P.Eq, P.Show)

-- ** Files
newtype Files = Files { unFiles :: Bool } deriving (P.Eq, P.Show)

-- ** Fingerprint
newtype Fingerprint = Fingerprint { unFingerprint :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Integer } deriving (P.Eq, P.Show)

-- ** IdInt
newtype IdInt = IdInt { unIdInt :: Int } deriving (P.Eq, P.Show)

-- ** IdText
newtype IdText = IdText { unIdText :: Text } deriving (P.Eq, P.Show)

-- ** IncludeDesc
newtype IncludeDesc = IncludeDesc { unIncludeDesc :: Bool } deriving (P.Eq, P.Show)

-- ** Index
newtype Index = Index { unIndex :: Integer } deriving (P.Eq, P.Show)

-- ** IndexInt
newtype IndexInt = IndexInt { unIndexInt :: Int } deriving (P.Eq, P.Show)

-- ** IndexText
newtype IndexText = IndexText { unIndexText :: Text } deriving (P.Eq, P.Show)

-- ** IsPrivate
newtype IsPrivate = IsPrivate { unIsPrivate :: Bool } deriving (P.Eq, P.Show)

-- ** KeyId
newtype KeyId = KeyId { unKeyId :: Int } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** LabelsInteger
newtype LabelsInteger = LabelsInteger { unLabelsInteger :: [Integer] } deriving (P.Eq, P.Show)

-- ** LastReadAt
newtype LastReadAt = LastReadAt { unLastReadAt :: DateTime } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** LoginName
newtype LoginName = LoginName { unLoginName :: Text } deriving (P.Eq, P.Show)

-- ** Mentioned
newtype Mentioned = Mentioned { unMentioned :: Bool } deriving (P.Eq, P.Show)

-- ** MentionedBy
newtype MentionedBy = MentionedBy { unMentionedBy :: Text } deriving (P.Eq, P.Show)

-- ** Milestone2
newtype Milestone2 = Milestone2 { unMilestone2 :: Integer } deriving (P.Eq, P.Show)

-- ** Milestones
newtype Milestones = Milestones { unMilestones :: Text } deriving (P.Eq, P.Show)

-- ** Mode
newtype Mode = Mode { unMode :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Not
newtype Not = Not { unNot :: Text } deriving (P.Eq, P.Show)

-- ** OnlyPerformedBy
newtype OnlyPerformedBy = OnlyPerformedBy { unOnlyPerformedBy :: Bool } deriving (P.Eq, P.Show)

-- ** Order
newtype Order = Order { unOrder :: Text } deriving (P.Eq, P.Show)

-- ** Org
newtype Org = Org { unOrg :: Text } deriving (P.Eq, P.Show)

-- ** Owner
newtype Owner = Owner { unOwner :: Text } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** PageName
newtype PageName = PageName { unPageName :: Text } deriving (P.Eq, P.Show)

-- ** ParamBinary
newtype ParamBinary = ParamBinary { unParamBinary :: Bool } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Date } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'Type2 } deriving (P.Eq, P.Show)

-- ** ParamType2
newtype ParamType2 = ParamType2 { unParamType2 :: E'Type3 } deriving (P.Eq, P.Show)

-- ** ParamTypeText
newtype ParamTypeText = ParamTypeText { unParamTypeText :: Text } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** Pattern
newtype Pattern = Pattern { unPattern :: Text } deriving (P.Eq, P.Show)

-- ** PerPage
newtype PerPage = PerPage { unPerPage :: Int } deriving (P.Eq, P.Show)

-- ** Position
newtype Position = Position { unPosition :: Integer } deriving (P.Eq, P.Show)

-- ** PreRelease
newtype PreRelease = PreRelease { unPreRelease :: Bool } deriving (P.Eq, P.Show)

-- ** PriorityOwnerId
newtype PriorityOwnerId = PriorityOwnerId { unPriorityOwnerId :: Integer } deriving (P.Eq, P.Show)

-- ** PriorityRepoId
newtype PriorityRepoId = PriorityRepoId { unPriorityRepoId :: Integer } deriving (P.Eq, P.Show)

-- ** Private
newtype Private = Private { unPrivate :: Bool } deriving (P.Eq, P.Show)

-- ** Purge
newtype Purge = Purge { unPurge :: Bool } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Recursive
newtype Recursive = Recursive { unRecursive :: Bool } deriving (P.Eq, P.Show)

-- ** Ref
newtype Ref = Ref { unRef :: Text } deriving (P.Eq, P.Show)

-- ** Repo
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)

-- ** ReviewRequested
newtype ReviewRequested = ReviewRequested { unReviewRequested :: Bool } deriving (P.Eq, P.Show)

-- ** Reviewed
newtype Reviewed = Reviewed { unReviewed :: Bool } deriving (P.Eq, P.Show)

-- ** Sha
newtype Sha = Sha { unSha :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: DateTime } deriving (P.Eq, P.Show)

-- ** SkipTo
newtype SkipTo = SkipTo { unSkipTo :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** Sort2
newtype Sort2 = Sort2 { unSort2 :: E'Sort } deriving (P.Eq, P.Show)

-- ** Sort3
newtype Sort3 = Sort3 { unSort3 :: E'Sort2 } deriving (P.Eq, P.Show)

-- ** SourceId
newtype SourceId = SourceId { unSourceId :: Integer } deriving (P.Eq, P.Show)

-- ** StarredBy
newtype StarredBy = StarredBy { unStarredBy :: Integer } deriving (P.Eq, P.Show)

-- ** Stat
newtype Stat = Stat { unStat :: Bool } deriving (P.Eq, P.Show)

-- ** State
newtype State = State { unState :: Text } deriving (P.Eq, P.Show)

-- ** State2
newtype State2 = State2 { unState2 :: E'State2 } deriving (P.Eq, P.Show)

-- ** State3
newtype State3 = State3 { unState3 :: E'State3 } deriving (P.Eq, P.Show)

-- ** StatusTypes
newtype StatusTypes = StatusTypes { unStatusTypes :: [Text] } deriving (P.Eq, P.Show)

-- ** Style
newtype Style = Style { unStyle :: E'Style } deriving (P.Eq, P.Show)

-- ** SubjectType
newtype SubjectType = SubjectType { unSubjectType :: [E'SubjectType] } deriving (P.Eq, P.Show)

-- ** Tag2
newtype Tag2 = Tag2 { unTag2 :: Text } deriving (P.Eq, P.Show)

-- ** Target
newtype Target = Target { unTarget :: Text } deriving (P.Eq, P.Show)

-- ** Task
newtype Task = Task { unTask :: Text } deriving (P.Eq, P.Show)

-- ** Team2
newtype Team2 = Team2 { unTeam2 :: Text } deriving (P.Eq, P.Show)

-- ** TeamId
newtype TeamId = TeamId { unTeamId :: Integer } deriving (P.Eq, P.Show)

-- ** Template
newtype Template = Template { unTemplate :: Bool } deriving (P.Eq, P.Show)

-- ** TemplateOwner
newtype TemplateOwner = TemplateOwner { unTemplateOwner :: Text } deriving (P.Eq, P.Show)

-- ** TemplateRepo
newtype TemplateRepo = TemplateRepo { unTemplateRepo :: Text } deriving (P.Eq, P.Show)

-- ** ToStatus
newtype ToStatus = ToStatus { unToStatus :: Text } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Text } deriving (P.Eq, P.Show)

-- ** Topic
newtype Topic = Topic { unTopic :: Bool } deriving (P.Eq, P.Show)

-- ** TopicText
newtype TopicText = TopicText { unTopicText :: Text } deriving (P.Eq, P.Show)

-- ** Uid
newtype Uid = Uid { unUid :: Integer } deriving (P.Eq, P.Show)

-- ** User2
newtype User2 = User2 { unUser2 :: Text } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Int } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** Verification
newtype Verification = Verification { unVerification :: Bool } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Text } deriving (P.Eq, P.Show)

-- ** Whitespace
newtype Whitespace = Whitespace { unWhitespace :: E'Whitespace } deriving (P.Eq, P.Show)

-- * Models


-- ** APIError
-- | APIError
-- APIError is an api error with a message
data APIError = APIError
  { aPIErrorMessage :: !(Maybe Text) -- ^ "message"
  , aPIErrorUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON APIError
instance A.FromJSON APIError where
  parseJSON = A.withObject "APIError" $ \o ->
    APIError
      <$> (o .:? "message")
      <*> (o .:? "url")

-- | ToJSON APIError
instance A.ToJSON APIError where
  toJSON APIError {..} =
   _omitNulls
      [ "message" .= aPIErrorMessage
      , "url" .= aPIErrorUrl
      ]


-- | Construct a value of type 'APIError' (by applying it's required fields, if any)
mkAPIError
  :: APIError
mkAPIError =
  APIError
  { aPIErrorMessage = Nothing
  , aPIErrorUrl = Nothing
  }

-- ** AccessToken
-- | AccessToken
-- AccessToken represents an API access token.
-- 
data AccessToken = AccessToken
  { accessTokenId :: !(Maybe Integer) -- ^ "id"
  , accessTokenName :: !(Maybe Text) -- ^ "name"
  , accessTokenScopes :: !(Maybe [Text]) -- ^ "scopes"
  , accessTokenSha1 :: !(Maybe Text) -- ^ "sha1"
  , accessTokenTokenLastEight :: !(Maybe Text) -- ^ "token_last_eight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessToken
instance A.FromJSON AccessToken where
  parseJSON = A.withObject "AccessToken" $ \o ->
    AccessToken
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "scopes")
      <*> (o .:? "sha1")
      <*> (o .:? "token_last_eight")

-- | ToJSON AccessToken
instance A.ToJSON AccessToken where
  toJSON AccessToken {..} =
   _omitNulls
      [ "id" .= accessTokenId
      , "name" .= accessTokenName
      , "scopes" .= accessTokenScopes
      , "sha1" .= accessTokenSha1
      , "token_last_eight" .= accessTokenTokenLastEight
      ]


-- | Construct a value of type 'AccessToken' (by applying it's required fields, if any)
mkAccessToken
  :: AccessToken
mkAccessToken =
  AccessToken
  { accessTokenId = Nothing
  , accessTokenName = Nothing
  , accessTokenScopes = Nothing
  , accessTokenSha1 = Nothing
  , accessTokenTokenLastEight = Nothing
  }

-- ** Activity
-- | Activity
data Activity = Activity
  { activityActUser :: !(Maybe User) -- ^ "act_user"
  , activityActUserId :: !(Maybe Integer) -- ^ "act_user_id"
  , activityComment :: !(Maybe Comment) -- ^ "comment"
  , activityCommentId :: !(Maybe Integer) -- ^ "comment_id"
  , activityContent :: !(Maybe Text) -- ^ "content"
  , activityCreated :: !(Maybe DateTime) -- ^ "created"
  , activityId :: !(Maybe Integer) -- ^ "id"
  , activityIsPrivate :: !(Maybe Bool) -- ^ "is_private"
  , activityOpType :: !(Maybe Text) -- ^ "op_type"
  , activityRefName :: !(Maybe Text) -- ^ "ref_name"
  , activityRepo :: !(Maybe Repository) -- ^ "repo"
  , activityRepoId :: !(Maybe Integer) -- ^ "repo_id"
  , activityUserId :: !(Maybe Integer) -- ^ "user_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Activity
instance A.FromJSON Activity where
  parseJSON = A.withObject "Activity" $ \o ->
    Activity
      <$> (o .:? "act_user")
      <*> (o .:? "act_user_id")
      <*> (o .:? "comment")
      <*> (o .:? "comment_id")
      <*> (o .:? "content")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "is_private")
      <*> (o .:? "op_type")
      <*> (o .:? "ref_name")
      <*> (o .:? "repo")
      <*> (o .:? "repo_id")
      <*> (o .:? "user_id")

-- | ToJSON Activity
instance A.ToJSON Activity where
  toJSON Activity {..} =
   _omitNulls
      [ "act_user" .= activityActUser
      , "act_user_id" .= activityActUserId
      , "comment" .= activityComment
      , "comment_id" .= activityCommentId
      , "content" .= activityContent
      , "created" .= activityCreated
      , "id" .= activityId
      , "is_private" .= activityIsPrivate
      , "op_type" .= activityOpType
      , "ref_name" .= activityRefName
      , "repo" .= activityRepo
      , "repo_id" .= activityRepoId
      , "user_id" .= activityUserId
      ]


-- | Construct a value of type 'Activity' (by applying it's required fields, if any)
mkActivity
  :: Activity
mkActivity =
  Activity
  { activityActUser = Nothing
  , activityActUserId = Nothing
  , activityComment = Nothing
  , activityCommentId = Nothing
  , activityContent = Nothing
  , activityCreated = Nothing
  , activityId = Nothing
  , activityIsPrivate = Nothing
  , activityOpType = Nothing
  , activityRefName = Nothing
  , activityRepo = Nothing
  , activityRepoId = Nothing
  , activityUserId = Nothing
  }

-- ** ActivityPub
-- | ActivityPub
-- ActivityPub type
data ActivityPub = ActivityPub
  { activityPubContext :: !(Maybe Text) -- ^ "@context"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ActivityPub
instance A.FromJSON ActivityPub where
  parseJSON = A.withObject "ActivityPub" $ \o ->
    ActivityPub
      <$> (o .:? "@context")

-- | ToJSON ActivityPub
instance A.ToJSON ActivityPub where
  toJSON ActivityPub {..} =
   _omitNulls
      [ "@context" .= activityPubContext
      ]


-- | Construct a value of type 'ActivityPub' (by applying it's required fields, if any)
mkActivityPub
  :: ActivityPub
mkActivityPub =
  ActivityPub
  { activityPubContext = Nothing
  }

-- ** AddCollaboratorOption
-- | AddCollaboratorOption
-- AddCollaboratorOption options when adding a user as a collaborator of a repository
data AddCollaboratorOption = AddCollaboratorOption
  { addCollaboratorOptionPermission :: !(Maybe Text) -- ^ "permission"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddCollaboratorOption
instance A.FromJSON AddCollaboratorOption where
  parseJSON = A.withObject "AddCollaboratorOption" $ \o ->
    AddCollaboratorOption
      <$> (o .:? "permission")

-- | ToJSON AddCollaboratorOption
instance A.ToJSON AddCollaboratorOption where
  toJSON AddCollaboratorOption {..} =
   _omitNulls
      [ "permission" .= addCollaboratorOptionPermission
      ]


-- | Construct a value of type 'AddCollaboratorOption' (by applying it's required fields, if any)
mkAddCollaboratorOption
  :: AddCollaboratorOption
mkAddCollaboratorOption =
  AddCollaboratorOption
  { addCollaboratorOptionPermission = Nothing
  }

-- ** AddTimeOption
-- | AddTimeOption
-- AddTimeOption options for adding time to an issue
data AddTimeOption = AddTimeOption
  { addTimeOptionCreated :: !(Maybe DateTime) -- ^ "created"
  , addTimeOptionTime :: !(Integer) -- ^ /Required/ "time" - time in seconds
  , addTimeOptionUserName :: !(Maybe Text) -- ^ "user_name" - User who spent the time (optional)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddTimeOption
instance A.FromJSON AddTimeOption where
  parseJSON = A.withObject "AddTimeOption" $ \o ->
    AddTimeOption
      <$> (o .:? "created")
      <*> (o .:  "time")
      <*> (o .:? "user_name")

-- | ToJSON AddTimeOption
instance A.ToJSON AddTimeOption where
  toJSON AddTimeOption {..} =
   _omitNulls
      [ "created" .= addTimeOptionCreated
      , "time" .= addTimeOptionTime
      , "user_name" .= addTimeOptionUserName
      ]


-- | Construct a value of type 'AddTimeOption' (by applying it's required fields, if any)
mkAddTimeOption
  :: Integer -- ^ 'addTimeOptionTime': time in seconds
  -> AddTimeOption
mkAddTimeOption addTimeOptionTime =
  AddTimeOption
  { addTimeOptionCreated = Nothing
  , addTimeOptionTime
  , addTimeOptionUserName = Nothing
  }

-- ** AnnotatedTag
-- | AnnotatedTag
-- AnnotatedTag represents an annotated tag
data AnnotatedTag = AnnotatedTag
  { annotatedTagMessage :: !(Maybe Text) -- ^ "message"
  , annotatedTagObject :: !(Maybe AnnotatedTagObject) -- ^ "object"
  , annotatedTagSha :: !(Maybe Text) -- ^ "sha"
  , annotatedTagTag :: !(Maybe Text) -- ^ "tag"
  , annotatedTagTagger :: !(Maybe CommitUser) -- ^ "tagger"
  , annotatedTagUrl :: !(Maybe Text) -- ^ "url"
  , annotatedTagVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnnotatedTag
instance A.FromJSON AnnotatedTag where
  parseJSON = A.withObject "AnnotatedTag" $ \o ->
    AnnotatedTag
      <$> (o .:? "message")
      <*> (o .:? "object")
      <*> (o .:? "sha")
      <*> (o .:? "tag")
      <*> (o .:? "tagger")
      <*> (o .:? "url")
      <*> (o .:? "verification")

-- | ToJSON AnnotatedTag
instance A.ToJSON AnnotatedTag where
  toJSON AnnotatedTag {..} =
   _omitNulls
      [ "message" .= annotatedTagMessage
      , "object" .= annotatedTagObject
      , "sha" .= annotatedTagSha
      , "tag" .= annotatedTagTag
      , "tagger" .= annotatedTagTagger
      , "url" .= annotatedTagUrl
      , "verification" .= annotatedTagVerification
      ]


-- | Construct a value of type 'AnnotatedTag' (by applying it's required fields, if any)
mkAnnotatedTag
  :: AnnotatedTag
mkAnnotatedTag =
  AnnotatedTag
  { annotatedTagMessage = Nothing
  , annotatedTagObject = Nothing
  , annotatedTagSha = Nothing
  , annotatedTagTag = Nothing
  , annotatedTagTagger = Nothing
  , annotatedTagUrl = Nothing
  , annotatedTagVerification = Nothing
  }

-- ** AnnotatedTagObject
-- | AnnotatedTagObject
-- AnnotatedTagObject contains meta information of the tag object
data AnnotatedTagObject = AnnotatedTagObject
  { annotatedTagObjectSha :: !(Maybe Text) -- ^ "sha"
  , annotatedTagObjectType :: !(Maybe Text) -- ^ "type"
  , annotatedTagObjectUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AnnotatedTagObject
instance A.FromJSON AnnotatedTagObject where
  parseJSON = A.withObject "AnnotatedTagObject" $ \o ->
    AnnotatedTagObject
      <$> (o .:? "sha")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON AnnotatedTagObject
instance A.ToJSON AnnotatedTagObject where
  toJSON AnnotatedTagObject {..} =
   _omitNulls
      [ "sha" .= annotatedTagObjectSha
      , "type" .= annotatedTagObjectType
      , "url" .= annotatedTagObjectUrl
      ]


-- | Construct a value of type 'AnnotatedTagObject' (by applying it's required fields, if any)
mkAnnotatedTagObject
  :: AnnotatedTagObject
mkAnnotatedTagObject =
  AnnotatedTagObject
  { annotatedTagObjectSha = Nothing
  , annotatedTagObjectType = Nothing
  , annotatedTagObjectUrl = Nothing
  }

-- ** Attachment
-- | Attachment
-- Attachment a generic attachment
data Attachment = Attachment
  { attachmentBrowserDownloadUrl :: !(Maybe Text) -- ^ "browser_download_url"
  , attachmentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , attachmentDownloadCount :: !(Maybe Integer) -- ^ "download_count"
  , attachmentId :: !(Maybe Integer) -- ^ "id"
  , attachmentName :: !(Maybe Text) -- ^ "name"
  , attachmentSize :: !(Maybe Integer) -- ^ "size"
  , attachmentUuid :: !(Maybe Text) -- ^ "uuid"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Attachment
instance A.FromJSON Attachment where
  parseJSON = A.withObject "Attachment" $ \o ->
    Attachment
      <$> (o .:? "browser_download_url")
      <*> (o .:? "created_at")
      <*> (o .:? "download_count")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "size")
      <*> (o .:? "uuid")

-- | ToJSON Attachment
instance A.ToJSON Attachment where
  toJSON Attachment {..} =
   _omitNulls
      [ "browser_download_url" .= attachmentBrowserDownloadUrl
      , "created_at" .= attachmentCreatedAt
      , "download_count" .= attachmentDownloadCount
      , "id" .= attachmentId
      , "name" .= attachmentName
      , "size" .= attachmentSize
      , "uuid" .= attachmentUuid
      ]


-- | Construct a value of type 'Attachment' (by applying it's required fields, if any)
mkAttachment
  :: Attachment
mkAttachment =
  Attachment
  { attachmentBrowserDownloadUrl = Nothing
  , attachmentCreatedAt = Nothing
  , attachmentDownloadCount = Nothing
  , attachmentId = Nothing
  , attachmentName = Nothing
  , attachmentSize = Nothing
  , attachmentUuid = Nothing
  }

-- ** Branch
-- | Branch
-- Branch represents a repository branch
data Branch = Branch
  { branchCommit :: !(Maybe PayloadCommit) -- ^ "commit"
  , branchEffectiveBranchProtectionName :: !(Maybe Text) -- ^ "effective_branch_protection_name"
  , branchEnableStatusCheck :: !(Maybe Bool) -- ^ "enable_status_check"
  , branchName :: !(Maybe Text) -- ^ "name"
  , branchProtected :: !(Maybe Bool) -- ^ "protected"
  , branchRequiredApprovals :: !(Maybe Integer) -- ^ "required_approvals"
  , branchStatusCheckContexts :: !(Maybe [Text]) -- ^ "status_check_contexts"
  , branchUserCanMerge :: !(Maybe Bool) -- ^ "user_can_merge"
  , branchUserCanPush :: !(Maybe Bool) -- ^ "user_can_push"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Branch
instance A.FromJSON Branch where
  parseJSON = A.withObject "Branch" $ \o ->
    Branch
      <$> (o .:? "commit")
      <*> (o .:? "effective_branch_protection_name")
      <*> (o .:? "enable_status_check")
      <*> (o .:? "name")
      <*> (o .:? "protected")
      <*> (o .:? "required_approvals")
      <*> (o .:? "status_check_contexts")
      <*> (o .:? "user_can_merge")
      <*> (o .:? "user_can_push")

-- | ToJSON Branch
instance A.ToJSON Branch where
  toJSON Branch {..} =
   _omitNulls
      [ "commit" .= branchCommit
      , "effective_branch_protection_name" .= branchEffectiveBranchProtectionName
      , "enable_status_check" .= branchEnableStatusCheck
      , "name" .= branchName
      , "protected" .= branchProtected
      , "required_approvals" .= branchRequiredApprovals
      , "status_check_contexts" .= branchStatusCheckContexts
      , "user_can_merge" .= branchUserCanMerge
      , "user_can_push" .= branchUserCanPush
      ]


-- | Construct a value of type 'Branch' (by applying it's required fields, if any)
mkBranch
  :: Branch
mkBranch =
  Branch
  { branchCommit = Nothing
  , branchEffectiveBranchProtectionName = Nothing
  , branchEnableStatusCheck = Nothing
  , branchName = Nothing
  , branchProtected = Nothing
  , branchRequiredApprovals = Nothing
  , branchStatusCheckContexts = Nothing
  , branchUserCanMerge = Nothing
  , branchUserCanPush = Nothing
  }

-- ** BranchProtection
-- | BranchProtection
-- BranchProtection represents a branch protection for a repository
data BranchProtection = BranchProtection
  { branchProtectionApprovalsWhitelistTeams :: !(Maybe [Text]) -- ^ "approvals_whitelist_teams"
  , branchProtectionApprovalsWhitelistUsername :: !(Maybe [Text]) -- ^ "approvals_whitelist_username"
  , branchProtectionBlockOnOfficialReviewRequests :: !(Maybe Bool) -- ^ "block_on_official_review_requests"
  , branchProtectionBlockOnOutdatedBranch :: !(Maybe Bool) -- ^ "block_on_outdated_branch"
  , branchProtectionBlockOnRejectedReviews :: !(Maybe Bool) -- ^ "block_on_rejected_reviews"
  , branchProtectionBranchName :: !(Maybe Text) -- ^ "branch_name" - Deprecated: true
  , branchProtectionCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , branchProtectionDismissStaleApprovals :: !(Maybe Bool) -- ^ "dismiss_stale_approvals"
  , branchProtectionEnableApprovalsWhitelist :: !(Maybe Bool) -- ^ "enable_approvals_whitelist"
  , branchProtectionEnableMergeWhitelist :: !(Maybe Bool) -- ^ "enable_merge_whitelist"
  , branchProtectionEnablePush :: !(Maybe Bool) -- ^ "enable_push"
  , branchProtectionEnablePushWhitelist :: !(Maybe Bool) -- ^ "enable_push_whitelist"
  , branchProtectionEnableStatusCheck :: !(Maybe Bool) -- ^ "enable_status_check"
  , branchProtectionMergeWhitelistTeams :: !(Maybe [Text]) -- ^ "merge_whitelist_teams"
  , branchProtectionMergeWhitelistUsernames :: !(Maybe [Text]) -- ^ "merge_whitelist_usernames"
  , branchProtectionProtectedFilePatterns :: !(Maybe Text) -- ^ "protected_file_patterns"
  , branchProtectionPushWhitelistDeployKeys :: !(Maybe Bool) -- ^ "push_whitelist_deploy_keys"
  , branchProtectionPushWhitelistTeams :: !(Maybe [Text]) -- ^ "push_whitelist_teams"
  , branchProtectionPushWhitelistUsernames :: !(Maybe [Text]) -- ^ "push_whitelist_usernames"
  , branchProtectionRequireSignedCommits :: !(Maybe Bool) -- ^ "require_signed_commits"
  , branchProtectionRequiredApprovals :: !(Maybe Integer) -- ^ "required_approvals"
  , branchProtectionRuleName :: !(Maybe Text) -- ^ "rule_name"
  , branchProtectionStatusCheckContexts :: !(Maybe [Text]) -- ^ "status_check_contexts"
  , branchProtectionUnprotectedFilePatterns :: !(Maybe Text) -- ^ "unprotected_file_patterns"
  , branchProtectionUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchProtection
instance A.FromJSON BranchProtection where
  parseJSON = A.withObject "BranchProtection" $ \o ->
    BranchProtection
      <$> (o .:? "approvals_whitelist_teams")
      <*> (o .:? "approvals_whitelist_username")
      <*> (o .:? "block_on_official_review_requests")
      <*> (o .:? "block_on_outdated_branch")
      <*> (o .:? "block_on_rejected_reviews")
      <*> (o .:? "branch_name")
      <*> (o .:? "created_at")
      <*> (o .:? "dismiss_stale_approvals")
      <*> (o .:? "enable_approvals_whitelist")
      <*> (o .:? "enable_merge_whitelist")
      <*> (o .:? "enable_push")
      <*> (o .:? "enable_push_whitelist")
      <*> (o .:? "enable_status_check")
      <*> (o .:? "merge_whitelist_teams")
      <*> (o .:? "merge_whitelist_usernames")
      <*> (o .:? "protected_file_patterns")
      <*> (o .:? "push_whitelist_deploy_keys")
      <*> (o .:? "push_whitelist_teams")
      <*> (o .:? "push_whitelist_usernames")
      <*> (o .:? "require_signed_commits")
      <*> (o .:? "required_approvals")
      <*> (o .:? "rule_name")
      <*> (o .:? "status_check_contexts")
      <*> (o .:? "unprotected_file_patterns")
      <*> (o .:? "updated_at")

-- | ToJSON BranchProtection
instance A.ToJSON BranchProtection where
  toJSON BranchProtection {..} =
   _omitNulls
      [ "approvals_whitelist_teams" .= branchProtectionApprovalsWhitelistTeams
      , "approvals_whitelist_username" .= branchProtectionApprovalsWhitelistUsername
      , "block_on_official_review_requests" .= branchProtectionBlockOnOfficialReviewRequests
      , "block_on_outdated_branch" .= branchProtectionBlockOnOutdatedBranch
      , "block_on_rejected_reviews" .= branchProtectionBlockOnRejectedReviews
      , "branch_name" .= branchProtectionBranchName
      , "created_at" .= branchProtectionCreatedAt
      , "dismiss_stale_approvals" .= branchProtectionDismissStaleApprovals
      , "enable_approvals_whitelist" .= branchProtectionEnableApprovalsWhitelist
      , "enable_merge_whitelist" .= branchProtectionEnableMergeWhitelist
      , "enable_push" .= branchProtectionEnablePush
      , "enable_push_whitelist" .= branchProtectionEnablePushWhitelist
      , "enable_status_check" .= branchProtectionEnableStatusCheck
      , "merge_whitelist_teams" .= branchProtectionMergeWhitelistTeams
      , "merge_whitelist_usernames" .= branchProtectionMergeWhitelistUsernames
      , "protected_file_patterns" .= branchProtectionProtectedFilePatterns
      , "push_whitelist_deploy_keys" .= branchProtectionPushWhitelistDeployKeys
      , "push_whitelist_teams" .= branchProtectionPushWhitelistTeams
      , "push_whitelist_usernames" .= branchProtectionPushWhitelistUsernames
      , "require_signed_commits" .= branchProtectionRequireSignedCommits
      , "required_approvals" .= branchProtectionRequiredApprovals
      , "rule_name" .= branchProtectionRuleName
      , "status_check_contexts" .= branchProtectionStatusCheckContexts
      , "unprotected_file_patterns" .= branchProtectionUnprotectedFilePatterns
      , "updated_at" .= branchProtectionUpdatedAt
      ]


-- | Construct a value of type 'BranchProtection' (by applying it's required fields, if any)
mkBranchProtection
  :: BranchProtection
mkBranchProtection =
  BranchProtection
  { branchProtectionApprovalsWhitelistTeams = Nothing
  , branchProtectionApprovalsWhitelistUsername = Nothing
  , branchProtectionBlockOnOfficialReviewRequests = Nothing
  , branchProtectionBlockOnOutdatedBranch = Nothing
  , branchProtectionBlockOnRejectedReviews = Nothing
  , branchProtectionBranchName = Nothing
  , branchProtectionCreatedAt = Nothing
  , branchProtectionDismissStaleApprovals = Nothing
  , branchProtectionEnableApprovalsWhitelist = Nothing
  , branchProtectionEnableMergeWhitelist = Nothing
  , branchProtectionEnablePush = Nothing
  , branchProtectionEnablePushWhitelist = Nothing
  , branchProtectionEnableStatusCheck = Nothing
  , branchProtectionMergeWhitelistTeams = Nothing
  , branchProtectionMergeWhitelistUsernames = Nothing
  , branchProtectionProtectedFilePatterns = Nothing
  , branchProtectionPushWhitelistDeployKeys = Nothing
  , branchProtectionPushWhitelistTeams = Nothing
  , branchProtectionPushWhitelistUsernames = Nothing
  , branchProtectionRequireSignedCommits = Nothing
  , branchProtectionRequiredApprovals = Nothing
  , branchProtectionRuleName = Nothing
  , branchProtectionStatusCheckContexts = Nothing
  , branchProtectionUnprotectedFilePatterns = Nothing
  , branchProtectionUpdatedAt = Nothing
  }

-- ** ChangeFileOperation
-- | ChangeFileOperation
-- ChangeFileOperation for creating, updating or deleting a file
data ChangeFileOperation = ChangeFileOperation
  { changeFileOperationContent :: !(Maybe Text) -- ^ "content" - new or updated file content, must be base64 encoded
  , changeFileOperationFromPath :: !(Maybe Text) -- ^ "from_path" - old path of the file to move
  , changeFileOperationOperation :: !(E'Operation) -- ^ /Required/ "operation" - indicates what to do with the file
  , changeFileOperationPath :: !(Text) -- ^ /Required/ "path" - path to the existing or new file
  , changeFileOperationSha :: !(Maybe Text) -- ^ "sha" - sha is the SHA for the file that already exists, required for update or delete
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangeFileOperation
instance A.FromJSON ChangeFileOperation where
  parseJSON = A.withObject "ChangeFileOperation" $ \o ->
    ChangeFileOperation
      <$> (o .:? "content")
      <*> (o .:? "from_path")
      <*> (o .:  "operation")
      <*> (o .:  "path")
      <*> (o .:? "sha")

-- | ToJSON ChangeFileOperation
instance A.ToJSON ChangeFileOperation where
  toJSON ChangeFileOperation {..} =
   _omitNulls
      [ "content" .= changeFileOperationContent
      , "from_path" .= changeFileOperationFromPath
      , "operation" .= changeFileOperationOperation
      , "path" .= changeFileOperationPath
      , "sha" .= changeFileOperationSha
      ]


-- | Construct a value of type 'ChangeFileOperation' (by applying it's required fields, if any)
mkChangeFileOperation
  :: E'Operation -- ^ 'changeFileOperationOperation': indicates what to do with the file
  -> Text -- ^ 'changeFileOperationPath': path to the existing or new file
  -> ChangeFileOperation
mkChangeFileOperation changeFileOperationOperation changeFileOperationPath =
  ChangeFileOperation
  { changeFileOperationContent = Nothing
  , changeFileOperationFromPath = Nothing
  , changeFileOperationOperation
  , changeFileOperationPath
  , changeFileOperationSha = Nothing
  }

-- ** ChangeFilesOptions
-- | ChangeFilesOptions
-- ChangeFilesOptions options for creating, updating or deleting multiple files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data ChangeFilesOptions = ChangeFilesOptions
  { changeFilesOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , changeFilesOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , changeFilesOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , changeFilesOptionsDates :: !(Maybe CommitDateOptions) -- ^ "dates"
  , changeFilesOptionsFiles :: !([ChangeFileOperation]) -- ^ /Required/ "files" - list of file operations
  , changeFilesOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , changeFilesOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , changeFilesOptionsSignoff :: !(Maybe Bool) -- ^ "signoff" - Add a Signed-off-by trailer by the committer at the end of the commit log message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangeFilesOptions
instance A.FromJSON ChangeFilesOptions where
  parseJSON = A.withObject "ChangeFilesOptions" $ \o ->
    ChangeFilesOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:? "dates")
      <*> (o .:  "files")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:? "signoff")

-- | ToJSON ChangeFilesOptions
instance A.ToJSON ChangeFilesOptions where
  toJSON ChangeFilesOptions {..} =
   _omitNulls
      [ "author" .= changeFilesOptionsAuthor
      , "branch" .= changeFilesOptionsBranch
      , "committer" .= changeFilesOptionsCommitter
      , "dates" .= changeFilesOptionsDates
      , "files" .= changeFilesOptionsFiles
      , "message" .= changeFilesOptionsMessage
      , "new_branch" .= changeFilesOptionsNewBranch
      , "signoff" .= changeFilesOptionsSignoff
      ]


-- | Construct a value of type 'ChangeFilesOptions' (by applying it's required fields, if any)
mkChangeFilesOptions
  :: [ChangeFileOperation] -- ^ 'changeFilesOptionsFiles': list of file operations
  -> ChangeFilesOptions
mkChangeFilesOptions changeFilesOptionsFiles =
  ChangeFilesOptions
  { changeFilesOptionsAuthor = Nothing
  , changeFilesOptionsBranch = Nothing
  , changeFilesOptionsCommitter = Nothing
  , changeFilesOptionsDates = Nothing
  , changeFilesOptionsFiles
  , changeFilesOptionsMessage = Nothing
  , changeFilesOptionsNewBranch = Nothing
  , changeFilesOptionsSignoff = Nothing
  }

-- ** ChangedFile
-- | ChangedFile
-- ChangedFile store information about files affected by the pull request
data ChangedFile = ChangedFile
  { changedFileAdditions :: !(Maybe Integer) -- ^ "additions"
  , changedFileChanges :: !(Maybe Integer) -- ^ "changes"
  , changedFileContentsUrl :: !(Maybe Text) -- ^ "contents_url"
  , changedFileDeletions :: !(Maybe Integer) -- ^ "deletions"
  , changedFileFilename :: !(Maybe Text) -- ^ "filename"
  , changedFileHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , changedFilePreviousFilename :: !(Maybe Text) -- ^ "previous_filename"
  , changedFileRawUrl :: !(Maybe Text) -- ^ "raw_url"
  , changedFileStatus :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangedFile
instance A.FromJSON ChangedFile where
  parseJSON = A.withObject "ChangedFile" $ \o ->
    ChangedFile
      <$> (o .:? "additions")
      <*> (o .:? "changes")
      <*> (o .:? "contents_url")
      <*> (o .:? "deletions")
      <*> (o .:? "filename")
      <*> (o .:? "html_url")
      <*> (o .:? "previous_filename")
      <*> (o .:? "raw_url")
      <*> (o .:? "status")

-- | ToJSON ChangedFile
instance A.ToJSON ChangedFile where
  toJSON ChangedFile {..} =
   _omitNulls
      [ "additions" .= changedFileAdditions
      , "changes" .= changedFileChanges
      , "contents_url" .= changedFileContentsUrl
      , "deletions" .= changedFileDeletions
      , "filename" .= changedFileFilename
      , "html_url" .= changedFileHtmlUrl
      , "previous_filename" .= changedFilePreviousFilename
      , "raw_url" .= changedFileRawUrl
      , "status" .= changedFileStatus
      ]


-- | Construct a value of type 'ChangedFile' (by applying it's required fields, if any)
mkChangedFile
  :: ChangedFile
mkChangedFile =
  ChangedFile
  { changedFileAdditions = Nothing
  , changedFileChanges = Nothing
  , changedFileContentsUrl = Nothing
  , changedFileDeletions = Nothing
  , changedFileFilename = Nothing
  , changedFileHtmlUrl = Nothing
  , changedFilePreviousFilename = Nothing
  , changedFileRawUrl = Nothing
  , changedFileStatus = Nothing
  }

-- ** CombinedStatus
-- | CombinedStatus
-- CombinedStatus holds the combined state of several statuses for a single commit
data CombinedStatus = CombinedStatus
  { combinedStatusCommitUrl :: !(Maybe Text) -- ^ "commit_url"
  , combinedStatusRepository :: !(Maybe Repository) -- ^ "repository"
  , combinedStatusSha :: !(Maybe Text) -- ^ "sha"
  , combinedStatusState :: !(Maybe Text) -- ^ "state" - CommitStatusState holds the state of a CommitStatus It can be \&quot;pending\&quot;, \&quot;success\&quot;, \&quot;error\&quot;, \&quot;failure\&quot;, and \&quot;warning\&quot;
  , combinedStatusStatuses :: !(Maybe [CommitStatus]) -- ^ "statuses"
  , combinedStatusTotalCount :: !(Maybe Integer) -- ^ "total_count"
  , combinedStatusUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CombinedStatus
instance A.FromJSON CombinedStatus where
  parseJSON = A.withObject "CombinedStatus" $ \o ->
    CombinedStatus
      <$> (o .:? "commit_url")
      <*> (o .:? "repository")
      <*> (o .:? "sha")
      <*> (o .:? "state")
      <*> (o .:? "statuses")
      <*> (o .:? "total_count")
      <*> (o .:? "url")

-- | ToJSON CombinedStatus
instance A.ToJSON CombinedStatus where
  toJSON CombinedStatus {..} =
   _omitNulls
      [ "commit_url" .= combinedStatusCommitUrl
      , "repository" .= combinedStatusRepository
      , "sha" .= combinedStatusSha
      , "state" .= combinedStatusState
      , "statuses" .= combinedStatusStatuses
      , "total_count" .= combinedStatusTotalCount
      , "url" .= combinedStatusUrl
      ]


-- | Construct a value of type 'CombinedStatus' (by applying it's required fields, if any)
mkCombinedStatus
  :: CombinedStatus
mkCombinedStatus =
  CombinedStatus
  { combinedStatusCommitUrl = Nothing
  , combinedStatusRepository = Nothing
  , combinedStatusSha = Nothing
  , combinedStatusState = Nothing
  , combinedStatusStatuses = Nothing
  , combinedStatusTotalCount = Nothing
  , combinedStatusUrl = Nothing
  }

-- ** Comment
-- | Comment
-- Comment represents a comment on a commit or issue
data Comment = Comment
  { commentAssets :: !(Maybe [Attachment]) -- ^ "assets"
  , commentBody :: !(Maybe Text) -- ^ "body"
  , commentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , commentHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , commentId :: !(Maybe Integer) -- ^ "id"
  , commentIssueUrl :: !(Maybe Text) -- ^ "issue_url"
  , commentOriginalAuthor :: !(Maybe Text) -- ^ "original_author"
  , commentOriginalAuthorId :: !(Maybe Integer) -- ^ "original_author_id"
  , commentPullRequestUrl :: !(Maybe Text) -- ^ "pull_request_url"
  , commentUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , commentUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Comment
instance A.FromJSON Comment where
  parseJSON = A.withObject "Comment" $ \o ->
    Comment
      <$> (o .:? "assets")
      <*> (o .:? "body")
      <*> (o .:? "created_at")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "issue_url")
      <*> (o .:? "original_author")
      <*> (o .:? "original_author_id")
      <*> (o .:? "pull_request_url")
      <*> (o .:? "updated_at")
      <*> (o .:? "user")

-- | ToJSON Comment
instance A.ToJSON Comment where
  toJSON Comment {..} =
   _omitNulls
      [ "assets" .= commentAssets
      , "body" .= commentBody
      , "created_at" .= commentCreatedAt
      , "html_url" .= commentHtmlUrl
      , "id" .= commentId
      , "issue_url" .= commentIssueUrl
      , "original_author" .= commentOriginalAuthor
      , "original_author_id" .= commentOriginalAuthorId
      , "pull_request_url" .= commentPullRequestUrl
      , "updated_at" .= commentUpdatedAt
      , "user" .= commentUser
      ]


-- | Construct a value of type 'Comment' (by applying it's required fields, if any)
mkComment
  :: Comment
mkComment =
  Comment
  { commentAssets = Nothing
  , commentBody = Nothing
  , commentCreatedAt = Nothing
  , commentHtmlUrl = Nothing
  , commentId = Nothing
  , commentIssueUrl = Nothing
  , commentOriginalAuthor = Nothing
  , commentOriginalAuthorId = Nothing
  , commentPullRequestUrl = Nothing
  , commentUpdatedAt = Nothing
  , commentUser = Nothing
  }

-- ** Commit
-- | Commit
-- Commit contains information generated from a Git commit.
-- 
data Commit = Commit
  { commitAuthor :: !(Maybe User) -- ^ "author"
  , commitCommit :: !(Maybe RepoCommit) -- ^ "commit"
  , commitCommitter :: !(Maybe User) -- ^ "committer"
  , commitCreated :: !(Maybe DateTime) -- ^ "created"
  , commitFiles :: !(Maybe [CommitAffectedFiles]) -- ^ "files"
  , commitHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , commitParents :: !(Maybe [CommitMeta]) -- ^ "parents"
  , commitSha :: !(Maybe Text) -- ^ "sha"
  , commitStats :: !(Maybe CommitStats) -- ^ "stats"
  , commitUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Commit
instance A.FromJSON Commit where
  parseJSON = A.withObject "Commit" $ \o ->
    Commit
      <$> (o .:? "author")
      <*> (o .:? "commit")
      <*> (o .:? "committer")
      <*> (o .:? "created")
      <*> (o .:? "files")
      <*> (o .:? "html_url")
      <*> (o .:? "parents")
      <*> (o .:? "sha")
      <*> (o .:? "stats")
      <*> (o .:? "url")

-- | ToJSON Commit
instance A.ToJSON Commit where
  toJSON Commit {..} =
   _omitNulls
      [ "author" .= commitAuthor
      , "commit" .= commitCommit
      , "committer" .= commitCommitter
      , "created" .= commitCreated
      , "files" .= commitFiles
      , "html_url" .= commitHtmlUrl
      , "parents" .= commitParents
      , "sha" .= commitSha
      , "stats" .= commitStats
      , "url" .= commitUrl
      ]


-- | Construct a value of type 'Commit' (by applying it's required fields, if any)
mkCommit
  :: Commit
mkCommit =
  Commit
  { commitAuthor = Nothing
  , commitCommit = Nothing
  , commitCommitter = Nothing
  , commitCreated = Nothing
  , commitFiles = Nothing
  , commitHtmlUrl = Nothing
  , commitParents = Nothing
  , commitSha = Nothing
  , commitStats = Nothing
  , commitUrl = Nothing
  }

-- ** CommitAffectedFiles
-- | CommitAffectedFiles
-- CommitAffectedFiles store information about files affected by the commit
data CommitAffectedFiles = CommitAffectedFiles
  { commitAffectedFilesFilename :: !(Maybe Text) -- ^ "filename"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitAffectedFiles
instance A.FromJSON CommitAffectedFiles where
  parseJSON = A.withObject "CommitAffectedFiles" $ \o ->
    CommitAffectedFiles
      <$> (o .:? "filename")

-- | ToJSON CommitAffectedFiles
instance A.ToJSON CommitAffectedFiles where
  toJSON CommitAffectedFiles {..} =
   _omitNulls
      [ "filename" .= commitAffectedFilesFilename
      ]


-- | Construct a value of type 'CommitAffectedFiles' (by applying it's required fields, if any)
mkCommitAffectedFiles
  :: CommitAffectedFiles
mkCommitAffectedFiles =
  CommitAffectedFiles
  { commitAffectedFilesFilename = Nothing
  }

-- ** CommitDateOptions
-- | CommitDateOptions
-- CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE
data CommitDateOptions = CommitDateOptions
  { commitDateOptionsAuthor :: !(Maybe DateTime) -- ^ "author"
  , commitDateOptionsCommitter :: !(Maybe DateTime) -- ^ "committer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitDateOptions
instance A.FromJSON CommitDateOptions where
  parseJSON = A.withObject "CommitDateOptions" $ \o ->
    CommitDateOptions
      <$> (o .:? "author")
      <*> (o .:? "committer")

-- | ToJSON CommitDateOptions
instance A.ToJSON CommitDateOptions where
  toJSON CommitDateOptions {..} =
   _omitNulls
      [ "author" .= commitDateOptionsAuthor
      , "committer" .= commitDateOptionsCommitter
      ]


-- | Construct a value of type 'CommitDateOptions' (by applying it's required fields, if any)
mkCommitDateOptions
  :: CommitDateOptions
mkCommitDateOptions =
  CommitDateOptions
  { commitDateOptionsAuthor = Nothing
  , commitDateOptionsCommitter = Nothing
  }

-- ** CommitMeta
-- | CommitMeta
-- CommitMeta contains meta information of a commit in terms of API.
-- 
data CommitMeta = CommitMeta
  { commitMetaCreated :: !(Maybe DateTime) -- ^ "created"
  , commitMetaSha :: !(Maybe Text) -- ^ "sha"
  , commitMetaUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitMeta
instance A.FromJSON CommitMeta where
  parseJSON = A.withObject "CommitMeta" $ \o ->
    CommitMeta
      <$> (o .:? "created")
      <*> (o .:? "sha")
      <*> (o .:? "url")

-- | ToJSON CommitMeta
instance A.ToJSON CommitMeta where
  toJSON CommitMeta {..} =
   _omitNulls
      [ "created" .= commitMetaCreated
      , "sha" .= commitMetaSha
      , "url" .= commitMetaUrl
      ]


-- | Construct a value of type 'CommitMeta' (by applying it's required fields, if any)
mkCommitMeta
  :: CommitMeta
mkCommitMeta =
  CommitMeta
  { commitMetaCreated = Nothing
  , commitMetaSha = Nothing
  , commitMetaUrl = Nothing
  }

-- ** CommitStats
-- | CommitStats
-- CommitStats is statistics for a RepoCommit
data CommitStats = CommitStats
  { commitStatsAdditions :: !(Maybe Integer) -- ^ "additions"
  , commitStatsDeletions :: !(Maybe Integer) -- ^ "deletions"
  , commitStatsTotal :: !(Maybe Integer) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitStats
instance A.FromJSON CommitStats where
  parseJSON = A.withObject "CommitStats" $ \o ->
    CommitStats
      <$> (o .:? "additions")
      <*> (o .:? "deletions")
      <*> (o .:? "total")

-- | ToJSON CommitStats
instance A.ToJSON CommitStats where
  toJSON CommitStats {..} =
   _omitNulls
      [ "additions" .= commitStatsAdditions
      , "deletions" .= commitStatsDeletions
      , "total" .= commitStatsTotal
      ]


-- | Construct a value of type 'CommitStats' (by applying it's required fields, if any)
mkCommitStats
  :: CommitStats
mkCommitStats =
  CommitStats
  { commitStatsAdditions = Nothing
  , commitStatsDeletions = Nothing
  , commitStatsTotal = Nothing
  }

-- ** CommitStatus
-- | CommitStatus
-- CommitStatus holds a single status of a single Commit
data CommitStatus = CommitStatus
  { commitStatusContext :: !(Maybe Text) -- ^ "context"
  , commitStatusCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , commitStatusCreator :: !(Maybe User) -- ^ "creator"
  , commitStatusDescription :: !(Maybe Text) -- ^ "description"
  , commitStatusId :: !(Maybe Integer) -- ^ "id"
  , commitStatusStatus :: !(Maybe Text) -- ^ "status" - CommitStatusState holds the state of a CommitStatus It can be \&quot;pending\&quot;, \&quot;success\&quot;, \&quot;error\&quot;, \&quot;failure\&quot;, and \&quot;warning\&quot;
  , commitStatusTargetUrl :: !(Maybe Text) -- ^ "target_url"
  , commitStatusUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , commitStatusUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitStatus
instance A.FromJSON CommitStatus where
  parseJSON = A.withObject "CommitStatus" $ \o ->
    CommitStatus
      <$> (o .:? "context")
      <*> (o .:? "created_at")
      <*> (o .:? "creator")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "status")
      <*> (o .:? "target_url")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")

-- | ToJSON CommitStatus
instance A.ToJSON CommitStatus where
  toJSON CommitStatus {..} =
   _omitNulls
      [ "context" .= commitStatusContext
      , "created_at" .= commitStatusCreatedAt
      , "creator" .= commitStatusCreator
      , "description" .= commitStatusDescription
      , "id" .= commitStatusId
      , "status" .= commitStatusStatus
      , "target_url" .= commitStatusTargetUrl
      , "updated_at" .= commitStatusUpdatedAt
      , "url" .= commitStatusUrl
      ]


-- | Construct a value of type 'CommitStatus' (by applying it's required fields, if any)
mkCommitStatus
  :: CommitStatus
mkCommitStatus =
  CommitStatus
  { commitStatusContext = Nothing
  , commitStatusCreatedAt = Nothing
  , commitStatusCreator = Nothing
  , commitStatusDescription = Nothing
  , commitStatusId = Nothing
  , commitStatusStatus = Nothing
  , commitStatusTargetUrl = Nothing
  , commitStatusUpdatedAt = Nothing
  , commitStatusUrl = Nothing
  }

-- ** CommitUser
-- | CommitUser
-- CommitUser contains information of a user in the context of a commit.
-- 
data CommitUser = CommitUser
  { commitUserDate :: !(Maybe Text) -- ^ "date"
  , commitUserEmail :: !(Maybe Text) -- ^ "email"
  , commitUserName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CommitUser
instance A.FromJSON CommitUser where
  parseJSON = A.withObject "CommitUser" $ \o ->
    CommitUser
      <$> (o .:? "date")
      <*> (o .:? "email")
      <*> (o .:? "name")

-- | ToJSON CommitUser
instance A.ToJSON CommitUser where
  toJSON CommitUser {..} =
   _omitNulls
      [ "date" .= commitUserDate
      , "email" .= commitUserEmail
      , "name" .= commitUserName
      ]


-- | Construct a value of type 'CommitUser' (by applying it's required fields, if any)
mkCommitUser
  :: CommitUser
mkCommitUser =
  CommitUser
  { commitUserDate = Nothing
  , commitUserEmail = Nothing
  , commitUserName = Nothing
  }

-- ** ContentsResponse
-- | ContentsResponse
-- ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content
data ContentsResponse = ContentsResponse
  { contentsResponseLinks :: !(Maybe FileLinksResponse) -- ^ "_links"
  , contentsResponseContent :: !(Maybe Text) -- ^ "content" - &#x60;content&#x60; is populated when &#x60;type&#x60; is &#x60;file&#x60;, otherwise null
  , contentsResponseDownloadUrl :: !(Maybe Text) -- ^ "download_url"
  , contentsResponseEncoding :: !(Maybe Text) -- ^ "encoding" - &#x60;encoding&#x60; is populated when &#x60;type&#x60; is &#x60;file&#x60;, otherwise null
  , contentsResponseGitUrl :: !(Maybe Text) -- ^ "git_url"
  , contentsResponseHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , contentsResponseLastCommitSha :: !(Maybe Text) -- ^ "last_commit_sha"
  , contentsResponseName :: !(Maybe Text) -- ^ "name"
  , contentsResponsePath :: !(Maybe Text) -- ^ "path"
  , contentsResponseSha :: !(Maybe Text) -- ^ "sha"
  , contentsResponseSize :: !(Maybe Integer) -- ^ "size"
  , contentsResponseSubmoduleGitUrl :: !(Maybe Text) -- ^ "submodule_git_url" - &#x60;submodule_git_url&#x60; is populated when &#x60;type&#x60; is &#x60;submodule&#x60;, otherwise null
  , contentsResponseTarget :: !(Maybe Text) -- ^ "target" - &#x60;target&#x60; is populated when &#x60;type&#x60; is &#x60;symlink&#x60;, otherwise null
  , contentsResponseType :: !(Maybe Text) -- ^ "type" - &#x60;type&#x60; will be &#x60;file&#x60;, &#x60;dir&#x60;, &#x60;symlink&#x60;, or &#x60;submodule&#x60;
  , contentsResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContentsResponse
instance A.FromJSON ContentsResponse where
  parseJSON = A.withObject "ContentsResponse" $ \o ->
    ContentsResponse
      <$> (o .:? "_links")
      <*> (o .:? "content")
      <*> (o .:? "download_url")
      <*> (o .:? "encoding")
      <*> (o .:? "git_url")
      <*> (o .:? "html_url")
      <*> (o .:? "last_commit_sha")
      <*> (o .:? "name")
      <*> (o .:? "path")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "submodule_git_url")
      <*> (o .:? "target")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON ContentsResponse
instance A.ToJSON ContentsResponse where
  toJSON ContentsResponse {..} =
   _omitNulls
      [ "_links" .= contentsResponseLinks
      , "content" .= contentsResponseContent
      , "download_url" .= contentsResponseDownloadUrl
      , "encoding" .= contentsResponseEncoding
      , "git_url" .= contentsResponseGitUrl
      , "html_url" .= contentsResponseHtmlUrl
      , "last_commit_sha" .= contentsResponseLastCommitSha
      , "name" .= contentsResponseName
      , "path" .= contentsResponsePath
      , "sha" .= contentsResponseSha
      , "size" .= contentsResponseSize
      , "submodule_git_url" .= contentsResponseSubmoduleGitUrl
      , "target" .= contentsResponseTarget
      , "type" .= contentsResponseType
      , "url" .= contentsResponseUrl
      ]


-- | Construct a value of type 'ContentsResponse' (by applying it's required fields, if any)
mkContentsResponse
  :: ContentsResponse
mkContentsResponse =
  ContentsResponse
  { contentsResponseLinks = Nothing
  , contentsResponseContent = Nothing
  , contentsResponseDownloadUrl = Nothing
  , contentsResponseEncoding = Nothing
  , contentsResponseGitUrl = Nothing
  , contentsResponseHtmlUrl = Nothing
  , contentsResponseLastCommitSha = Nothing
  , contentsResponseName = Nothing
  , contentsResponsePath = Nothing
  , contentsResponseSha = Nothing
  , contentsResponseSize = Nothing
  , contentsResponseSubmoduleGitUrl = Nothing
  , contentsResponseTarget = Nothing
  , contentsResponseType = Nothing
  , contentsResponseUrl = Nothing
  }

-- ** CreateAccessTokenOption
-- | CreateAccessTokenOption
-- CreateAccessTokenOption options when create access token
data CreateAccessTokenOption = CreateAccessTokenOption
  { createAccessTokenOptionName :: !(Text) -- ^ /Required/ "name"
  , createAccessTokenOptionScopes :: !(Maybe [Text]) -- ^ "scopes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAccessTokenOption
instance A.FromJSON CreateAccessTokenOption where
  parseJSON = A.withObject "CreateAccessTokenOption" $ \o ->
    CreateAccessTokenOption
      <$> (o .:  "name")
      <*> (o .:? "scopes")

-- | ToJSON CreateAccessTokenOption
instance A.ToJSON CreateAccessTokenOption where
  toJSON CreateAccessTokenOption {..} =
   _omitNulls
      [ "name" .= createAccessTokenOptionName
      , "scopes" .= createAccessTokenOptionScopes
      ]


-- | Construct a value of type 'CreateAccessTokenOption' (by applying it's required fields, if any)
mkCreateAccessTokenOption
  :: Text -- ^ 'createAccessTokenOptionName' 
  -> CreateAccessTokenOption
mkCreateAccessTokenOption createAccessTokenOptionName =
  CreateAccessTokenOption
  { createAccessTokenOptionName
  , createAccessTokenOptionScopes = Nothing
  }

-- ** CreateBranchProtectionOption
-- | CreateBranchProtectionOption
-- CreateBranchProtectionOption options for creating a branch protection
data CreateBranchProtectionOption = CreateBranchProtectionOption
  { createBranchProtectionOptionApprovalsWhitelistTeams :: !(Maybe [Text]) -- ^ "approvals_whitelist_teams"
  , createBranchProtectionOptionApprovalsWhitelistUsername :: !(Maybe [Text]) -- ^ "approvals_whitelist_username"
  , createBranchProtectionOptionBlockOnOfficialReviewRequests :: !(Maybe Bool) -- ^ "block_on_official_review_requests"
  , createBranchProtectionOptionBlockOnOutdatedBranch :: !(Maybe Bool) -- ^ "block_on_outdated_branch"
  , createBranchProtectionOptionBlockOnRejectedReviews :: !(Maybe Bool) -- ^ "block_on_rejected_reviews"
  , createBranchProtectionOptionBranchName :: !(Maybe Text) -- ^ "branch_name" - Deprecated: true
  , createBranchProtectionOptionDismissStaleApprovals :: !(Maybe Bool) -- ^ "dismiss_stale_approvals"
  , createBranchProtectionOptionEnableApprovalsWhitelist :: !(Maybe Bool) -- ^ "enable_approvals_whitelist"
  , createBranchProtectionOptionEnableMergeWhitelist :: !(Maybe Bool) -- ^ "enable_merge_whitelist"
  , createBranchProtectionOptionEnablePush :: !(Maybe Bool) -- ^ "enable_push"
  , createBranchProtectionOptionEnablePushWhitelist :: !(Maybe Bool) -- ^ "enable_push_whitelist"
  , createBranchProtectionOptionEnableStatusCheck :: !(Maybe Bool) -- ^ "enable_status_check"
  , createBranchProtectionOptionMergeWhitelistTeams :: !(Maybe [Text]) -- ^ "merge_whitelist_teams"
  , createBranchProtectionOptionMergeWhitelistUsernames :: !(Maybe [Text]) -- ^ "merge_whitelist_usernames"
  , createBranchProtectionOptionProtectedFilePatterns :: !(Maybe Text) -- ^ "protected_file_patterns"
  , createBranchProtectionOptionPushWhitelistDeployKeys :: !(Maybe Bool) -- ^ "push_whitelist_deploy_keys"
  , createBranchProtectionOptionPushWhitelistTeams :: !(Maybe [Text]) -- ^ "push_whitelist_teams"
  , createBranchProtectionOptionPushWhitelistUsernames :: !(Maybe [Text]) -- ^ "push_whitelist_usernames"
  , createBranchProtectionOptionRequireSignedCommits :: !(Maybe Bool) -- ^ "require_signed_commits"
  , createBranchProtectionOptionRequiredApprovals :: !(Maybe Integer) -- ^ "required_approvals"
  , createBranchProtectionOptionRuleName :: !(Maybe Text) -- ^ "rule_name"
  , createBranchProtectionOptionStatusCheckContexts :: !(Maybe [Text]) -- ^ "status_check_contexts"
  , createBranchProtectionOptionUnprotectedFilePatterns :: !(Maybe Text) -- ^ "unprotected_file_patterns"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateBranchProtectionOption
instance A.FromJSON CreateBranchProtectionOption where
  parseJSON = A.withObject "CreateBranchProtectionOption" $ \o ->
    CreateBranchProtectionOption
      <$> (o .:? "approvals_whitelist_teams")
      <*> (o .:? "approvals_whitelist_username")
      <*> (o .:? "block_on_official_review_requests")
      <*> (o .:? "block_on_outdated_branch")
      <*> (o .:? "block_on_rejected_reviews")
      <*> (o .:? "branch_name")
      <*> (o .:? "dismiss_stale_approvals")
      <*> (o .:? "enable_approvals_whitelist")
      <*> (o .:? "enable_merge_whitelist")
      <*> (o .:? "enable_push")
      <*> (o .:? "enable_push_whitelist")
      <*> (o .:? "enable_status_check")
      <*> (o .:? "merge_whitelist_teams")
      <*> (o .:? "merge_whitelist_usernames")
      <*> (o .:? "protected_file_patterns")
      <*> (o .:? "push_whitelist_deploy_keys")
      <*> (o .:? "push_whitelist_teams")
      <*> (o .:? "push_whitelist_usernames")
      <*> (o .:? "require_signed_commits")
      <*> (o .:? "required_approvals")
      <*> (o .:? "rule_name")
      <*> (o .:? "status_check_contexts")
      <*> (o .:? "unprotected_file_patterns")

-- | ToJSON CreateBranchProtectionOption
instance A.ToJSON CreateBranchProtectionOption where
  toJSON CreateBranchProtectionOption {..} =
   _omitNulls
      [ "approvals_whitelist_teams" .= createBranchProtectionOptionApprovalsWhitelistTeams
      , "approvals_whitelist_username" .= createBranchProtectionOptionApprovalsWhitelistUsername
      , "block_on_official_review_requests" .= createBranchProtectionOptionBlockOnOfficialReviewRequests
      , "block_on_outdated_branch" .= createBranchProtectionOptionBlockOnOutdatedBranch
      , "block_on_rejected_reviews" .= createBranchProtectionOptionBlockOnRejectedReviews
      , "branch_name" .= createBranchProtectionOptionBranchName
      , "dismiss_stale_approvals" .= createBranchProtectionOptionDismissStaleApprovals
      , "enable_approvals_whitelist" .= createBranchProtectionOptionEnableApprovalsWhitelist
      , "enable_merge_whitelist" .= createBranchProtectionOptionEnableMergeWhitelist
      , "enable_push" .= createBranchProtectionOptionEnablePush
      , "enable_push_whitelist" .= createBranchProtectionOptionEnablePushWhitelist
      , "enable_status_check" .= createBranchProtectionOptionEnableStatusCheck
      , "merge_whitelist_teams" .= createBranchProtectionOptionMergeWhitelistTeams
      , "merge_whitelist_usernames" .= createBranchProtectionOptionMergeWhitelistUsernames
      , "protected_file_patterns" .= createBranchProtectionOptionProtectedFilePatterns
      , "push_whitelist_deploy_keys" .= createBranchProtectionOptionPushWhitelistDeployKeys
      , "push_whitelist_teams" .= createBranchProtectionOptionPushWhitelistTeams
      , "push_whitelist_usernames" .= createBranchProtectionOptionPushWhitelistUsernames
      , "require_signed_commits" .= createBranchProtectionOptionRequireSignedCommits
      , "required_approvals" .= createBranchProtectionOptionRequiredApprovals
      , "rule_name" .= createBranchProtectionOptionRuleName
      , "status_check_contexts" .= createBranchProtectionOptionStatusCheckContexts
      , "unprotected_file_patterns" .= createBranchProtectionOptionUnprotectedFilePatterns
      ]


-- | Construct a value of type 'CreateBranchProtectionOption' (by applying it's required fields, if any)
mkCreateBranchProtectionOption
  :: CreateBranchProtectionOption
mkCreateBranchProtectionOption =
  CreateBranchProtectionOption
  { createBranchProtectionOptionApprovalsWhitelistTeams = Nothing
  , createBranchProtectionOptionApprovalsWhitelistUsername = Nothing
  , createBranchProtectionOptionBlockOnOfficialReviewRequests = Nothing
  , createBranchProtectionOptionBlockOnOutdatedBranch = Nothing
  , createBranchProtectionOptionBlockOnRejectedReviews = Nothing
  , createBranchProtectionOptionBranchName = Nothing
  , createBranchProtectionOptionDismissStaleApprovals = Nothing
  , createBranchProtectionOptionEnableApprovalsWhitelist = Nothing
  , createBranchProtectionOptionEnableMergeWhitelist = Nothing
  , createBranchProtectionOptionEnablePush = Nothing
  , createBranchProtectionOptionEnablePushWhitelist = Nothing
  , createBranchProtectionOptionEnableStatusCheck = Nothing
  , createBranchProtectionOptionMergeWhitelistTeams = Nothing
  , createBranchProtectionOptionMergeWhitelistUsernames = Nothing
  , createBranchProtectionOptionProtectedFilePatterns = Nothing
  , createBranchProtectionOptionPushWhitelistDeployKeys = Nothing
  , createBranchProtectionOptionPushWhitelistTeams = Nothing
  , createBranchProtectionOptionPushWhitelistUsernames = Nothing
  , createBranchProtectionOptionRequireSignedCommits = Nothing
  , createBranchProtectionOptionRequiredApprovals = Nothing
  , createBranchProtectionOptionRuleName = Nothing
  , createBranchProtectionOptionStatusCheckContexts = Nothing
  , createBranchProtectionOptionUnprotectedFilePatterns = Nothing
  }

-- ** CreateBranchRepoOption
-- | CreateBranchRepoOption
-- CreateBranchRepoOption options when creating a branch in a repository
data CreateBranchRepoOption = CreateBranchRepoOption
  { createBranchRepoOptionNewBranchName :: !(Text) -- ^ /Required/ "new_branch_name" - Name of the branch to create
  , createBranchRepoOptionOldBranchName :: !(Maybe Text) -- ^ "old_branch_name" - Deprecated: true Name of the old branch to create from
  , createBranchRepoOptionOldRefName :: !(Maybe Text) -- ^ "old_ref_name" - Name of the old branch/tag/commit to create from
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateBranchRepoOption
instance A.FromJSON CreateBranchRepoOption where
  parseJSON = A.withObject "CreateBranchRepoOption" $ \o ->
    CreateBranchRepoOption
      <$> (o .:  "new_branch_name")
      <*> (o .:? "old_branch_name")
      <*> (o .:? "old_ref_name")

-- | ToJSON CreateBranchRepoOption
instance A.ToJSON CreateBranchRepoOption where
  toJSON CreateBranchRepoOption {..} =
   _omitNulls
      [ "new_branch_name" .= createBranchRepoOptionNewBranchName
      , "old_branch_name" .= createBranchRepoOptionOldBranchName
      , "old_ref_name" .= createBranchRepoOptionOldRefName
      ]


-- | Construct a value of type 'CreateBranchRepoOption' (by applying it's required fields, if any)
mkCreateBranchRepoOption
  :: Text -- ^ 'createBranchRepoOptionNewBranchName': Name of the branch to create
  -> CreateBranchRepoOption
mkCreateBranchRepoOption createBranchRepoOptionNewBranchName =
  CreateBranchRepoOption
  { createBranchRepoOptionNewBranchName
  , createBranchRepoOptionOldBranchName = Nothing
  , createBranchRepoOptionOldRefName = Nothing
  }

-- ** CreateEmailOption
-- | CreateEmailOption
-- CreateEmailOption options when creating email addresses
data CreateEmailOption = CreateEmailOption
  { createEmailOptionEmails :: !(Maybe [Text]) -- ^ "emails" - email addresses to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmailOption
instance A.FromJSON CreateEmailOption where
  parseJSON = A.withObject "CreateEmailOption" $ \o ->
    CreateEmailOption
      <$> (o .:? "emails")

-- | ToJSON CreateEmailOption
instance A.ToJSON CreateEmailOption where
  toJSON CreateEmailOption {..} =
   _omitNulls
      [ "emails" .= createEmailOptionEmails
      ]


-- | Construct a value of type 'CreateEmailOption' (by applying it's required fields, if any)
mkCreateEmailOption
  :: CreateEmailOption
mkCreateEmailOption =
  CreateEmailOption
  { createEmailOptionEmails = Nothing
  }

-- ** CreateFileOptions
-- | CreateFileOptions
-- CreateFileOptions options for creating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data CreateFileOptions = CreateFileOptions
  { createFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , createFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , createFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , createFileOptionsContent :: !(Text) -- ^ /Required/ "content" - content must be base64 encoded
  , createFileOptionsDates :: !(Maybe CommitDateOptions) -- ^ "dates"
  , createFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , createFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , createFileOptionsSignoff :: !(Maybe Bool) -- ^ "signoff" - Add a Signed-off-by trailer by the committer at the end of the commit log message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFileOptions
instance A.FromJSON CreateFileOptions where
  parseJSON = A.withObject "CreateFileOptions" $ \o ->
    CreateFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:  "content")
      <*> (o .:? "dates")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:? "signoff")

-- | ToJSON CreateFileOptions
instance A.ToJSON CreateFileOptions where
  toJSON CreateFileOptions {..} =
   _omitNulls
      [ "author" .= createFileOptionsAuthor
      , "branch" .= createFileOptionsBranch
      , "committer" .= createFileOptionsCommitter
      , "content" .= createFileOptionsContent
      , "dates" .= createFileOptionsDates
      , "message" .= createFileOptionsMessage
      , "new_branch" .= createFileOptionsNewBranch
      , "signoff" .= createFileOptionsSignoff
      ]


-- | Construct a value of type 'CreateFileOptions' (by applying it's required fields, if any)
mkCreateFileOptions
  :: Text -- ^ 'createFileOptionsContent': content must be base64 encoded
  -> CreateFileOptions
mkCreateFileOptions createFileOptionsContent =
  CreateFileOptions
  { createFileOptionsAuthor = Nothing
  , createFileOptionsBranch = Nothing
  , createFileOptionsCommitter = Nothing
  , createFileOptionsContent
  , createFileOptionsDates = Nothing
  , createFileOptionsMessage = Nothing
  , createFileOptionsNewBranch = Nothing
  , createFileOptionsSignoff = Nothing
  }

-- ** CreateForkOption
-- | CreateForkOption
-- CreateForkOption options for creating a fork
data CreateForkOption = CreateForkOption
  { createForkOptionName :: !(Maybe Text) -- ^ "name" - name of the forked repository
  , createForkOptionOrganization :: !(Maybe Text) -- ^ "organization" - organization name, if forking into an organization
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateForkOption
instance A.FromJSON CreateForkOption where
  parseJSON = A.withObject "CreateForkOption" $ \o ->
    CreateForkOption
      <$> (o .:? "name")
      <*> (o .:? "organization")

-- | ToJSON CreateForkOption
instance A.ToJSON CreateForkOption where
  toJSON CreateForkOption {..} =
   _omitNulls
      [ "name" .= createForkOptionName
      , "organization" .= createForkOptionOrganization
      ]


-- | Construct a value of type 'CreateForkOption' (by applying it's required fields, if any)
mkCreateForkOption
  :: CreateForkOption
mkCreateForkOption =
  CreateForkOption
  { createForkOptionName = Nothing
  , createForkOptionOrganization = Nothing
  }

-- ** CreateGPGKeyOption
-- | CreateGPGKeyOption
-- CreateGPGKeyOption options create user GPG key
data CreateGPGKeyOption = CreateGPGKeyOption
  { createGPGKeyOptionArmoredPublicKey :: !(Text) -- ^ /Required/ "armored_public_key" - An armored GPG key to add
  , createGPGKeyOptionArmoredSignature :: !(Maybe Text) -- ^ "armored_signature"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateGPGKeyOption
instance A.FromJSON CreateGPGKeyOption where
  parseJSON = A.withObject "CreateGPGKeyOption" $ \o ->
    CreateGPGKeyOption
      <$> (o .:  "armored_public_key")
      <*> (o .:? "armored_signature")

-- | ToJSON CreateGPGKeyOption
instance A.ToJSON CreateGPGKeyOption where
  toJSON CreateGPGKeyOption {..} =
   _omitNulls
      [ "armored_public_key" .= createGPGKeyOptionArmoredPublicKey
      , "armored_signature" .= createGPGKeyOptionArmoredSignature
      ]


-- | Construct a value of type 'CreateGPGKeyOption' (by applying it's required fields, if any)
mkCreateGPGKeyOption
  :: Text -- ^ 'createGPGKeyOptionArmoredPublicKey': An armored GPG key to add
  -> CreateGPGKeyOption
mkCreateGPGKeyOption createGPGKeyOptionArmoredPublicKey =
  CreateGPGKeyOption
  { createGPGKeyOptionArmoredPublicKey
  , createGPGKeyOptionArmoredSignature = Nothing
  }

-- ** CreateHookOption
-- | CreateHookOption
-- CreateHookOption options when create a hook
data CreateHookOption = CreateHookOption
  { createHookOptionActive :: !(Maybe Bool) -- ^ "active"
  , createHookOptionAuthorizationHeader :: !(Maybe Text) -- ^ "authorization_header"
  , createHookOptionBranchFilter :: !(Maybe Text) -- ^ "branch_filter"
  , createHookOptionConfig :: !((Map.Map String Text)) -- ^ /Required/ "config" - CreateHookOptionConfig has all config options in it required are \&quot;content_type\&quot; and \&quot;url\&quot; Required
  , createHookOptionEvents :: !(Maybe [Text]) -- ^ "events"
  , createHookOptionType :: !(E'Type) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateHookOption
instance A.FromJSON CreateHookOption where
  parseJSON = A.withObject "CreateHookOption" $ \o ->
    CreateHookOption
      <$> (o .:? "active")
      <*> (o .:? "authorization_header")
      <*> (o .:? "branch_filter")
      <*> (o .:  "config")
      <*> (o .:? "events")
      <*> (o .:  "type")

-- | ToJSON CreateHookOption
instance A.ToJSON CreateHookOption where
  toJSON CreateHookOption {..} =
   _omitNulls
      [ "active" .= createHookOptionActive
      , "authorization_header" .= createHookOptionAuthorizationHeader
      , "branch_filter" .= createHookOptionBranchFilter
      , "config" .= createHookOptionConfig
      , "events" .= createHookOptionEvents
      , "type" .= createHookOptionType
      ]


-- | Construct a value of type 'CreateHookOption' (by applying it's required fields, if any)
mkCreateHookOption
  :: (Map.Map String Text) -- ^ 'createHookOptionConfig': CreateHookOptionConfig has all config options in it required are \"content_type\" and \"url\" Required
  -> E'Type -- ^ 'createHookOptionType' 
  -> CreateHookOption
mkCreateHookOption createHookOptionConfig createHookOptionType =
  CreateHookOption
  { createHookOptionActive = Nothing
  , createHookOptionAuthorizationHeader = Nothing
  , createHookOptionBranchFilter = Nothing
  , createHookOptionConfig
  , createHookOptionEvents = Nothing
  , createHookOptionType
  }

-- ** CreateIssueCommentOption
-- | CreateIssueCommentOption
-- CreateIssueCommentOption options for creating a comment on an issue
data CreateIssueCommentOption = CreateIssueCommentOption
  { createIssueCommentOptionBody :: !(Text) -- ^ /Required/ "body"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateIssueCommentOption
instance A.FromJSON CreateIssueCommentOption where
  parseJSON = A.withObject "CreateIssueCommentOption" $ \o ->
    CreateIssueCommentOption
      <$> (o .:  "body")

-- | ToJSON CreateIssueCommentOption
instance A.ToJSON CreateIssueCommentOption where
  toJSON CreateIssueCommentOption {..} =
   _omitNulls
      [ "body" .= createIssueCommentOptionBody
      ]


-- | Construct a value of type 'CreateIssueCommentOption' (by applying it's required fields, if any)
mkCreateIssueCommentOption
  :: Text -- ^ 'createIssueCommentOptionBody' 
  -> CreateIssueCommentOption
mkCreateIssueCommentOption createIssueCommentOptionBody =
  CreateIssueCommentOption
  { createIssueCommentOptionBody
  }

-- ** CreateIssueOption
-- | CreateIssueOption
-- CreateIssueOption options to create one issue
data CreateIssueOption = CreateIssueOption
  { createIssueOptionAssignee :: !(Maybe Text) -- ^ "assignee" - deprecated
  , createIssueOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , createIssueOptionBody :: !(Maybe Text) -- ^ "body"
  , createIssueOptionClosed :: !(Maybe Bool) -- ^ "closed"
  , createIssueOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , createIssueOptionLabels :: !(Maybe [Integer]) -- ^ "labels" - list of label ids
  , createIssueOptionMilestone :: !(Maybe Integer) -- ^ "milestone" - milestone id
  , createIssueOptionRef :: !(Maybe Text) -- ^ "ref"
  , createIssueOptionTitle :: !(Text) -- ^ /Required/ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateIssueOption
instance A.FromJSON CreateIssueOption where
  parseJSON = A.withObject "CreateIssueOption" $ \o ->
    CreateIssueOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "closed")
      <*> (o .:? "due_date")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "ref")
      <*> (o .:  "title")

-- | ToJSON CreateIssueOption
instance A.ToJSON CreateIssueOption where
  toJSON CreateIssueOption {..} =
   _omitNulls
      [ "assignee" .= createIssueOptionAssignee
      , "assignees" .= createIssueOptionAssignees
      , "body" .= createIssueOptionBody
      , "closed" .= createIssueOptionClosed
      , "due_date" .= createIssueOptionDueDate
      , "labels" .= createIssueOptionLabels
      , "milestone" .= createIssueOptionMilestone
      , "ref" .= createIssueOptionRef
      , "title" .= createIssueOptionTitle
      ]


-- | Construct a value of type 'CreateIssueOption' (by applying it's required fields, if any)
mkCreateIssueOption
  :: Text -- ^ 'createIssueOptionTitle' 
  -> CreateIssueOption
mkCreateIssueOption createIssueOptionTitle =
  CreateIssueOption
  { createIssueOptionAssignee = Nothing
  , createIssueOptionAssignees = Nothing
  , createIssueOptionBody = Nothing
  , createIssueOptionClosed = Nothing
  , createIssueOptionDueDate = Nothing
  , createIssueOptionLabels = Nothing
  , createIssueOptionMilestone = Nothing
  , createIssueOptionRef = Nothing
  , createIssueOptionTitle
  }

-- ** CreateKeyOption
-- | CreateKeyOption
-- CreateKeyOption options when creating a key
data CreateKeyOption = CreateKeyOption
  { createKeyOptionKey :: !(Text) -- ^ /Required/ "key" - An armored SSH key to add
  , createKeyOptionReadOnly :: !(Maybe Bool) -- ^ "read_only" - Describe if the key has only read access or read/write
  , createKeyOptionTitle :: !(Text) -- ^ /Required/ "title" - Title of the key to add
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateKeyOption
instance A.FromJSON CreateKeyOption where
  parseJSON = A.withObject "CreateKeyOption" $ \o ->
    CreateKeyOption
      <$> (o .:  "key")
      <*> (o .:? "read_only")
      <*> (o .:  "title")

-- | ToJSON CreateKeyOption
instance A.ToJSON CreateKeyOption where
  toJSON CreateKeyOption {..} =
   _omitNulls
      [ "key" .= createKeyOptionKey
      , "read_only" .= createKeyOptionReadOnly
      , "title" .= createKeyOptionTitle
      ]


-- | Construct a value of type 'CreateKeyOption' (by applying it's required fields, if any)
mkCreateKeyOption
  :: Text -- ^ 'createKeyOptionKey': An armored SSH key to add
  -> Text -- ^ 'createKeyOptionTitle': Title of the key to add
  -> CreateKeyOption
mkCreateKeyOption createKeyOptionKey createKeyOptionTitle =
  CreateKeyOption
  { createKeyOptionKey
  , createKeyOptionReadOnly = Nothing
  , createKeyOptionTitle
  }

-- ** CreateLabelOption
-- | CreateLabelOption
-- CreateLabelOption options for creating a label
data CreateLabelOption = CreateLabelOption
  { createLabelOptionColor :: !(Text) -- ^ /Required/ "color"
  , createLabelOptionDescription :: !(Maybe Text) -- ^ "description"
  , createLabelOptionExclusive :: !(Maybe Bool) -- ^ "exclusive"
  , createLabelOptionName :: !(Text) -- ^ /Required/ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateLabelOption
instance A.FromJSON CreateLabelOption where
  parseJSON = A.withObject "CreateLabelOption" $ \o ->
    CreateLabelOption
      <$> (o .:  "color")
      <*> (o .:? "description")
      <*> (o .:? "exclusive")
      <*> (o .:  "name")

-- | ToJSON CreateLabelOption
instance A.ToJSON CreateLabelOption where
  toJSON CreateLabelOption {..} =
   _omitNulls
      [ "color" .= createLabelOptionColor
      , "description" .= createLabelOptionDescription
      , "exclusive" .= createLabelOptionExclusive
      , "name" .= createLabelOptionName
      ]


-- | Construct a value of type 'CreateLabelOption' (by applying it's required fields, if any)
mkCreateLabelOption
  :: Text -- ^ 'createLabelOptionColor' 
  -> Text -- ^ 'createLabelOptionName' 
  -> CreateLabelOption
mkCreateLabelOption createLabelOptionColor createLabelOptionName =
  CreateLabelOption
  { createLabelOptionColor
  , createLabelOptionDescription = Nothing
  , createLabelOptionExclusive = Nothing
  , createLabelOptionName
  }

-- ** CreateMilestoneOption
-- | CreateMilestoneOption
-- CreateMilestoneOption options for creating a milestone
data CreateMilestoneOption = CreateMilestoneOption
  { createMilestoneOptionDescription :: !(Maybe Text) -- ^ "description"
  , createMilestoneOptionDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , createMilestoneOptionState :: !(Maybe E'State) -- ^ "state"
  , createMilestoneOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateMilestoneOption
instance A.FromJSON CreateMilestoneOption where
  parseJSON = A.withObject "CreateMilestoneOption" $ \o ->
    CreateMilestoneOption
      <$> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON CreateMilestoneOption
instance A.ToJSON CreateMilestoneOption where
  toJSON CreateMilestoneOption {..} =
   _omitNulls
      [ "description" .= createMilestoneOptionDescription
      , "due_on" .= createMilestoneOptionDueOn
      , "state" .= createMilestoneOptionState
      , "title" .= createMilestoneOptionTitle
      ]


-- | Construct a value of type 'CreateMilestoneOption' (by applying it's required fields, if any)
mkCreateMilestoneOption
  :: CreateMilestoneOption
mkCreateMilestoneOption =
  CreateMilestoneOption
  { createMilestoneOptionDescription = Nothing
  , createMilestoneOptionDueOn = Nothing
  , createMilestoneOptionState = Nothing
  , createMilestoneOptionTitle = Nothing
  }

-- ** CreateOAuth2ApplicationOptions
-- | CreateOAuth2ApplicationOptions
-- CreateOAuth2ApplicationOptions holds options to create an oauth2 application
data CreateOAuth2ApplicationOptions = CreateOAuth2ApplicationOptions
  { createOAuth2ApplicationOptionsConfidentialClient :: !(Maybe Bool) -- ^ "confidential_client"
  , createOAuth2ApplicationOptionsName :: !(Maybe Text) -- ^ "name"
  , createOAuth2ApplicationOptionsRedirectUris :: !(Maybe [Text]) -- ^ "redirect_uris"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOAuth2ApplicationOptions
instance A.FromJSON CreateOAuth2ApplicationOptions where
  parseJSON = A.withObject "CreateOAuth2ApplicationOptions" $ \o ->
    CreateOAuth2ApplicationOptions
      <$> (o .:? "confidential_client")
      <*> (o .:? "name")
      <*> (o .:? "redirect_uris")

-- | ToJSON CreateOAuth2ApplicationOptions
instance A.ToJSON CreateOAuth2ApplicationOptions where
  toJSON CreateOAuth2ApplicationOptions {..} =
   _omitNulls
      [ "confidential_client" .= createOAuth2ApplicationOptionsConfidentialClient
      , "name" .= createOAuth2ApplicationOptionsName
      , "redirect_uris" .= createOAuth2ApplicationOptionsRedirectUris
      ]


-- | Construct a value of type 'CreateOAuth2ApplicationOptions' (by applying it's required fields, if any)
mkCreateOAuth2ApplicationOptions
  :: CreateOAuth2ApplicationOptions
mkCreateOAuth2ApplicationOptions =
  CreateOAuth2ApplicationOptions
  { createOAuth2ApplicationOptionsConfidentialClient = Nothing
  , createOAuth2ApplicationOptionsName = Nothing
  , createOAuth2ApplicationOptionsRedirectUris = Nothing
  }

-- ** CreateOrgOption
-- | CreateOrgOption
-- CreateOrgOption options for creating an organization
data CreateOrgOption = CreateOrgOption
  { createOrgOptionDescription :: !(Maybe Text) -- ^ "description"
  , createOrgOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , createOrgOptionLocation :: !(Maybe Text) -- ^ "location"
  , createOrgOptionRepoAdminChangeTeamAccess :: !(Maybe Bool) -- ^ "repo_admin_change_team_access"
  , createOrgOptionUsername :: !(Text) -- ^ /Required/ "username"
  , createOrgOptionVisibility :: !(Maybe E'Visibility) -- ^ "visibility" - possible values are &#x60;public&#x60; (default), &#x60;limited&#x60; or &#x60;private&#x60;
  , createOrgOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOrgOption
instance A.FromJSON CreateOrgOption where
  parseJSON = A.withObject "CreateOrgOption" $ \o ->
    CreateOrgOption
      <$> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:? "repo_admin_change_team_access")
      <*> (o .:  "username")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON CreateOrgOption
instance A.ToJSON CreateOrgOption where
  toJSON CreateOrgOption {..} =
   _omitNulls
      [ "description" .= createOrgOptionDescription
      , "full_name" .= createOrgOptionFullName
      , "location" .= createOrgOptionLocation
      , "repo_admin_change_team_access" .= createOrgOptionRepoAdminChangeTeamAccess
      , "username" .= createOrgOptionUsername
      , "visibility" .= createOrgOptionVisibility
      , "website" .= createOrgOptionWebsite
      ]


-- | Construct a value of type 'CreateOrgOption' (by applying it's required fields, if any)
mkCreateOrgOption
  :: Text -- ^ 'createOrgOptionUsername' 
  -> CreateOrgOption
mkCreateOrgOption createOrgOptionUsername =
  CreateOrgOption
  { createOrgOptionDescription = Nothing
  , createOrgOptionFullName = Nothing
  , createOrgOptionLocation = Nothing
  , createOrgOptionRepoAdminChangeTeamAccess = Nothing
  , createOrgOptionUsername
  , createOrgOptionVisibility = Nothing
  , createOrgOptionWebsite = Nothing
  }

-- ** CreatePullRequestOption
-- | CreatePullRequestOption
-- CreatePullRequestOption options when creating a pull request
data CreatePullRequestOption = CreatePullRequestOption
  { createPullRequestOptionAssignee :: !(Maybe Text) -- ^ "assignee"
  , createPullRequestOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , createPullRequestOptionBase :: !(Maybe Text) -- ^ "base"
  , createPullRequestOptionBody :: !(Maybe Text) -- ^ "body"
  , createPullRequestOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , createPullRequestOptionHead :: !(Maybe Text) -- ^ "head"
  , createPullRequestOptionLabels :: !(Maybe [Integer]) -- ^ "labels"
  , createPullRequestOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , createPullRequestOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePullRequestOption
instance A.FromJSON CreatePullRequestOption where
  parseJSON = A.withObject "CreatePullRequestOption" $ \o ->
    CreatePullRequestOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "base")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "head")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "title")

-- | ToJSON CreatePullRequestOption
instance A.ToJSON CreatePullRequestOption where
  toJSON CreatePullRequestOption {..} =
   _omitNulls
      [ "assignee" .= createPullRequestOptionAssignee
      , "assignees" .= createPullRequestOptionAssignees
      , "base" .= createPullRequestOptionBase
      , "body" .= createPullRequestOptionBody
      , "due_date" .= createPullRequestOptionDueDate
      , "head" .= createPullRequestOptionHead
      , "labels" .= createPullRequestOptionLabels
      , "milestone" .= createPullRequestOptionMilestone
      , "title" .= createPullRequestOptionTitle
      ]


-- | Construct a value of type 'CreatePullRequestOption' (by applying it's required fields, if any)
mkCreatePullRequestOption
  :: CreatePullRequestOption
mkCreatePullRequestOption =
  CreatePullRequestOption
  { createPullRequestOptionAssignee = Nothing
  , createPullRequestOptionAssignees = Nothing
  , createPullRequestOptionBase = Nothing
  , createPullRequestOptionBody = Nothing
  , createPullRequestOptionDueDate = Nothing
  , createPullRequestOptionHead = Nothing
  , createPullRequestOptionLabels = Nothing
  , createPullRequestOptionMilestone = Nothing
  , createPullRequestOptionTitle = Nothing
  }

-- ** CreatePullReviewComment
-- | CreatePullReviewComment
-- CreatePullReviewComment represent a review comment for creation api
data CreatePullReviewComment = CreatePullReviewComment
  { createPullReviewCommentBody :: !(Maybe Text) -- ^ "body"
  , createPullReviewCommentNewPosition :: !(Maybe Integer) -- ^ "new_position" - if comment to new file line or 0
  , createPullReviewCommentOldPosition :: !(Maybe Integer) -- ^ "old_position" - if comment to old file line or 0
  , createPullReviewCommentPath :: !(Maybe Text) -- ^ "path" - the tree path
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePullReviewComment
instance A.FromJSON CreatePullReviewComment where
  parseJSON = A.withObject "CreatePullReviewComment" $ \o ->
    CreatePullReviewComment
      <$> (o .:? "body")
      <*> (o .:? "new_position")
      <*> (o .:? "old_position")
      <*> (o .:? "path")

-- | ToJSON CreatePullReviewComment
instance A.ToJSON CreatePullReviewComment where
  toJSON CreatePullReviewComment {..} =
   _omitNulls
      [ "body" .= createPullReviewCommentBody
      , "new_position" .= createPullReviewCommentNewPosition
      , "old_position" .= createPullReviewCommentOldPosition
      , "path" .= createPullReviewCommentPath
      ]


-- | Construct a value of type 'CreatePullReviewComment' (by applying it's required fields, if any)
mkCreatePullReviewComment
  :: CreatePullReviewComment
mkCreatePullReviewComment =
  CreatePullReviewComment
  { createPullReviewCommentBody = Nothing
  , createPullReviewCommentNewPosition = Nothing
  , createPullReviewCommentOldPosition = Nothing
  , createPullReviewCommentPath = Nothing
  }

-- ** CreatePullReviewOptions
-- | CreatePullReviewOptions
-- CreatePullReviewOptions are options to create a pull review
data CreatePullReviewOptions = CreatePullReviewOptions
  { createPullReviewOptionsBody :: !(Maybe Text) -- ^ "body"
  , createPullReviewOptionsComments :: !(Maybe [CreatePullReviewComment]) -- ^ "comments"
  , createPullReviewOptionsCommitId :: !(Maybe Text) -- ^ "commit_id"
  , createPullReviewOptionsEvent :: !(Maybe Text) -- ^ "event" - ReviewStateType review state type
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePullReviewOptions
instance A.FromJSON CreatePullReviewOptions where
  parseJSON = A.withObject "CreatePullReviewOptions" $ \o ->
    CreatePullReviewOptions
      <$> (o .:? "body")
      <*> (o .:? "comments")
      <*> (o .:? "commit_id")
      <*> (o .:? "event")

-- | ToJSON CreatePullReviewOptions
instance A.ToJSON CreatePullReviewOptions where
  toJSON CreatePullReviewOptions {..} =
   _omitNulls
      [ "body" .= createPullReviewOptionsBody
      , "comments" .= createPullReviewOptionsComments
      , "commit_id" .= createPullReviewOptionsCommitId
      , "event" .= createPullReviewOptionsEvent
      ]


-- | Construct a value of type 'CreatePullReviewOptions' (by applying it's required fields, if any)
mkCreatePullReviewOptions
  :: CreatePullReviewOptions
mkCreatePullReviewOptions =
  CreatePullReviewOptions
  { createPullReviewOptionsBody = Nothing
  , createPullReviewOptionsComments = Nothing
  , createPullReviewOptionsCommitId = Nothing
  , createPullReviewOptionsEvent = Nothing
  }

-- ** CreatePushMirrorOption
-- | CreatePushMirrorOption
-- CreatePushMirrorOption represents need information to create a push mirror of a repository.
-- 
data CreatePushMirrorOption = CreatePushMirrorOption
  { createPushMirrorOptionInterval :: !(Maybe Text) -- ^ "interval"
  , createPushMirrorOptionRemoteAddress :: !(Maybe Text) -- ^ "remote_address"
  , createPushMirrorOptionRemotePassword :: !(Maybe Text) -- ^ "remote_password"
  , createPushMirrorOptionRemoteUsername :: !(Maybe Text) -- ^ "remote_username"
  , createPushMirrorOptionSyncOnCommit :: !(Maybe Bool) -- ^ "sync_on_commit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatePushMirrorOption
instance A.FromJSON CreatePushMirrorOption where
  parseJSON = A.withObject "CreatePushMirrorOption" $ \o ->
    CreatePushMirrorOption
      <$> (o .:? "interval")
      <*> (o .:? "remote_address")
      <*> (o .:? "remote_password")
      <*> (o .:? "remote_username")
      <*> (o .:? "sync_on_commit")

-- | ToJSON CreatePushMirrorOption
instance A.ToJSON CreatePushMirrorOption where
  toJSON CreatePushMirrorOption {..} =
   _omitNulls
      [ "interval" .= createPushMirrorOptionInterval
      , "remote_address" .= createPushMirrorOptionRemoteAddress
      , "remote_password" .= createPushMirrorOptionRemotePassword
      , "remote_username" .= createPushMirrorOptionRemoteUsername
      , "sync_on_commit" .= createPushMirrorOptionSyncOnCommit
      ]


-- | Construct a value of type 'CreatePushMirrorOption' (by applying it's required fields, if any)
mkCreatePushMirrorOption
  :: CreatePushMirrorOption
mkCreatePushMirrorOption =
  CreatePushMirrorOption
  { createPushMirrorOptionInterval = Nothing
  , createPushMirrorOptionRemoteAddress = Nothing
  , createPushMirrorOptionRemotePassword = Nothing
  , createPushMirrorOptionRemoteUsername = Nothing
  , createPushMirrorOptionSyncOnCommit = Nothing
  }

-- ** CreateReleaseOption
-- | CreateReleaseOption
-- CreateReleaseOption options when creating a release
data CreateReleaseOption = CreateReleaseOption
  { createReleaseOptionBody :: !(Maybe Text) -- ^ "body"
  , createReleaseOptionDraft :: !(Maybe Bool) -- ^ "draft"
  , createReleaseOptionName :: !(Maybe Text) -- ^ "name"
  , createReleaseOptionPrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , createReleaseOptionTagName :: !(Text) -- ^ /Required/ "tag_name"
  , createReleaseOptionTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateReleaseOption
instance A.FromJSON CreateReleaseOption where
  parseJSON = A.withObject "CreateReleaseOption" $ \o ->
    CreateReleaseOption
      <$> (o .:? "body")
      <*> (o .:? "draft")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:  "tag_name")
      <*> (o .:? "target_commitish")

-- | ToJSON CreateReleaseOption
instance A.ToJSON CreateReleaseOption where
  toJSON CreateReleaseOption {..} =
   _omitNulls
      [ "body" .= createReleaseOptionBody
      , "draft" .= createReleaseOptionDraft
      , "name" .= createReleaseOptionName
      , "prerelease" .= createReleaseOptionPrerelease
      , "tag_name" .= createReleaseOptionTagName
      , "target_commitish" .= createReleaseOptionTargetCommitish
      ]


-- | Construct a value of type 'CreateReleaseOption' (by applying it's required fields, if any)
mkCreateReleaseOption
  :: Text -- ^ 'createReleaseOptionTagName' 
  -> CreateReleaseOption
mkCreateReleaseOption createReleaseOptionTagName =
  CreateReleaseOption
  { createReleaseOptionBody = Nothing
  , createReleaseOptionDraft = Nothing
  , createReleaseOptionName = Nothing
  , createReleaseOptionPrerelease = Nothing
  , createReleaseOptionTagName
  , createReleaseOptionTargetCommitish = Nothing
  }

-- ** CreateRepoOption
-- | CreateRepoOption
-- CreateRepoOption options when creating repository
data CreateRepoOption = CreateRepoOption
  { createRepoOptionAutoInit :: !(Maybe Bool) -- ^ "auto_init" - Whether the repository should be auto-initialized?
  , createRepoOptionDefaultBranch :: !(Maybe Text) -- ^ "default_branch" - DefaultBranch of the repository (used when initializes and in template)
  , createRepoOptionDescription :: !(Maybe Text) -- ^ "description" - Description of the repository to create
  , createRepoOptionGitignores :: !(Maybe Text) -- ^ "gitignores" - Gitignores to use
  , createRepoOptionIssueLabels :: !(Maybe Text) -- ^ "issue_labels" - Label-Set to use
  , createRepoOptionLicense :: !(Maybe Text) -- ^ "license" - License to use
  , createRepoOptionName :: !(Text) -- ^ /Required/ "name" - Name of the repository to create
  , createRepoOptionPrivate :: !(Maybe Bool) -- ^ "private" - Whether the repository is private
  , createRepoOptionReadme :: !(Maybe Text) -- ^ "readme" - Readme of the repository to create
  , createRepoOptionTemplate :: !(Maybe Bool) -- ^ "template" - Whether the repository is template
  , createRepoOptionTrustModel :: !(Maybe E'TrustModel) -- ^ "trust_model" - TrustModel of the repository
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateRepoOption
instance A.FromJSON CreateRepoOption where
  parseJSON = A.withObject "CreateRepoOption" $ \o ->
    CreateRepoOption
      <$> (o .:? "auto_init")
      <*> (o .:? "default_branch")
      <*> (o .:? "description")
      <*> (o .:? "gitignores")
      <*> (o .:? "issue_labels")
      <*> (o .:? "license")
      <*> (o .:  "name")
      <*> (o .:? "private")
      <*> (o .:? "readme")
      <*> (o .:? "template")
      <*> (o .:? "trust_model")

-- | ToJSON CreateRepoOption
instance A.ToJSON CreateRepoOption where
  toJSON CreateRepoOption {..} =
   _omitNulls
      [ "auto_init" .= createRepoOptionAutoInit
      , "default_branch" .= createRepoOptionDefaultBranch
      , "description" .= createRepoOptionDescription
      , "gitignores" .= createRepoOptionGitignores
      , "issue_labels" .= createRepoOptionIssueLabels
      , "license" .= createRepoOptionLicense
      , "name" .= createRepoOptionName
      , "private" .= createRepoOptionPrivate
      , "readme" .= createRepoOptionReadme
      , "template" .= createRepoOptionTemplate
      , "trust_model" .= createRepoOptionTrustModel
      ]


-- | Construct a value of type 'CreateRepoOption' (by applying it's required fields, if any)
mkCreateRepoOption
  :: Text -- ^ 'createRepoOptionName': Name of the repository to create
  -> CreateRepoOption
mkCreateRepoOption createRepoOptionName =
  CreateRepoOption
  { createRepoOptionAutoInit = Nothing
  , createRepoOptionDefaultBranch = Nothing
  , createRepoOptionDescription = Nothing
  , createRepoOptionGitignores = Nothing
  , createRepoOptionIssueLabels = Nothing
  , createRepoOptionLicense = Nothing
  , createRepoOptionName
  , createRepoOptionPrivate = Nothing
  , createRepoOptionReadme = Nothing
  , createRepoOptionTemplate = Nothing
  , createRepoOptionTrustModel = Nothing
  }

-- ** CreateStatusOption
-- | CreateStatusOption
-- CreateStatusOption holds the information needed to create a new CommitStatus for a Commit
data CreateStatusOption = CreateStatusOption
  { createStatusOptionContext :: !(Maybe Text) -- ^ "context"
  , createStatusOptionDescription :: !(Maybe Text) -- ^ "description"
  , createStatusOptionState :: !(Maybe Text) -- ^ "state" - CommitStatusState holds the state of a CommitStatus It can be \&quot;pending\&quot;, \&quot;success\&quot;, \&quot;error\&quot;, \&quot;failure\&quot;, and \&quot;warning\&quot;
  , createStatusOptionTargetUrl :: !(Maybe Text) -- ^ "target_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateStatusOption
instance A.FromJSON CreateStatusOption where
  parseJSON = A.withObject "CreateStatusOption" $ \o ->
    CreateStatusOption
      <$> (o .:? "context")
      <*> (o .:? "description")
      <*> (o .:? "state")
      <*> (o .:? "target_url")

-- | ToJSON CreateStatusOption
instance A.ToJSON CreateStatusOption where
  toJSON CreateStatusOption {..} =
   _omitNulls
      [ "context" .= createStatusOptionContext
      , "description" .= createStatusOptionDescription
      , "state" .= createStatusOptionState
      , "target_url" .= createStatusOptionTargetUrl
      ]


-- | Construct a value of type 'CreateStatusOption' (by applying it's required fields, if any)
mkCreateStatusOption
  :: CreateStatusOption
mkCreateStatusOption =
  CreateStatusOption
  { createStatusOptionContext = Nothing
  , createStatusOptionDescription = Nothing
  , createStatusOptionState = Nothing
  , createStatusOptionTargetUrl = Nothing
  }

-- ** CreateTagOption
-- | CreateTagOption
-- CreateTagOption options when creating a tag
data CreateTagOption = CreateTagOption
  { createTagOptionMessage :: !(Maybe Text) -- ^ "message"
  , createTagOptionTagName :: !(Text) -- ^ /Required/ "tag_name"
  , createTagOptionTarget :: !(Maybe Text) -- ^ "target"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTagOption
instance A.FromJSON CreateTagOption where
  parseJSON = A.withObject "CreateTagOption" $ \o ->
    CreateTagOption
      <$> (o .:? "message")
      <*> (o .:  "tag_name")
      <*> (o .:? "target")

-- | ToJSON CreateTagOption
instance A.ToJSON CreateTagOption where
  toJSON CreateTagOption {..} =
   _omitNulls
      [ "message" .= createTagOptionMessage
      , "tag_name" .= createTagOptionTagName
      , "target" .= createTagOptionTarget
      ]


-- | Construct a value of type 'CreateTagOption' (by applying it's required fields, if any)
mkCreateTagOption
  :: Text -- ^ 'createTagOptionTagName' 
  -> CreateTagOption
mkCreateTagOption createTagOptionTagName =
  CreateTagOption
  { createTagOptionMessage = Nothing
  , createTagOptionTagName
  , createTagOptionTarget = Nothing
  }

-- ** CreateTeamOption
-- | CreateTeamOption
-- CreateTeamOption options for creating a team
data CreateTeamOption = CreateTeamOption
  { createTeamOptionCanCreateOrgRepo :: !(Maybe Bool) -- ^ "can_create_org_repo"
  , createTeamOptionDescription :: !(Maybe Text) -- ^ "description"
  , createTeamOptionIncludesAllRepositories :: !(Maybe Bool) -- ^ "includes_all_repositories"
  , createTeamOptionName :: !(Text) -- ^ /Required/ "name"
  , createTeamOptionPermission :: !(Maybe E'Permission) -- ^ "permission"
  , createTeamOptionUnits :: !(Maybe [Text]) -- ^ "units"
  , createTeamOptionUnitsMap :: !(Maybe (Map.Map String Text)) -- ^ "units_map"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTeamOption
instance A.FromJSON CreateTeamOption where
  parseJSON = A.withObject "CreateTeamOption" $ \o ->
    CreateTeamOption
      <$> (o .:? "can_create_org_repo")
      <*> (o .:? "description")
      <*> (o .:? "includes_all_repositories")
      <*> (o .:  "name")
      <*> (o .:? "permission")
      <*> (o .:? "units")
      <*> (o .:? "units_map")

-- | ToJSON CreateTeamOption
instance A.ToJSON CreateTeamOption where
  toJSON CreateTeamOption {..} =
   _omitNulls
      [ "can_create_org_repo" .= createTeamOptionCanCreateOrgRepo
      , "description" .= createTeamOptionDescription
      , "includes_all_repositories" .= createTeamOptionIncludesAllRepositories
      , "name" .= createTeamOptionName
      , "permission" .= createTeamOptionPermission
      , "units" .= createTeamOptionUnits
      , "units_map" .= createTeamOptionUnitsMap
      ]


-- | Construct a value of type 'CreateTeamOption' (by applying it's required fields, if any)
mkCreateTeamOption
  :: Text -- ^ 'createTeamOptionName' 
  -> CreateTeamOption
mkCreateTeamOption createTeamOptionName =
  CreateTeamOption
  { createTeamOptionCanCreateOrgRepo = Nothing
  , createTeamOptionDescription = Nothing
  , createTeamOptionIncludesAllRepositories = Nothing
  , createTeamOptionName
  , createTeamOptionPermission = Nothing
  , createTeamOptionUnits = Nothing
  , createTeamOptionUnitsMap = Nothing
  }

-- ** CreateUserOption
-- | CreateUserOption
-- CreateUserOption create user options
data CreateUserOption = CreateUserOption
  { createUserOptionCreatedAt :: !(Maybe DateTime) -- ^ "created_at" - For explicitly setting the user creation timestamp. Useful when users are migrated from other systems. When omitted, the user&#39;s creation timestamp will be set to \&quot;now\&quot;.
  , createUserOptionEmail :: !(Text) -- ^ /Required/ "email"
  , createUserOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , createUserOptionLoginName :: !(Maybe Text) -- ^ "login_name"
  , createUserOptionMustChangePassword :: !(Maybe Bool) -- ^ "must_change_password"
  , createUserOptionPassword :: !(Text) -- ^ /Required/ "password"
  , createUserOptionRestricted :: !(Maybe Bool) -- ^ "restricted"
  , createUserOptionSendNotify :: !(Maybe Bool) -- ^ "send_notify"
  , createUserOptionSourceId :: !(Maybe Integer) -- ^ "source_id"
  , createUserOptionUsername :: !(Text) -- ^ /Required/ "username"
  , createUserOptionVisibility :: !(Maybe Text) -- ^ "visibility"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUserOption
instance A.FromJSON CreateUserOption where
  parseJSON = A.withObject "CreateUserOption" $ \o ->
    CreateUserOption
      <$> (o .:? "created_at")
      <*> (o .:  "email")
      <*> (o .:? "full_name")
      <*> (o .:? "login_name")
      <*> (o .:? "must_change_password")
      <*> (o .:  "password")
      <*> (o .:? "restricted")
      <*> (o .:? "send_notify")
      <*> (o .:? "source_id")
      <*> (o .:  "username")
      <*> (o .:? "visibility")

-- | ToJSON CreateUserOption
instance A.ToJSON CreateUserOption where
  toJSON CreateUserOption {..} =
   _omitNulls
      [ "created_at" .= createUserOptionCreatedAt
      , "email" .= createUserOptionEmail
      , "full_name" .= createUserOptionFullName
      , "login_name" .= createUserOptionLoginName
      , "must_change_password" .= createUserOptionMustChangePassword
      , "password" .= createUserOptionPassword
      , "restricted" .= createUserOptionRestricted
      , "send_notify" .= createUserOptionSendNotify
      , "source_id" .= createUserOptionSourceId
      , "username" .= createUserOptionUsername
      , "visibility" .= createUserOptionVisibility
      ]


-- | Construct a value of type 'CreateUserOption' (by applying it's required fields, if any)
mkCreateUserOption
  :: Text -- ^ 'createUserOptionEmail' 
  -> Text -- ^ 'createUserOptionPassword' 
  -> Text -- ^ 'createUserOptionUsername' 
  -> CreateUserOption
mkCreateUserOption createUserOptionEmail createUserOptionPassword createUserOptionUsername =
  CreateUserOption
  { createUserOptionCreatedAt = Nothing
  , createUserOptionEmail
  , createUserOptionFullName = Nothing
  , createUserOptionLoginName = Nothing
  , createUserOptionMustChangePassword = Nothing
  , createUserOptionPassword
  , createUserOptionRestricted = Nothing
  , createUserOptionSendNotify = Nothing
  , createUserOptionSourceId = Nothing
  , createUserOptionUsername
  , createUserOptionVisibility = Nothing
  }

-- ** CreateWikiPageOptions
-- | CreateWikiPageOptions
-- CreateWikiPageOptions form for creating wiki
data CreateWikiPageOptions = CreateWikiPageOptions
  { createWikiPageOptionsContentBase64 :: !(Maybe Text) -- ^ "content_base64" - content must be base64 encoded
  , createWikiPageOptionsMessage :: !(Maybe Text) -- ^ "message" - optional commit message summarizing the change
  , createWikiPageOptionsTitle :: !(Maybe Text) -- ^ "title" - page title. leave empty to keep unchanged
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateWikiPageOptions
instance A.FromJSON CreateWikiPageOptions where
  parseJSON = A.withObject "CreateWikiPageOptions" $ \o ->
    CreateWikiPageOptions
      <$> (o .:? "content_base64")
      <*> (o .:? "message")
      <*> (o .:? "title")

-- | ToJSON CreateWikiPageOptions
instance A.ToJSON CreateWikiPageOptions where
  toJSON CreateWikiPageOptions {..} =
   _omitNulls
      [ "content_base64" .= createWikiPageOptionsContentBase64
      , "message" .= createWikiPageOptionsMessage
      , "title" .= createWikiPageOptionsTitle
      ]


-- | Construct a value of type 'CreateWikiPageOptions' (by applying it's required fields, if any)
mkCreateWikiPageOptions
  :: CreateWikiPageOptions
mkCreateWikiPageOptions =
  CreateWikiPageOptions
  { createWikiPageOptionsContentBase64 = Nothing
  , createWikiPageOptionsMessage = Nothing
  , createWikiPageOptionsTitle = Nothing
  }

-- ** Cron
-- | Cron
-- Cron represents a Cron task
data Cron = Cron
  { cronExecTimes :: !(Maybe Integer) -- ^ "exec_times"
  , cronName :: !(Maybe Text) -- ^ "name"
  , cronNext :: !(Maybe DateTime) -- ^ "next"
  , cronPrev :: !(Maybe DateTime) -- ^ "prev"
  , cronSchedule :: !(Maybe Text) -- ^ "schedule"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Cron
instance A.FromJSON Cron where
  parseJSON = A.withObject "Cron" $ \o ->
    Cron
      <$> (o .:? "exec_times")
      <*> (o .:? "name")
      <*> (o .:? "next")
      <*> (o .:? "prev")
      <*> (o .:? "schedule")

-- | ToJSON Cron
instance A.ToJSON Cron where
  toJSON Cron {..} =
   _omitNulls
      [ "exec_times" .= cronExecTimes
      , "name" .= cronName
      , "next" .= cronNext
      , "prev" .= cronPrev
      , "schedule" .= cronSchedule
      ]


-- | Construct a value of type 'Cron' (by applying it's required fields, if any)
mkCron
  :: Cron
mkCron =
  Cron
  { cronExecTimes = Nothing
  , cronName = Nothing
  , cronNext = Nothing
  , cronPrev = Nothing
  , cronSchedule = Nothing
  }

-- ** DeleteEmailOption
-- | DeleteEmailOption
-- DeleteEmailOption options when deleting email addresses
data DeleteEmailOption = DeleteEmailOption
  { deleteEmailOptionEmails :: !(Maybe [Text]) -- ^ "emails" - email addresses to delete
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteEmailOption
instance A.FromJSON DeleteEmailOption where
  parseJSON = A.withObject "DeleteEmailOption" $ \o ->
    DeleteEmailOption
      <$> (o .:? "emails")

-- | ToJSON DeleteEmailOption
instance A.ToJSON DeleteEmailOption where
  toJSON DeleteEmailOption {..} =
   _omitNulls
      [ "emails" .= deleteEmailOptionEmails
      ]


-- | Construct a value of type 'DeleteEmailOption' (by applying it's required fields, if any)
mkDeleteEmailOption
  :: DeleteEmailOption
mkDeleteEmailOption =
  DeleteEmailOption
  { deleteEmailOptionEmails = Nothing
  }

-- ** DeleteFileOptions
-- | DeleteFileOptions
-- DeleteFileOptions options for deleting files (used for other File structs below) Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data DeleteFileOptions = DeleteFileOptions
  { deleteFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , deleteFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , deleteFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , deleteFileOptionsDates :: !(Maybe CommitDateOptions) -- ^ "dates"
  , deleteFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , deleteFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , deleteFileOptionsSha :: !(Text) -- ^ /Required/ "sha" - sha is the SHA for the file that already exists
  , deleteFileOptionsSignoff :: !(Maybe Bool) -- ^ "signoff" - Add a Signed-off-by trailer by the committer at the end of the commit log message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteFileOptions
instance A.FromJSON DeleteFileOptions where
  parseJSON = A.withObject "DeleteFileOptions" $ \o ->
    DeleteFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:? "dates")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:  "sha")
      <*> (o .:? "signoff")

-- | ToJSON DeleteFileOptions
instance A.ToJSON DeleteFileOptions where
  toJSON DeleteFileOptions {..} =
   _omitNulls
      [ "author" .= deleteFileOptionsAuthor
      , "branch" .= deleteFileOptionsBranch
      , "committer" .= deleteFileOptionsCommitter
      , "dates" .= deleteFileOptionsDates
      , "message" .= deleteFileOptionsMessage
      , "new_branch" .= deleteFileOptionsNewBranch
      , "sha" .= deleteFileOptionsSha
      , "signoff" .= deleteFileOptionsSignoff
      ]


-- | Construct a value of type 'DeleteFileOptions' (by applying it's required fields, if any)
mkDeleteFileOptions
  :: Text -- ^ 'deleteFileOptionsSha': sha is the SHA for the file that already exists
  -> DeleteFileOptions
mkDeleteFileOptions deleteFileOptionsSha =
  DeleteFileOptions
  { deleteFileOptionsAuthor = Nothing
  , deleteFileOptionsBranch = Nothing
  , deleteFileOptionsCommitter = Nothing
  , deleteFileOptionsDates = Nothing
  , deleteFileOptionsMessage = Nothing
  , deleteFileOptionsNewBranch = Nothing
  , deleteFileOptionsSha
  , deleteFileOptionsSignoff = Nothing
  }

-- ** DeployKey
-- | DeployKey
-- DeployKey a deploy key
data DeployKey = DeployKey
  { deployKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , deployKeyFingerprint :: !(Maybe Text) -- ^ "fingerprint"
  , deployKeyId :: !(Maybe Integer) -- ^ "id"
  , deployKeyKey :: !(Maybe Text) -- ^ "key"
  , deployKeyKeyId :: !(Maybe Integer) -- ^ "key_id"
  , deployKeyReadOnly :: !(Maybe Bool) -- ^ "read_only"
  , deployKeyRepository :: !(Maybe Repository) -- ^ "repository"
  , deployKeyTitle :: !(Maybe Text) -- ^ "title"
  , deployKeyUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeployKey
instance A.FromJSON DeployKey where
  parseJSON = A.withObject "DeployKey" $ \o ->
    DeployKey
      <$> (o .:? "created_at")
      <*> (o .:? "fingerprint")
      <*> (o .:? "id")
      <*> (o .:? "key")
      <*> (o .:? "key_id")
      <*> (o .:? "read_only")
      <*> (o .:? "repository")
      <*> (o .:? "title")
      <*> (o .:? "url")

-- | ToJSON DeployKey
instance A.ToJSON DeployKey where
  toJSON DeployKey {..} =
   _omitNulls
      [ "created_at" .= deployKeyCreatedAt
      , "fingerprint" .= deployKeyFingerprint
      , "id" .= deployKeyId
      , "key" .= deployKeyKey
      , "key_id" .= deployKeyKeyId
      , "read_only" .= deployKeyReadOnly
      , "repository" .= deployKeyRepository
      , "title" .= deployKeyTitle
      , "url" .= deployKeyUrl
      ]


-- | Construct a value of type 'DeployKey' (by applying it's required fields, if any)
mkDeployKey
  :: DeployKey
mkDeployKey =
  DeployKey
  { deployKeyCreatedAt = Nothing
  , deployKeyFingerprint = Nothing
  , deployKeyId = Nothing
  , deployKeyKey = Nothing
  , deployKeyKeyId = Nothing
  , deployKeyReadOnly = Nothing
  , deployKeyRepository = Nothing
  , deployKeyTitle = Nothing
  , deployKeyUrl = Nothing
  }

-- ** DismissPullReviewOptions
-- | DismissPullReviewOptions
-- DismissPullReviewOptions are options to dismiss a pull review
data DismissPullReviewOptions = DismissPullReviewOptions
  { dismissPullReviewOptionsMessage :: !(Maybe Text) -- ^ "message"
  , dismissPullReviewOptionsPriors :: !(Maybe Bool) -- ^ "priors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DismissPullReviewOptions
instance A.FromJSON DismissPullReviewOptions where
  parseJSON = A.withObject "DismissPullReviewOptions" $ \o ->
    DismissPullReviewOptions
      <$> (o .:? "message")
      <*> (o .:? "priors")

-- | ToJSON DismissPullReviewOptions
instance A.ToJSON DismissPullReviewOptions where
  toJSON DismissPullReviewOptions {..} =
   _omitNulls
      [ "message" .= dismissPullReviewOptionsMessage
      , "priors" .= dismissPullReviewOptionsPriors
      ]


-- | Construct a value of type 'DismissPullReviewOptions' (by applying it's required fields, if any)
mkDismissPullReviewOptions
  :: DismissPullReviewOptions
mkDismissPullReviewOptions =
  DismissPullReviewOptions
  { dismissPullReviewOptionsMessage = Nothing
  , dismissPullReviewOptionsPriors = Nothing
  }

-- ** EditAttachmentOptions
-- | EditAttachmentOptions
-- EditAttachmentOptions options for editing attachments
data EditAttachmentOptions = EditAttachmentOptions
  { editAttachmentOptionsName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditAttachmentOptions
instance A.FromJSON EditAttachmentOptions where
  parseJSON = A.withObject "EditAttachmentOptions" $ \o ->
    EditAttachmentOptions
      <$> (o .:? "name")

-- | ToJSON EditAttachmentOptions
instance A.ToJSON EditAttachmentOptions where
  toJSON EditAttachmentOptions {..} =
   _omitNulls
      [ "name" .= editAttachmentOptionsName
      ]


-- | Construct a value of type 'EditAttachmentOptions' (by applying it's required fields, if any)
mkEditAttachmentOptions
  :: EditAttachmentOptions
mkEditAttachmentOptions =
  EditAttachmentOptions
  { editAttachmentOptionsName = Nothing
  }

-- ** EditBranchProtectionOption
-- | EditBranchProtectionOption
-- EditBranchProtectionOption options for editing a branch protection
data EditBranchProtectionOption = EditBranchProtectionOption
  { editBranchProtectionOptionApprovalsWhitelistTeams :: !(Maybe [Text]) -- ^ "approvals_whitelist_teams"
  , editBranchProtectionOptionApprovalsWhitelistUsername :: !(Maybe [Text]) -- ^ "approvals_whitelist_username"
  , editBranchProtectionOptionBlockOnOfficialReviewRequests :: !(Maybe Bool) -- ^ "block_on_official_review_requests"
  , editBranchProtectionOptionBlockOnOutdatedBranch :: !(Maybe Bool) -- ^ "block_on_outdated_branch"
  , editBranchProtectionOptionBlockOnRejectedReviews :: !(Maybe Bool) -- ^ "block_on_rejected_reviews"
  , editBranchProtectionOptionDismissStaleApprovals :: !(Maybe Bool) -- ^ "dismiss_stale_approvals"
  , editBranchProtectionOptionEnableApprovalsWhitelist :: !(Maybe Bool) -- ^ "enable_approvals_whitelist"
  , editBranchProtectionOptionEnableMergeWhitelist :: !(Maybe Bool) -- ^ "enable_merge_whitelist"
  , editBranchProtectionOptionEnablePush :: !(Maybe Bool) -- ^ "enable_push"
  , editBranchProtectionOptionEnablePushWhitelist :: !(Maybe Bool) -- ^ "enable_push_whitelist"
  , editBranchProtectionOptionEnableStatusCheck :: !(Maybe Bool) -- ^ "enable_status_check"
  , editBranchProtectionOptionMergeWhitelistTeams :: !(Maybe [Text]) -- ^ "merge_whitelist_teams"
  , editBranchProtectionOptionMergeWhitelistUsernames :: !(Maybe [Text]) -- ^ "merge_whitelist_usernames"
  , editBranchProtectionOptionProtectedFilePatterns :: !(Maybe Text) -- ^ "protected_file_patterns"
  , editBranchProtectionOptionPushWhitelistDeployKeys :: !(Maybe Bool) -- ^ "push_whitelist_deploy_keys"
  , editBranchProtectionOptionPushWhitelistTeams :: !(Maybe [Text]) -- ^ "push_whitelist_teams"
  , editBranchProtectionOptionPushWhitelistUsernames :: !(Maybe [Text]) -- ^ "push_whitelist_usernames"
  , editBranchProtectionOptionRequireSignedCommits :: !(Maybe Bool) -- ^ "require_signed_commits"
  , editBranchProtectionOptionRequiredApprovals :: !(Maybe Integer) -- ^ "required_approvals"
  , editBranchProtectionOptionStatusCheckContexts :: !(Maybe [Text]) -- ^ "status_check_contexts"
  , editBranchProtectionOptionUnprotectedFilePatterns :: !(Maybe Text) -- ^ "unprotected_file_patterns"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditBranchProtectionOption
instance A.FromJSON EditBranchProtectionOption where
  parseJSON = A.withObject "EditBranchProtectionOption" $ \o ->
    EditBranchProtectionOption
      <$> (o .:? "approvals_whitelist_teams")
      <*> (o .:? "approvals_whitelist_username")
      <*> (o .:? "block_on_official_review_requests")
      <*> (o .:? "block_on_outdated_branch")
      <*> (o .:? "block_on_rejected_reviews")
      <*> (o .:? "dismiss_stale_approvals")
      <*> (o .:? "enable_approvals_whitelist")
      <*> (o .:? "enable_merge_whitelist")
      <*> (o .:? "enable_push")
      <*> (o .:? "enable_push_whitelist")
      <*> (o .:? "enable_status_check")
      <*> (o .:? "merge_whitelist_teams")
      <*> (o .:? "merge_whitelist_usernames")
      <*> (o .:? "protected_file_patterns")
      <*> (o .:? "push_whitelist_deploy_keys")
      <*> (o .:? "push_whitelist_teams")
      <*> (o .:? "push_whitelist_usernames")
      <*> (o .:? "require_signed_commits")
      <*> (o .:? "required_approvals")
      <*> (o .:? "status_check_contexts")
      <*> (o .:? "unprotected_file_patterns")

-- | ToJSON EditBranchProtectionOption
instance A.ToJSON EditBranchProtectionOption where
  toJSON EditBranchProtectionOption {..} =
   _omitNulls
      [ "approvals_whitelist_teams" .= editBranchProtectionOptionApprovalsWhitelistTeams
      , "approvals_whitelist_username" .= editBranchProtectionOptionApprovalsWhitelistUsername
      , "block_on_official_review_requests" .= editBranchProtectionOptionBlockOnOfficialReviewRequests
      , "block_on_outdated_branch" .= editBranchProtectionOptionBlockOnOutdatedBranch
      , "block_on_rejected_reviews" .= editBranchProtectionOptionBlockOnRejectedReviews
      , "dismiss_stale_approvals" .= editBranchProtectionOptionDismissStaleApprovals
      , "enable_approvals_whitelist" .= editBranchProtectionOptionEnableApprovalsWhitelist
      , "enable_merge_whitelist" .= editBranchProtectionOptionEnableMergeWhitelist
      , "enable_push" .= editBranchProtectionOptionEnablePush
      , "enable_push_whitelist" .= editBranchProtectionOptionEnablePushWhitelist
      , "enable_status_check" .= editBranchProtectionOptionEnableStatusCheck
      , "merge_whitelist_teams" .= editBranchProtectionOptionMergeWhitelistTeams
      , "merge_whitelist_usernames" .= editBranchProtectionOptionMergeWhitelistUsernames
      , "protected_file_patterns" .= editBranchProtectionOptionProtectedFilePatterns
      , "push_whitelist_deploy_keys" .= editBranchProtectionOptionPushWhitelistDeployKeys
      , "push_whitelist_teams" .= editBranchProtectionOptionPushWhitelistTeams
      , "push_whitelist_usernames" .= editBranchProtectionOptionPushWhitelistUsernames
      , "require_signed_commits" .= editBranchProtectionOptionRequireSignedCommits
      , "required_approvals" .= editBranchProtectionOptionRequiredApprovals
      , "status_check_contexts" .= editBranchProtectionOptionStatusCheckContexts
      , "unprotected_file_patterns" .= editBranchProtectionOptionUnprotectedFilePatterns
      ]


-- | Construct a value of type 'EditBranchProtectionOption' (by applying it's required fields, if any)
mkEditBranchProtectionOption
  :: EditBranchProtectionOption
mkEditBranchProtectionOption =
  EditBranchProtectionOption
  { editBranchProtectionOptionApprovalsWhitelistTeams = Nothing
  , editBranchProtectionOptionApprovalsWhitelistUsername = Nothing
  , editBranchProtectionOptionBlockOnOfficialReviewRequests = Nothing
  , editBranchProtectionOptionBlockOnOutdatedBranch = Nothing
  , editBranchProtectionOptionBlockOnRejectedReviews = Nothing
  , editBranchProtectionOptionDismissStaleApprovals = Nothing
  , editBranchProtectionOptionEnableApprovalsWhitelist = Nothing
  , editBranchProtectionOptionEnableMergeWhitelist = Nothing
  , editBranchProtectionOptionEnablePush = Nothing
  , editBranchProtectionOptionEnablePushWhitelist = Nothing
  , editBranchProtectionOptionEnableStatusCheck = Nothing
  , editBranchProtectionOptionMergeWhitelistTeams = Nothing
  , editBranchProtectionOptionMergeWhitelistUsernames = Nothing
  , editBranchProtectionOptionProtectedFilePatterns = Nothing
  , editBranchProtectionOptionPushWhitelistDeployKeys = Nothing
  , editBranchProtectionOptionPushWhitelistTeams = Nothing
  , editBranchProtectionOptionPushWhitelistUsernames = Nothing
  , editBranchProtectionOptionRequireSignedCommits = Nothing
  , editBranchProtectionOptionRequiredApprovals = Nothing
  , editBranchProtectionOptionStatusCheckContexts = Nothing
  , editBranchProtectionOptionUnprotectedFilePatterns = Nothing
  }

-- ** EditDeadlineOption
-- | EditDeadlineOption
-- EditDeadlineOption options for creating a deadline
data EditDeadlineOption = EditDeadlineOption
  { editDeadlineOptionDueDate :: !(DateTime) -- ^ /Required/ "due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditDeadlineOption
instance A.FromJSON EditDeadlineOption where
  parseJSON = A.withObject "EditDeadlineOption" $ \o ->
    EditDeadlineOption
      <$> (o .:  "due_date")

-- | ToJSON EditDeadlineOption
instance A.ToJSON EditDeadlineOption where
  toJSON EditDeadlineOption {..} =
   _omitNulls
      [ "due_date" .= editDeadlineOptionDueDate
      ]


-- | Construct a value of type 'EditDeadlineOption' (by applying it's required fields, if any)
mkEditDeadlineOption
  :: DateTime -- ^ 'editDeadlineOptionDueDate' 
  -> EditDeadlineOption
mkEditDeadlineOption editDeadlineOptionDueDate =
  EditDeadlineOption
  { editDeadlineOptionDueDate
  }

-- ** EditGitHookOption
-- | EditGitHookOption
-- EditGitHookOption options when modifying one Git hook
data EditGitHookOption = EditGitHookOption
  { editGitHookOptionContent :: !(Maybe Text) -- ^ "content"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditGitHookOption
instance A.FromJSON EditGitHookOption where
  parseJSON = A.withObject "EditGitHookOption" $ \o ->
    EditGitHookOption
      <$> (o .:? "content")

-- | ToJSON EditGitHookOption
instance A.ToJSON EditGitHookOption where
  toJSON EditGitHookOption {..} =
   _omitNulls
      [ "content" .= editGitHookOptionContent
      ]


-- | Construct a value of type 'EditGitHookOption' (by applying it's required fields, if any)
mkEditGitHookOption
  :: EditGitHookOption
mkEditGitHookOption =
  EditGitHookOption
  { editGitHookOptionContent = Nothing
  }

-- ** EditHookOption
-- | EditHookOption
-- EditHookOption options when modify one hook
data EditHookOption = EditHookOption
  { editHookOptionActive :: !(Maybe Bool) -- ^ "active"
  , editHookOptionAuthorizationHeader :: !(Maybe Text) -- ^ "authorization_header"
  , editHookOptionBranchFilter :: !(Maybe Text) -- ^ "branch_filter"
  , editHookOptionConfig :: !(Maybe (Map.Map String Text)) -- ^ "config"
  , editHookOptionEvents :: !(Maybe [Text]) -- ^ "events"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditHookOption
instance A.FromJSON EditHookOption where
  parseJSON = A.withObject "EditHookOption" $ \o ->
    EditHookOption
      <$> (o .:? "active")
      <*> (o .:? "authorization_header")
      <*> (o .:? "branch_filter")
      <*> (o .:? "config")
      <*> (o .:? "events")

-- | ToJSON EditHookOption
instance A.ToJSON EditHookOption where
  toJSON EditHookOption {..} =
   _omitNulls
      [ "active" .= editHookOptionActive
      , "authorization_header" .= editHookOptionAuthorizationHeader
      , "branch_filter" .= editHookOptionBranchFilter
      , "config" .= editHookOptionConfig
      , "events" .= editHookOptionEvents
      ]


-- | Construct a value of type 'EditHookOption' (by applying it's required fields, if any)
mkEditHookOption
  :: EditHookOption
mkEditHookOption =
  EditHookOption
  { editHookOptionActive = Nothing
  , editHookOptionAuthorizationHeader = Nothing
  , editHookOptionBranchFilter = Nothing
  , editHookOptionConfig = Nothing
  , editHookOptionEvents = Nothing
  }

-- ** EditIssueCommentOption
-- | EditIssueCommentOption
-- EditIssueCommentOption options for editing a comment
data EditIssueCommentOption = EditIssueCommentOption
  { editIssueCommentOptionBody :: !(Text) -- ^ /Required/ "body"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditIssueCommentOption
instance A.FromJSON EditIssueCommentOption where
  parseJSON = A.withObject "EditIssueCommentOption" $ \o ->
    EditIssueCommentOption
      <$> (o .:  "body")

-- | ToJSON EditIssueCommentOption
instance A.ToJSON EditIssueCommentOption where
  toJSON EditIssueCommentOption {..} =
   _omitNulls
      [ "body" .= editIssueCommentOptionBody
      ]


-- | Construct a value of type 'EditIssueCommentOption' (by applying it's required fields, if any)
mkEditIssueCommentOption
  :: Text -- ^ 'editIssueCommentOptionBody' 
  -> EditIssueCommentOption
mkEditIssueCommentOption editIssueCommentOptionBody =
  EditIssueCommentOption
  { editIssueCommentOptionBody
  }

-- ** EditIssueOption
-- | EditIssueOption
-- EditIssueOption options for editing an issue
data EditIssueOption = EditIssueOption
  { editIssueOptionAssignee :: !(Maybe Text) -- ^ "assignee" - deprecated
  , editIssueOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , editIssueOptionBody :: !(Maybe Text) -- ^ "body"
  , editIssueOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , editIssueOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , editIssueOptionRef :: !(Maybe Text) -- ^ "ref"
  , editIssueOptionState :: !(Maybe Text) -- ^ "state"
  , editIssueOptionTitle :: !(Maybe Text) -- ^ "title"
  , editIssueOptionUnsetDueDate :: !(Maybe Bool) -- ^ "unset_due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditIssueOption
instance A.FromJSON EditIssueOption where
  parseJSON = A.withObject "EditIssueOption" $ \o ->
    EditIssueOption
      <$> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "milestone")
      <*> (o .:? "ref")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "unset_due_date")

-- | ToJSON EditIssueOption
instance A.ToJSON EditIssueOption where
  toJSON EditIssueOption {..} =
   _omitNulls
      [ "assignee" .= editIssueOptionAssignee
      , "assignees" .= editIssueOptionAssignees
      , "body" .= editIssueOptionBody
      , "due_date" .= editIssueOptionDueDate
      , "milestone" .= editIssueOptionMilestone
      , "ref" .= editIssueOptionRef
      , "state" .= editIssueOptionState
      , "title" .= editIssueOptionTitle
      , "unset_due_date" .= editIssueOptionUnsetDueDate
      ]


-- | Construct a value of type 'EditIssueOption' (by applying it's required fields, if any)
mkEditIssueOption
  :: EditIssueOption
mkEditIssueOption =
  EditIssueOption
  { editIssueOptionAssignee = Nothing
  , editIssueOptionAssignees = Nothing
  , editIssueOptionBody = Nothing
  , editIssueOptionDueDate = Nothing
  , editIssueOptionMilestone = Nothing
  , editIssueOptionRef = Nothing
  , editIssueOptionState = Nothing
  , editIssueOptionTitle = Nothing
  , editIssueOptionUnsetDueDate = Nothing
  }

-- ** EditLabelOption
-- | EditLabelOption
-- EditLabelOption options for editing a label
data EditLabelOption = EditLabelOption
  { editLabelOptionColor :: !(Maybe Text) -- ^ "color"
  , editLabelOptionDescription :: !(Maybe Text) -- ^ "description"
  , editLabelOptionExclusive :: !(Maybe Bool) -- ^ "exclusive"
  , editLabelOptionName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditLabelOption
instance A.FromJSON EditLabelOption where
  parseJSON = A.withObject "EditLabelOption" $ \o ->
    EditLabelOption
      <$> (o .:? "color")
      <*> (o .:? "description")
      <*> (o .:? "exclusive")
      <*> (o .:? "name")

-- | ToJSON EditLabelOption
instance A.ToJSON EditLabelOption where
  toJSON EditLabelOption {..} =
   _omitNulls
      [ "color" .= editLabelOptionColor
      , "description" .= editLabelOptionDescription
      , "exclusive" .= editLabelOptionExclusive
      , "name" .= editLabelOptionName
      ]


-- | Construct a value of type 'EditLabelOption' (by applying it's required fields, if any)
mkEditLabelOption
  :: EditLabelOption
mkEditLabelOption =
  EditLabelOption
  { editLabelOptionColor = Nothing
  , editLabelOptionDescription = Nothing
  , editLabelOptionExclusive = Nothing
  , editLabelOptionName = Nothing
  }

-- ** EditMilestoneOption
-- | EditMilestoneOption
-- EditMilestoneOption options for editing a milestone
data EditMilestoneOption = EditMilestoneOption
  { editMilestoneOptionDescription :: !(Maybe Text) -- ^ "description"
  , editMilestoneOptionDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , editMilestoneOptionState :: !(Maybe Text) -- ^ "state"
  , editMilestoneOptionTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditMilestoneOption
instance A.FromJSON EditMilestoneOption where
  parseJSON = A.withObject "EditMilestoneOption" $ \o ->
    EditMilestoneOption
      <$> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "state")
      <*> (o .:? "title")

-- | ToJSON EditMilestoneOption
instance A.ToJSON EditMilestoneOption where
  toJSON EditMilestoneOption {..} =
   _omitNulls
      [ "description" .= editMilestoneOptionDescription
      , "due_on" .= editMilestoneOptionDueOn
      , "state" .= editMilestoneOptionState
      , "title" .= editMilestoneOptionTitle
      ]


-- | Construct a value of type 'EditMilestoneOption' (by applying it's required fields, if any)
mkEditMilestoneOption
  :: EditMilestoneOption
mkEditMilestoneOption =
  EditMilestoneOption
  { editMilestoneOptionDescription = Nothing
  , editMilestoneOptionDueOn = Nothing
  , editMilestoneOptionState = Nothing
  , editMilestoneOptionTitle = Nothing
  }

-- ** EditOrgOption
-- | EditOrgOption
-- EditOrgOption options for editing an organization
data EditOrgOption = EditOrgOption
  { editOrgOptionDescription :: !(Maybe Text) -- ^ "description"
  , editOrgOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , editOrgOptionLocation :: !(Maybe Text) -- ^ "location"
  , editOrgOptionRepoAdminChangeTeamAccess :: !(Maybe Bool) -- ^ "repo_admin_change_team_access"
  , editOrgOptionVisibility :: !(Maybe E'Visibility) -- ^ "visibility" - possible values are &#x60;public&#x60;, &#x60;limited&#x60; or &#x60;private&#x60;
  , editOrgOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditOrgOption
instance A.FromJSON EditOrgOption where
  parseJSON = A.withObject "EditOrgOption" $ \o ->
    EditOrgOption
      <$> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:? "repo_admin_change_team_access")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON EditOrgOption
instance A.ToJSON EditOrgOption where
  toJSON EditOrgOption {..} =
   _omitNulls
      [ "description" .= editOrgOptionDescription
      , "full_name" .= editOrgOptionFullName
      , "location" .= editOrgOptionLocation
      , "repo_admin_change_team_access" .= editOrgOptionRepoAdminChangeTeamAccess
      , "visibility" .= editOrgOptionVisibility
      , "website" .= editOrgOptionWebsite
      ]


-- | Construct a value of type 'EditOrgOption' (by applying it's required fields, if any)
mkEditOrgOption
  :: EditOrgOption
mkEditOrgOption =
  EditOrgOption
  { editOrgOptionDescription = Nothing
  , editOrgOptionFullName = Nothing
  , editOrgOptionLocation = Nothing
  , editOrgOptionRepoAdminChangeTeamAccess = Nothing
  , editOrgOptionVisibility = Nothing
  , editOrgOptionWebsite = Nothing
  }

-- ** EditPullRequestOption
-- | EditPullRequestOption
-- EditPullRequestOption options when modify pull request
data EditPullRequestOption = EditPullRequestOption
  { editPullRequestOptionAllowMaintainerEdit :: !(Maybe Bool) -- ^ "allow_maintainer_edit"
  , editPullRequestOptionAssignee :: !(Maybe Text) -- ^ "assignee"
  , editPullRequestOptionAssignees :: !(Maybe [Text]) -- ^ "assignees"
  , editPullRequestOptionBase :: !(Maybe Text) -- ^ "base"
  , editPullRequestOptionBody :: !(Maybe Text) -- ^ "body"
  , editPullRequestOptionDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , editPullRequestOptionLabels :: !(Maybe [Integer]) -- ^ "labels"
  , editPullRequestOptionMilestone :: !(Maybe Integer) -- ^ "milestone"
  , editPullRequestOptionState :: !(Maybe Text) -- ^ "state"
  , editPullRequestOptionTitle :: !(Maybe Text) -- ^ "title"
  , editPullRequestOptionUnsetDueDate :: !(Maybe Bool) -- ^ "unset_due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditPullRequestOption
instance A.FromJSON EditPullRequestOption where
  parseJSON = A.withObject "EditPullRequestOption" $ \o ->
    EditPullRequestOption
      <$> (o .:? "allow_maintainer_edit")
      <*> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "base")
      <*> (o .:? "body")
      <*> (o .:? "due_date")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "unset_due_date")

-- | ToJSON EditPullRequestOption
instance A.ToJSON EditPullRequestOption where
  toJSON EditPullRequestOption {..} =
   _omitNulls
      [ "allow_maintainer_edit" .= editPullRequestOptionAllowMaintainerEdit
      , "assignee" .= editPullRequestOptionAssignee
      , "assignees" .= editPullRequestOptionAssignees
      , "base" .= editPullRequestOptionBase
      , "body" .= editPullRequestOptionBody
      , "due_date" .= editPullRequestOptionDueDate
      , "labels" .= editPullRequestOptionLabels
      , "milestone" .= editPullRequestOptionMilestone
      , "state" .= editPullRequestOptionState
      , "title" .= editPullRequestOptionTitle
      , "unset_due_date" .= editPullRequestOptionUnsetDueDate
      ]


-- | Construct a value of type 'EditPullRequestOption' (by applying it's required fields, if any)
mkEditPullRequestOption
  :: EditPullRequestOption
mkEditPullRequestOption =
  EditPullRequestOption
  { editPullRequestOptionAllowMaintainerEdit = Nothing
  , editPullRequestOptionAssignee = Nothing
  , editPullRequestOptionAssignees = Nothing
  , editPullRequestOptionBase = Nothing
  , editPullRequestOptionBody = Nothing
  , editPullRequestOptionDueDate = Nothing
  , editPullRequestOptionLabels = Nothing
  , editPullRequestOptionMilestone = Nothing
  , editPullRequestOptionState = Nothing
  , editPullRequestOptionTitle = Nothing
  , editPullRequestOptionUnsetDueDate = Nothing
  }

-- ** EditReactionOption
-- | EditReactionOption
-- EditReactionOption contain the reaction type
data EditReactionOption = EditReactionOption
  { editReactionOptionContent :: !(Maybe Text) -- ^ "content"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditReactionOption
instance A.FromJSON EditReactionOption where
  parseJSON = A.withObject "EditReactionOption" $ \o ->
    EditReactionOption
      <$> (o .:? "content")

-- | ToJSON EditReactionOption
instance A.ToJSON EditReactionOption where
  toJSON EditReactionOption {..} =
   _omitNulls
      [ "content" .= editReactionOptionContent
      ]


-- | Construct a value of type 'EditReactionOption' (by applying it's required fields, if any)
mkEditReactionOption
  :: EditReactionOption
mkEditReactionOption =
  EditReactionOption
  { editReactionOptionContent = Nothing
  }

-- ** EditReleaseOption
-- | EditReleaseOption
-- EditReleaseOption options when editing a release
data EditReleaseOption = EditReleaseOption
  { editReleaseOptionBody :: !(Maybe Text) -- ^ "body"
  , editReleaseOptionDraft :: !(Maybe Bool) -- ^ "draft"
  , editReleaseOptionName :: !(Maybe Text) -- ^ "name"
  , editReleaseOptionPrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , editReleaseOptionTagName :: !(Maybe Text) -- ^ "tag_name"
  , editReleaseOptionTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditReleaseOption
instance A.FromJSON EditReleaseOption where
  parseJSON = A.withObject "EditReleaseOption" $ \o ->
    EditReleaseOption
      <$> (o .:? "body")
      <*> (o .:? "draft")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:? "tag_name")
      <*> (o .:? "target_commitish")

-- | ToJSON EditReleaseOption
instance A.ToJSON EditReleaseOption where
  toJSON EditReleaseOption {..} =
   _omitNulls
      [ "body" .= editReleaseOptionBody
      , "draft" .= editReleaseOptionDraft
      , "name" .= editReleaseOptionName
      , "prerelease" .= editReleaseOptionPrerelease
      , "tag_name" .= editReleaseOptionTagName
      , "target_commitish" .= editReleaseOptionTargetCommitish
      ]


-- | Construct a value of type 'EditReleaseOption' (by applying it's required fields, if any)
mkEditReleaseOption
  :: EditReleaseOption
mkEditReleaseOption =
  EditReleaseOption
  { editReleaseOptionBody = Nothing
  , editReleaseOptionDraft = Nothing
  , editReleaseOptionName = Nothing
  , editReleaseOptionPrerelease = Nothing
  , editReleaseOptionTagName = Nothing
  , editReleaseOptionTargetCommitish = Nothing
  }

-- ** EditRepoOption
-- | EditRepoOption
-- EditRepoOption options when editing a repository's properties
data EditRepoOption = EditRepoOption
  { editRepoOptionAllowManualMerge :: !(Maybe Bool) -- ^ "allow_manual_merge" - either &#x60;true&#x60; to allow mark pr as merged manually, or &#x60;false&#x60; to prevent it.
  , editRepoOptionAllowMergeCommits :: !(Maybe Bool) -- ^ "allow_merge_commits" - either &#x60;true&#x60; to allow merging pull requests with a merge commit, or &#x60;false&#x60; to prevent merging pull requests with merge commits.
  , editRepoOptionAllowRebase :: !(Maybe Bool) -- ^ "allow_rebase" - either &#x60;true&#x60; to allow rebase-merging pull requests, or &#x60;false&#x60; to prevent rebase-merging.
  , editRepoOptionAllowRebaseExplicit :: !(Maybe Bool) -- ^ "allow_rebase_explicit" - either &#x60;true&#x60; to allow rebase with explicit merge commits (--no-ff), or &#x60;false&#x60; to prevent rebase with explicit merge commits.
  , editRepoOptionAllowRebaseUpdate :: !(Maybe Bool) -- ^ "allow_rebase_update" - either &#x60;true&#x60; to allow updating pull request branch by rebase, or &#x60;false&#x60; to prevent it.
  , editRepoOptionAllowSquashMerge :: !(Maybe Bool) -- ^ "allow_squash_merge" - either &#x60;true&#x60; to allow squash-merging pull requests, or &#x60;false&#x60; to prevent squash-merging.
  , editRepoOptionArchived :: !(Maybe Bool) -- ^ "archived" - set to &#x60;true&#x60; to archive this repository.
  , editRepoOptionAutodetectManualMerge :: !(Maybe Bool) -- ^ "autodetect_manual_merge" - either &#x60;true&#x60; to enable AutodetectManualMerge, or &#x60;false&#x60; to prevent it. Note: In some special cases, misjudgments can occur.
  , editRepoOptionDefaultAllowMaintainerEdit :: !(Maybe Bool) -- ^ "default_allow_maintainer_edit" - set to &#x60;true&#x60; to allow edits from maintainers by default
  , editRepoOptionDefaultBranch :: !(Maybe Text) -- ^ "default_branch" - sets the default branch for this repository.
  , editRepoOptionDefaultDeleteBranchAfterMerge :: !(Maybe Bool) -- ^ "default_delete_branch_after_merge" - set to &#x60;true&#x60; to delete pr branch after merge by default
  , editRepoOptionDefaultMergeStyle :: !(Maybe Text) -- ^ "default_merge_style" - set to a merge style to be used by this repository: \&quot;merge\&quot;, \&quot;rebase\&quot;, \&quot;rebase-merge\&quot;, or \&quot;squash\&quot;.
  , editRepoOptionDescription :: !(Maybe Text) -- ^ "description" - a short description of the repository.
  , editRepoOptionEnablePrune :: !(Maybe Bool) -- ^ "enable_prune" - enable prune - remove obsolete remote-tracking references
  , editRepoOptionExternalTracker :: !(Maybe ExternalTracker) -- ^ "external_tracker"
  , editRepoOptionExternalWiki :: !(Maybe ExternalWiki) -- ^ "external_wiki"
  , editRepoOptionHasActions :: !(Maybe Bool) -- ^ "has_actions" - either &#x60;true&#x60; to enable actions unit, or &#x60;false&#x60; to disable them.
  , editRepoOptionHasIssues :: !(Maybe Bool) -- ^ "has_issues" - either &#x60;true&#x60; to enable issues for this repository or &#x60;false&#x60; to disable them.
  , editRepoOptionHasPackages :: !(Maybe Bool) -- ^ "has_packages" - either &#x60;true&#x60; to enable packages unit, or &#x60;false&#x60; to disable them.
  , editRepoOptionHasProjects :: !(Maybe Bool) -- ^ "has_projects" - either &#x60;true&#x60; to enable project unit, or &#x60;false&#x60; to disable them.
  , editRepoOptionHasPullRequests :: !(Maybe Bool) -- ^ "has_pull_requests" - either &#x60;true&#x60; to allow pull requests, or &#x60;false&#x60; to prevent pull request.
  , editRepoOptionHasReleases :: !(Maybe Bool) -- ^ "has_releases" - either &#x60;true&#x60; to enable releases unit, or &#x60;false&#x60; to disable them.
  , editRepoOptionHasWiki :: !(Maybe Bool) -- ^ "has_wiki" - either &#x60;true&#x60; to enable the wiki for this repository or &#x60;false&#x60; to disable it.
  , editRepoOptionIgnoreWhitespaceConflicts :: !(Maybe Bool) -- ^ "ignore_whitespace_conflicts" - either &#x60;true&#x60; to ignore whitespace for conflicts, or &#x60;false&#x60; to not ignore whitespace.
  , editRepoOptionInternalTracker :: !(Maybe InternalTracker) -- ^ "internal_tracker"
  , editRepoOptionMirrorInterval :: !(Maybe Text) -- ^ "mirror_interval" - set to a string like &#x60;8h30m0s&#x60; to set the mirror interval time
  , editRepoOptionName :: !(Maybe Text) -- ^ "name" - name of the repository
  , editRepoOptionPrivate :: !(Maybe Bool) -- ^ "private" - either &#x60;true&#x60; to make the repository private or &#x60;false&#x60; to make it public. Note: you will get a 422 error if the organization restricts changing repository visibility to organization owners and a non-owner tries to change the value of private.
  , editRepoOptionTemplate :: !(Maybe Bool) -- ^ "template" - either &#x60;true&#x60; to make this repository a template or &#x60;false&#x60; to make it a normal repository
  , editRepoOptionWebsite :: !(Maybe Text) -- ^ "website" - a URL with more information about the repository.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditRepoOption
instance A.FromJSON EditRepoOption where
  parseJSON = A.withObject "EditRepoOption" $ \o ->
    EditRepoOption
      <$> (o .:? "allow_manual_merge")
      <*> (o .:? "allow_merge_commits")
      <*> (o .:? "allow_rebase")
      <*> (o .:? "allow_rebase_explicit")
      <*> (o .:? "allow_rebase_update")
      <*> (o .:? "allow_squash_merge")
      <*> (o .:? "archived")
      <*> (o .:? "autodetect_manual_merge")
      <*> (o .:? "default_allow_maintainer_edit")
      <*> (o .:? "default_branch")
      <*> (o .:? "default_delete_branch_after_merge")
      <*> (o .:? "default_merge_style")
      <*> (o .:? "description")
      <*> (o .:? "enable_prune")
      <*> (o .:? "external_tracker")
      <*> (o .:? "external_wiki")
      <*> (o .:? "has_actions")
      <*> (o .:? "has_issues")
      <*> (o .:? "has_packages")
      <*> (o .:? "has_projects")
      <*> (o .:? "has_pull_requests")
      <*> (o .:? "has_releases")
      <*> (o .:? "has_wiki")
      <*> (o .:? "ignore_whitespace_conflicts")
      <*> (o .:? "internal_tracker")
      <*> (o .:? "mirror_interval")
      <*> (o .:? "name")
      <*> (o .:? "private")
      <*> (o .:? "template")
      <*> (o .:? "website")

-- | ToJSON EditRepoOption
instance A.ToJSON EditRepoOption where
  toJSON EditRepoOption {..} =
   _omitNulls
      [ "allow_manual_merge" .= editRepoOptionAllowManualMerge
      , "allow_merge_commits" .= editRepoOptionAllowMergeCommits
      , "allow_rebase" .= editRepoOptionAllowRebase
      , "allow_rebase_explicit" .= editRepoOptionAllowRebaseExplicit
      , "allow_rebase_update" .= editRepoOptionAllowRebaseUpdate
      , "allow_squash_merge" .= editRepoOptionAllowSquashMerge
      , "archived" .= editRepoOptionArchived
      , "autodetect_manual_merge" .= editRepoOptionAutodetectManualMerge
      , "default_allow_maintainer_edit" .= editRepoOptionDefaultAllowMaintainerEdit
      , "default_branch" .= editRepoOptionDefaultBranch
      , "default_delete_branch_after_merge" .= editRepoOptionDefaultDeleteBranchAfterMerge
      , "default_merge_style" .= editRepoOptionDefaultMergeStyle
      , "description" .= editRepoOptionDescription
      , "enable_prune" .= editRepoOptionEnablePrune
      , "external_tracker" .= editRepoOptionExternalTracker
      , "external_wiki" .= editRepoOptionExternalWiki
      , "has_actions" .= editRepoOptionHasActions
      , "has_issues" .= editRepoOptionHasIssues
      , "has_packages" .= editRepoOptionHasPackages
      , "has_projects" .= editRepoOptionHasProjects
      , "has_pull_requests" .= editRepoOptionHasPullRequests
      , "has_releases" .= editRepoOptionHasReleases
      , "has_wiki" .= editRepoOptionHasWiki
      , "ignore_whitespace_conflicts" .= editRepoOptionIgnoreWhitespaceConflicts
      , "internal_tracker" .= editRepoOptionInternalTracker
      , "mirror_interval" .= editRepoOptionMirrorInterval
      , "name" .= editRepoOptionName
      , "private" .= editRepoOptionPrivate
      , "template" .= editRepoOptionTemplate
      , "website" .= editRepoOptionWebsite
      ]


-- | Construct a value of type 'EditRepoOption' (by applying it's required fields, if any)
mkEditRepoOption
  :: EditRepoOption
mkEditRepoOption =
  EditRepoOption
  { editRepoOptionAllowManualMerge = Nothing
  , editRepoOptionAllowMergeCommits = Nothing
  , editRepoOptionAllowRebase = Nothing
  , editRepoOptionAllowRebaseExplicit = Nothing
  , editRepoOptionAllowRebaseUpdate = Nothing
  , editRepoOptionAllowSquashMerge = Nothing
  , editRepoOptionArchived = Nothing
  , editRepoOptionAutodetectManualMerge = Nothing
  , editRepoOptionDefaultAllowMaintainerEdit = Nothing
  , editRepoOptionDefaultBranch = Nothing
  , editRepoOptionDefaultDeleteBranchAfterMerge = Nothing
  , editRepoOptionDefaultMergeStyle = Nothing
  , editRepoOptionDescription = Nothing
  , editRepoOptionEnablePrune = Nothing
  , editRepoOptionExternalTracker = Nothing
  , editRepoOptionExternalWiki = Nothing
  , editRepoOptionHasActions = Nothing
  , editRepoOptionHasIssues = Nothing
  , editRepoOptionHasPackages = Nothing
  , editRepoOptionHasProjects = Nothing
  , editRepoOptionHasPullRequests = Nothing
  , editRepoOptionHasReleases = Nothing
  , editRepoOptionHasWiki = Nothing
  , editRepoOptionIgnoreWhitespaceConflicts = Nothing
  , editRepoOptionInternalTracker = Nothing
  , editRepoOptionMirrorInterval = Nothing
  , editRepoOptionName = Nothing
  , editRepoOptionPrivate = Nothing
  , editRepoOptionTemplate = Nothing
  , editRepoOptionWebsite = Nothing
  }

-- ** EditTeamOption
-- | EditTeamOption
-- EditTeamOption options for editing a team
data EditTeamOption = EditTeamOption
  { editTeamOptionCanCreateOrgRepo :: !(Maybe Bool) -- ^ "can_create_org_repo"
  , editTeamOptionDescription :: !(Maybe Text) -- ^ "description"
  , editTeamOptionIncludesAllRepositories :: !(Maybe Bool) -- ^ "includes_all_repositories"
  , editTeamOptionName :: !(Text) -- ^ /Required/ "name"
  , editTeamOptionPermission :: !(Maybe E'Permission) -- ^ "permission"
  , editTeamOptionUnits :: !(Maybe [Text]) -- ^ "units"
  , editTeamOptionUnitsMap :: !(Maybe (Map.Map String Text)) -- ^ "units_map"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditTeamOption
instance A.FromJSON EditTeamOption where
  parseJSON = A.withObject "EditTeamOption" $ \o ->
    EditTeamOption
      <$> (o .:? "can_create_org_repo")
      <*> (o .:? "description")
      <*> (o .:? "includes_all_repositories")
      <*> (o .:  "name")
      <*> (o .:? "permission")
      <*> (o .:? "units")
      <*> (o .:? "units_map")

-- | ToJSON EditTeamOption
instance A.ToJSON EditTeamOption where
  toJSON EditTeamOption {..} =
   _omitNulls
      [ "can_create_org_repo" .= editTeamOptionCanCreateOrgRepo
      , "description" .= editTeamOptionDescription
      , "includes_all_repositories" .= editTeamOptionIncludesAllRepositories
      , "name" .= editTeamOptionName
      , "permission" .= editTeamOptionPermission
      , "units" .= editTeamOptionUnits
      , "units_map" .= editTeamOptionUnitsMap
      ]


-- | Construct a value of type 'EditTeamOption' (by applying it's required fields, if any)
mkEditTeamOption
  :: Text -- ^ 'editTeamOptionName' 
  -> EditTeamOption
mkEditTeamOption editTeamOptionName =
  EditTeamOption
  { editTeamOptionCanCreateOrgRepo = Nothing
  , editTeamOptionDescription = Nothing
  , editTeamOptionIncludesAllRepositories = Nothing
  , editTeamOptionName
  , editTeamOptionPermission = Nothing
  , editTeamOptionUnits = Nothing
  , editTeamOptionUnitsMap = Nothing
  }

-- ** EditUserOption
-- | EditUserOption
-- EditUserOption edit user options
data EditUserOption = EditUserOption
  { editUserOptionActive :: !(Maybe Bool) -- ^ "active"
  , editUserOptionAdmin :: !(Maybe Bool) -- ^ "admin"
  , editUserOptionAllowCreateOrganization :: !(Maybe Bool) -- ^ "allow_create_organization"
  , editUserOptionAllowGitHook :: !(Maybe Bool) -- ^ "allow_git_hook"
  , editUserOptionAllowImportLocal :: !(Maybe Bool) -- ^ "allow_import_local"
  , editUserOptionDescription :: !(Maybe Text) -- ^ "description"
  , editUserOptionEmail :: !(Maybe Text) -- ^ "email"
  , editUserOptionFullName :: !(Maybe Text) -- ^ "full_name"
  , editUserOptionLocation :: !(Maybe Text) -- ^ "location"
  , editUserOptionLoginName :: !(Text) -- ^ /Required/ "login_name"
  , editUserOptionMaxRepoCreation :: !(Maybe Integer) -- ^ "max_repo_creation"
  , editUserOptionMustChangePassword :: !(Maybe Bool) -- ^ "must_change_password"
  , editUserOptionPassword :: !(Maybe Text) -- ^ "password"
  , editUserOptionProhibitLogin :: !(Maybe Bool) -- ^ "prohibit_login"
  , editUserOptionRestricted :: !(Maybe Bool) -- ^ "restricted"
  , editUserOptionSourceId :: !(Integer) -- ^ /Required/ "source_id"
  , editUserOptionVisibility :: !(Maybe Text) -- ^ "visibility"
  , editUserOptionWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EditUserOption
instance A.FromJSON EditUserOption where
  parseJSON = A.withObject "EditUserOption" $ \o ->
    EditUserOption
      <$> (o .:? "active")
      <*> (o .:? "admin")
      <*> (o .:? "allow_create_organization")
      <*> (o .:? "allow_git_hook")
      <*> (o .:? "allow_import_local")
      <*> (o .:? "description")
      <*> (o .:? "email")
      <*> (o .:? "full_name")
      <*> (o .:? "location")
      <*> (o .:  "login_name")
      <*> (o .:? "max_repo_creation")
      <*> (o .:? "must_change_password")
      <*> (o .:? "password")
      <*> (o .:? "prohibit_login")
      <*> (o .:? "restricted")
      <*> (o .:  "source_id")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON EditUserOption
instance A.ToJSON EditUserOption where
  toJSON EditUserOption {..} =
   _omitNulls
      [ "active" .= editUserOptionActive
      , "admin" .= editUserOptionAdmin
      , "allow_create_organization" .= editUserOptionAllowCreateOrganization
      , "allow_git_hook" .= editUserOptionAllowGitHook
      , "allow_import_local" .= editUserOptionAllowImportLocal
      , "description" .= editUserOptionDescription
      , "email" .= editUserOptionEmail
      , "full_name" .= editUserOptionFullName
      , "location" .= editUserOptionLocation
      , "login_name" .= editUserOptionLoginName
      , "max_repo_creation" .= editUserOptionMaxRepoCreation
      , "must_change_password" .= editUserOptionMustChangePassword
      , "password" .= editUserOptionPassword
      , "prohibit_login" .= editUserOptionProhibitLogin
      , "restricted" .= editUserOptionRestricted
      , "source_id" .= editUserOptionSourceId
      , "visibility" .= editUserOptionVisibility
      , "website" .= editUserOptionWebsite
      ]


-- | Construct a value of type 'EditUserOption' (by applying it's required fields, if any)
mkEditUserOption
  :: Text -- ^ 'editUserOptionLoginName' 
  -> Integer -- ^ 'editUserOptionSourceId' 
  -> EditUserOption
mkEditUserOption editUserOptionLoginName editUserOptionSourceId =
  EditUserOption
  { editUserOptionActive = Nothing
  , editUserOptionAdmin = Nothing
  , editUserOptionAllowCreateOrganization = Nothing
  , editUserOptionAllowGitHook = Nothing
  , editUserOptionAllowImportLocal = Nothing
  , editUserOptionDescription = Nothing
  , editUserOptionEmail = Nothing
  , editUserOptionFullName = Nothing
  , editUserOptionLocation = Nothing
  , editUserOptionLoginName
  , editUserOptionMaxRepoCreation = Nothing
  , editUserOptionMustChangePassword = Nothing
  , editUserOptionPassword = Nothing
  , editUserOptionProhibitLogin = Nothing
  , editUserOptionRestricted = Nothing
  , editUserOptionSourceId
  , editUserOptionVisibility = Nothing
  , editUserOptionWebsite = Nothing
  }

-- ** Email
-- | Email
-- Email an email address belonging to a user
data Email = Email
  { emailEmail :: !(Maybe Text) -- ^ "email"
  , emailPrimary :: !(Maybe Bool) -- ^ "primary"
  , emailUserId :: !(Maybe Integer) -- ^ "user_id"
  , emailUsername :: !(Maybe Text) -- ^ "username"
  , emailVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Email
instance A.FromJSON Email where
  parseJSON = A.withObject "Email" $ \o ->
    Email
      <$> (o .:? "email")
      <*> (o .:? "primary")
      <*> (o .:? "user_id")
      <*> (o .:? "username")
      <*> (o .:? "verified")

-- | ToJSON Email
instance A.ToJSON Email where
  toJSON Email {..} =
   _omitNulls
      [ "email" .= emailEmail
      , "primary" .= emailPrimary
      , "user_id" .= emailUserId
      , "username" .= emailUsername
      , "verified" .= emailVerified
      ]


-- | Construct a value of type 'Email' (by applying it's required fields, if any)
mkEmail
  :: Email
mkEmail =
  Email
  { emailEmail = Nothing
  , emailPrimary = Nothing
  , emailUserId = Nothing
  , emailUsername = Nothing
  , emailVerified = Nothing
  }

-- ** ExternalTracker
-- | ExternalTracker
-- ExternalTracker represents settings for external tracker
data ExternalTracker = ExternalTracker
  { externalTrackerExternalTrackerFormat :: !(Maybe Text) -- ^ "external_tracker_format" - External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.
  , externalTrackerExternalTrackerRegexpPattern :: !(Maybe Text) -- ^ "external_tracker_regexp_pattern" - External Issue Tracker issue regular expression
  , externalTrackerExternalTrackerStyle :: !(Maybe Text) -- ^ "external_tracker_style" - External Issue Tracker Number Format, either &#x60;numeric&#x60;, &#x60;alphanumeric&#x60;, or &#x60;regexp&#x60;
  , externalTrackerExternalTrackerUrl :: !(Maybe Text) -- ^ "external_tracker_url" - URL of external issue tracker.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExternalTracker
instance A.FromJSON ExternalTracker where
  parseJSON = A.withObject "ExternalTracker" $ \o ->
    ExternalTracker
      <$> (o .:? "external_tracker_format")
      <*> (o .:? "external_tracker_regexp_pattern")
      <*> (o .:? "external_tracker_style")
      <*> (o .:? "external_tracker_url")

-- | ToJSON ExternalTracker
instance A.ToJSON ExternalTracker where
  toJSON ExternalTracker {..} =
   _omitNulls
      [ "external_tracker_format" .= externalTrackerExternalTrackerFormat
      , "external_tracker_regexp_pattern" .= externalTrackerExternalTrackerRegexpPattern
      , "external_tracker_style" .= externalTrackerExternalTrackerStyle
      , "external_tracker_url" .= externalTrackerExternalTrackerUrl
      ]


-- | Construct a value of type 'ExternalTracker' (by applying it's required fields, if any)
mkExternalTracker
  :: ExternalTracker
mkExternalTracker =
  ExternalTracker
  { externalTrackerExternalTrackerFormat = Nothing
  , externalTrackerExternalTrackerRegexpPattern = Nothing
  , externalTrackerExternalTrackerStyle = Nothing
  , externalTrackerExternalTrackerUrl = Nothing
  }

-- ** ExternalWiki
-- | ExternalWiki
-- ExternalWiki represents setting for external wiki
data ExternalWiki = ExternalWiki
  { externalWikiExternalWikiUrl :: !(Maybe Text) -- ^ "external_wiki_url" - URL of external wiki.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExternalWiki
instance A.FromJSON ExternalWiki where
  parseJSON = A.withObject "ExternalWiki" $ \o ->
    ExternalWiki
      <$> (o .:? "external_wiki_url")

-- | ToJSON ExternalWiki
instance A.ToJSON ExternalWiki where
  toJSON ExternalWiki {..} =
   _omitNulls
      [ "external_wiki_url" .= externalWikiExternalWikiUrl
      ]


-- | Construct a value of type 'ExternalWiki' (by applying it's required fields, if any)
mkExternalWiki
  :: ExternalWiki
mkExternalWiki =
  ExternalWiki
  { externalWikiExternalWikiUrl = Nothing
  }

-- ** FileCommitResponse
-- | FileCommitResponse
-- FileCommitResponse contains information generated from a Git commit for a repo's file.
-- 
data FileCommitResponse = FileCommitResponse
  { fileCommitResponseAuthor :: !(Maybe CommitUser) -- ^ "author"
  , fileCommitResponseCommitter :: !(Maybe CommitUser) -- ^ "committer"
  , fileCommitResponseCreated :: !(Maybe DateTime) -- ^ "created"
  , fileCommitResponseHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , fileCommitResponseMessage :: !(Maybe Text) -- ^ "message"
  , fileCommitResponseParents :: !(Maybe [CommitMeta]) -- ^ "parents"
  , fileCommitResponseSha :: !(Maybe Text) -- ^ "sha"
  , fileCommitResponseTree :: !(Maybe CommitMeta) -- ^ "tree"
  , fileCommitResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileCommitResponse
instance A.FromJSON FileCommitResponse where
  parseJSON = A.withObject "FileCommitResponse" $ \o ->
    FileCommitResponse
      <$> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "created")
      <*> (o .:? "html_url")
      <*> (o .:? "message")
      <*> (o .:? "parents")
      <*> (o .:? "sha")
      <*> (o .:? "tree")
      <*> (o .:? "url")

-- | ToJSON FileCommitResponse
instance A.ToJSON FileCommitResponse where
  toJSON FileCommitResponse {..} =
   _omitNulls
      [ "author" .= fileCommitResponseAuthor
      , "committer" .= fileCommitResponseCommitter
      , "created" .= fileCommitResponseCreated
      , "html_url" .= fileCommitResponseHtmlUrl
      , "message" .= fileCommitResponseMessage
      , "parents" .= fileCommitResponseParents
      , "sha" .= fileCommitResponseSha
      , "tree" .= fileCommitResponseTree
      , "url" .= fileCommitResponseUrl
      ]


-- | Construct a value of type 'FileCommitResponse' (by applying it's required fields, if any)
mkFileCommitResponse
  :: FileCommitResponse
mkFileCommitResponse =
  FileCommitResponse
  { fileCommitResponseAuthor = Nothing
  , fileCommitResponseCommitter = Nothing
  , fileCommitResponseCreated = Nothing
  , fileCommitResponseHtmlUrl = Nothing
  , fileCommitResponseMessage = Nothing
  , fileCommitResponseParents = Nothing
  , fileCommitResponseSha = Nothing
  , fileCommitResponseTree = Nothing
  , fileCommitResponseUrl = Nothing
  }

-- ** FileDeleteResponse
-- | FileDeleteResponse
-- FileDeleteResponse contains information about a repo's file that was deleted
data FileDeleteResponse = FileDeleteResponse
  { fileDeleteResponseCommit :: !(Maybe FileCommitResponse) -- ^ "commit"
  , fileDeleteResponseContent :: !(Maybe A.Value) -- ^ "content"
  , fileDeleteResponseVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileDeleteResponse
instance A.FromJSON FileDeleteResponse where
  parseJSON = A.withObject "FileDeleteResponse" $ \o ->
    FileDeleteResponse
      <$> (o .:? "commit")
      <*> (o .:? "content")
      <*> (o .:? "verification")

-- | ToJSON FileDeleteResponse
instance A.ToJSON FileDeleteResponse where
  toJSON FileDeleteResponse {..} =
   _omitNulls
      [ "commit" .= fileDeleteResponseCommit
      , "content" .= fileDeleteResponseContent
      , "verification" .= fileDeleteResponseVerification
      ]


-- | Construct a value of type 'FileDeleteResponse' (by applying it's required fields, if any)
mkFileDeleteResponse
  :: FileDeleteResponse
mkFileDeleteResponse =
  FileDeleteResponse
  { fileDeleteResponseCommit = Nothing
  , fileDeleteResponseContent = Nothing
  , fileDeleteResponseVerification = Nothing
  }

-- ** FileLinksResponse
-- | FileLinksResponse
-- FileLinksResponse contains the links for a repo's file
data FileLinksResponse = FileLinksResponse
  { fileLinksResponseGit :: !(Maybe Text) -- ^ "git"
  , fileLinksResponseHtml :: !(Maybe Text) -- ^ "html"
  , fileLinksResponseSelf :: !(Maybe Text) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileLinksResponse
instance A.FromJSON FileLinksResponse where
  parseJSON = A.withObject "FileLinksResponse" $ \o ->
    FileLinksResponse
      <$> (o .:? "git")
      <*> (o .:? "html")
      <*> (o .:? "self")

-- | ToJSON FileLinksResponse
instance A.ToJSON FileLinksResponse where
  toJSON FileLinksResponse {..} =
   _omitNulls
      [ "git" .= fileLinksResponseGit
      , "html" .= fileLinksResponseHtml
      , "self" .= fileLinksResponseSelf
      ]


-- | Construct a value of type 'FileLinksResponse' (by applying it's required fields, if any)
mkFileLinksResponse
  :: FileLinksResponse
mkFileLinksResponse =
  FileLinksResponse
  { fileLinksResponseGit = Nothing
  , fileLinksResponseHtml = Nothing
  , fileLinksResponseSelf = Nothing
  }

-- ** FileResponse
-- | FileResponse
-- FileResponse contains information about a repo's file
data FileResponse = FileResponse
  { fileResponseCommit :: !(Maybe FileCommitResponse) -- ^ "commit"
  , fileResponseContent :: !(Maybe ContentsResponse) -- ^ "content"
  , fileResponseVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FileResponse
instance A.FromJSON FileResponse where
  parseJSON = A.withObject "FileResponse" $ \o ->
    FileResponse
      <$> (o .:? "commit")
      <*> (o .:? "content")
      <*> (o .:? "verification")

-- | ToJSON FileResponse
instance A.ToJSON FileResponse where
  toJSON FileResponse {..} =
   _omitNulls
      [ "commit" .= fileResponseCommit
      , "content" .= fileResponseContent
      , "verification" .= fileResponseVerification
      ]


-- | Construct a value of type 'FileResponse' (by applying it's required fields, if any)
mkFileResponse
  :: FileResponse
mkFileResponse =
  FileResponse
  { fileResponseCommit = Nothing
  , fileResponseContent = Nothing
  , fileResponseVerification = Nothing
  }

-- ** FilesResponse
-- | FilesResponse
-- FilesResponse contains information about multiple files from a repo
data FilesResponse = FilesResponse
  { filesResponseCommit :: !(Maybe FileCommitResponse) -- ^ "commit"
  , filesResponseFiles :: !(Maybe [ContentsResponse]) -- ^ "files"
  , filesResponseVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FilesResponse
instance A.FromJSON FilesResponse where
  parseJSON = A.withObject "FilesResponse" $ \o ->
    FilesResponse
      <$> (o .:? "commit")
      <*> (o .:? "files")
      <*> (o .:? "verification")

-- | ToJSON FilesResponse
instance A.ToJSON FilesResponse where
  toJSON FilesResponse {..} =
   _omitNulls
      [ "commit" .= filesResponseCommit
      , "files" .= filesResponseFiles
      , "verification" .= filesResponseVerification
      ]


-- | Construct a value of type 'FilesResponse' (by applying it's required fields, if any)
mkFilesResponse
  :: FilesResponse
mkFilesResponse =
  FilesResponse
  { filesResponseCommit = Nothing
  , filesResponseFiles = Nothing
  , filesResponseVerification = Nothing
  }

-- ** GPGKey
-- | GPGKey
-- GPGKey a user GPG key to sign commit and tag in repository
data GPGKey = GPGKey
  { gPGKeyCanCertify :: !(Maybe Bool) -- ^ "can_certify"
  , gPGKeyCanEncryptComms :: !(Maybe Bool) -- ^ "can_encrypt_comms"
  , gPGKeyCanEncryptStorage :: !(Maybe Bool) -- ^ "can_encrypt_storage"
  , gPGKeyCanSign :: !(Maybe Bool) -- ^ "can_sign"
  , gPGKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , gPGKeyEmails :: !(Maybe [GPGKeyEmail]) -- ^ "emails"
  , gPGKeyExpiresAt :: !(Maybe DateTime) -- ^ "expires_at"
  , gPGKeyId :: !(Maybe Integer) -- ^ "id"
  , gPGKeyKeyId :: !(Maybe Text) -- ^ "key_id"
  , gPGKeyPrimaryKeyId :: !(Maybe Text) -- ^ "primary_key_id"
  , gPGKeyPublicKey :: !(Maybe Text) -- ^ "public_key"
  , gPGKeySubkeys :: !(Maybe [GPGKey]) -- ^ "subkeys"
  , gPGKeyVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GPGKey
instance A.FromJSON GPGKey where
  parseJSON = A.withObject "GPGKey" $ \o ->
    GPGKey
      <$> (o .:? "can_certify")
      <*> (o .:? "can_encrypt_comms")
      <*> (o .:? "can_encrypt_storage")
      <*> (o .:? "can_sign")
      <*> (o .:? "created_at")
      <*> (o .:? "emails")
      <*> (o .:? "expires_at")
      <*> (o .:? "id")
      <*> (o .:? "key_id")
      <*> (o .:? "primary_key_id")
      <*> (o .:? "public_key")
      <*> (o .:? "subkeys")
      <*> (o .:? "verified")

-- | ToJSON GPGKey
instance A.ToJSON GPGKey where
  toJSON GPGKey {..} =
   _omitNulls
      [ "can_certify" .= gPGKeyCanCertify
      , "can_encrypt_comms" .= gPGKeyCanEncryptComms
      , "can_encrypt_storage" .= gPGKeyCanEncryptStorage
      , "can_sign" .= gPGKeyCanSign
      , "created_at" .= gPGKeyCreatedAt
      , "emails" .= gPGKeyEmails
      , "expires_at" .= gPGKeyExpiresAt
      , "id" .= gPGKeyId
      , "key_id" .= gPGKeyKeyId
      , "primary_key_id" .= gPGKeyPrimaryKeyId
      , "public_key" .= gPGKeyPublicKey
      , "subkeys" .= gPGKeySubkeys
      , "verified" .= gPGKeyVerified
      ]


-- | Construct a value of type 'GPGKey' (by applying it's required fields, if any)
mkGPGKey
  :: GPGKey
mkGPGKey =
  GPGKey
  { gPGKeyCanCertify = Nothing
  , gPGKeyCanEncryptComms = Nothing
  , gPGKeyCanEncryptStorage = Nothing
  , gPGKeyCanSign = Nothing
  , gPGKeyCreatedAt = Nothing
  , gPGKeyEmails = Nothing
  , gPGKeyExpiresAt = Nothing
  , gPGKeyId = Nothing
  , gPGKeyKeyId = Nothing
  , gPGKeyPrimaryKeyId = Nothing
  , gPGKeyPublicKey = Nothing
  , gPGKeySubkeys = Nothing
  , gPGKeyVerified = Nothing
  }

-- ** GPGKeyEmail
-- | GPGKeyEmail
-- GPGKeyEmail an email attached to a GPGKey
data GPGKeyEmail = GPGKeyEmail
  { gPGKeyEmailEmail :: !(Maybe Text) -- ^ "email"
  , gPGKeyEmailVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GPGKeyEmail
instance A.FromJSON GPGKeyEmail where
  parseJSON = A.withObject "GPGKeyEmail" $ \o ->
    GPGKeyEmail
      <$> (o .:? "email")
      <*> (o .:? "verified")

-- | ToJSON GPGKeyEmail
instance A.ToJSON GPGKeyEmail where
  toJSON GPGKeyEmail {..} =
   _omitNulls
      [ "email" .= gPGKeyEmailEmail
      , "verified" .= gPGKeyEmailVerified
      ]


-- | Construct a value of type 'GPGKeyEmail' (by applying it's required fields, if any)
mkGPGKeyEmail
  :: GPGKeyEmail
mkGPGKeyEmail =
  GPGKeyEmail
  { gPGKeyEmailEmail = Nothing
  , gPGKeyEmailVerified = Nothing
  }

-- ** GeneralAPISettings
-- | GeneralAPISettings
-- GeneralAPISettings contains global api settings exposed by it
data GeneralAPISettings = GeneralAPISettings
  { generalAPISettingsDefaultGitTreesPerPage :: !(Maybe Integer) -- ^ "default_git_trees_per_page"
  , generalAPISettingsDefaultMaxBlobSize :: !(Maybe Integer) -- ^ "default_max_blob_size"
  , generalAPISettingsDefaultPagingNum :: !(Maybe Integer) -- ^ "default_paging_num"
  , generalAPISettingsMaxResponseItems :: !(Maybe Integer) -- ^ "max_response_items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneralAPISettings
instance A.FromJSON GeneralAPISettings where
  parseJSON = A.withObject "GeneralAPISettings" $ \o ->
    GeneralAPISettings
      <$> (o .:? "default_git_trees_per_page")
      <*> (o .:? "default_max_blob_size")
      <*> (o .:? "default_paging_num")
      <*> (o .:? "max_response_items")

-- | ToJSON GeneralAPISettings
instance A.ToJSON GeneralAPISettings where
  toJSON GeneralAPISettings {..} =
   _omitNulls
      [ "default_git_trees_per_page" .= generalAPISettingsDefaultGitTreesPerPage
      , "default_max_blob_size" .= generalAPISettingsDefaultMaxBlobSize
      , "default_paging_num" .= generalAPISettingsDefaultPagingNum
      , "max_response_items" .= generalAPISettingsMaxResponseItems
      ]


-- | Construct a value of type 'GeneralAPISettings' (by applying it's required fields, if any)
mkGeneralAPISettings
  :: GeneralAPISettings
mkGeneralAPISettings =
  GeneralAPISettings
  { generalAPISettingsDefaultGitTreesPerPage = Nothing
  , generalAPISettingsDefaultMaxBlobSize = Nothing
  , generalAPISettingsDefaultPagingNum = Nothing
  , generalAPISettingsMaxResponseItems = Nothing
  }

-- ** GeneralAttachmentSettings
-- | GeneralAttachmentSettings
-- GeneralAttachmentSettings contains global Attachment settings exposed by API
data GeneralAttachmentSettings = GeneralAttachmentSettings
  { generalAttachmentSettingsAllowedTypes :: !(Maybe Text) -- ^ "allowed_types"
  , generalAttachmentSettingsEnabled :: !(Maybe Bool) -- ^ "enabled"
  , generalAttachmentSettingsMaxFiles :: !(Maybe Integer) -- ^ "max_files"
  , generalAttachmentSettingsMaxSize :: !(Maybe Integer) -- ^ "max_size"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneralAttachmentSettings
instance A.FromJSON GeneralAttachmentSettings where
  parseJSON = A.withObject "GeneralAttachmentSettings" $ \o ->
    GeneralAttachmentSettings
      <$> (o .:? "allowed_types")
      <*> (o .:? "enabled")
      <*> (o .:? "max_files")
      <*> (o .:? "max_size")

-- | ToJSON GeneralAttachmentSettings
instance A.ToJSON GeneralAttachmentSettings where
  toJSON GeneralAttachmentSettings {..} =
   _omitNulls
      [ "allowed_types" .= generalAttachmentSettingsAllowedTypes
      , "enabled" .= generalAttachmentSettingsEnabled
      , "max_files" .= generalAttachmentSettingsMaxFiles
      , "max_size" .= generalAttachmentSettingsMaxSize
      ]


-- | Construct a value of type 'GeneralAttachmentSettings' (by applying it's required fields, if any)
mkGeneralAttachmentSettings
  :: GeneralAttachmentSettings
mkGeneralAttachmentSettings =
  GeneralAttachmentSettings
  { generalAttachmentSettingsAllowedTypes = Nothing
  , generalAttachmentSettingsEnabled = Nothing
  , generalAttachmentSettingsMaxFiles = Nothing
  , generalAttachmentSettingsMaxSize = Nothing
  }

-- ** GeneralRepoSettings
-- | GeneralRepoSettings
-- GeneralRepoSettings contains global repository settings exposed by API
data GeneralRepoSettings = GeneralRepoSettings
  { generalRepoSettingsHttpGitDisabled :: !(Maybe Bool) -- ^ "http_git_disabled"
  , generalRepoSettingsLfsDisabled :: !(Maybe Bool) -- ^ "lfs_disabled"
  , generalRepoSettingsMigrationsDisabled :: !(Maybe Bool) -- ^ "migrations_disabled"
  , generalRepoSettingsMirrorsDisabled :: !(Maybe Bool) -- ^ "mirrors_disabled"
  , generalRepoSettingsStarsDisabled :: !(Maybe Bool) -- ^ "stars_disabled"
  , generalRepoSettingsTimeTrackingDisabled :: !(Maybe Bool) -- ^ "time_tracking_disabled"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneralRepoSettings
instance A.FromJSON GeneralRepoSettings where
  parseJSON = A.withObject "GeneralRepoSettings" $ \o ->
    GeneralRepoSettings
      <$> (o .:? "http_git_disabled")
      <*> (o .:? "lfs_disabled")
      <*> (o .:? "migrations_disabled")
      <*> (o .:? "mirrors_disabled")
      <*> (o .:? "stars_disabled")
      <*> (o .:? "time_tracking_disabled")

-- | ToJSON GeneralRepoSettings
instance A.ToJSON GeneralRepoSettings where
  toJSON GeneralRepoSettings {..} =
   _omitNulls
      [ "http_git_disabled" .= generalRepoSettingsHttpGitDisabled
      , "lfs_disabled" .= generalRepoSettingsLfsDisabled
      , "migrations_disabled" .= generalRepoSettingsMigrationsDisabled
      , "mirrors_disabled" .= generalRepoSettingsMirrorsDisabled
      , "stars_disabled" .= generalRepoSettingsStarsDisabled
      , "time_tracking_disabled" .= generalRepoSettingsTimeTrackingDisabled
      ]


-- | Construct a value of type 'GeneralRepoSettings' (by applying it's required fields, if any)
mkGeneralRepoSettings
  :: GeneralRepoSettings
mkGeneralRepoSettings =
  GeneralRepoSettings
  { generalRepoSettingsHttpGitDisabled = Nothing
  , generalRepoSettingsLfsDisabled = Nothing
  , generalRepoSettingsMigrationsDisabled = Nothing
  , generalRepoSettingsMirrorsDisabled = Nothing
  , generalRepoSettingsStarsDisabled = Nothing
  , generalRepoSettingsTimeTrackingDisabled = Nothing
  }

-- ** GeneralUISettings
-- | GeneralUISettings
-- GeneralUISettings contains global ui settings exposed by API
data GeneralUISettings = GeneralUISettings
  { generalUISettingsAllowedReactions :: !(Maybe [Text]) -- ^ "allowed_reactions"
  , generalUISettingsCustomEmojis :: !(Maybe [Text]) -- ^ "custom_emojis"
  , generalUISettingsDefaultTheme :: !(Maybe Text) -- ^ "default_theme"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GeneralUISettings
instance A.FromJSON GeneralUISettings where
  parseJSON = A.withObject "GeneralUISettings" $ \o ->
    GeneralUISettings
      <$> (o .:? "allowed_reactions")
      <*> (o .:? "custom_emojis")
      <*> (o .:? "default_theme")

-- | ToJSON GeneralUISettings
instance A.ToJSON GeneralUISettings where
  toJSON GeneralUISettings {..} =
   _omitNulls
      [ "allowed_reactions" .= generalUISettingsAllowedReactions
      , "custom_emojis" .= generalUISettingsCustomEmojis
      , "default_theme" .= generalUISettingsDefaultTheme
      ]


-- | Construct a value of type 'GeneralUISettings' (by applying it's required fields, if any)
mkGeneralUISettings
  :: GeneralUISettings
mkGeneralUISettings =
  GeneralUISettings
  { generalUISettingsAllowedReactions = Nothing
  , generalUISettingsCustomEmojis = Nothing
  , generalUISettingsDefaultTheme = Nothing
  }

-- ** GenerateRepoOption
-- | GenerateRepoOption
-- GenerateRepoOption options when creating repository using a template
data GenerateRepoOption = GenerateRepoOption
  { generateRepoOptionAvatar :: !(Maybe Bool) -- ^ "avatar" - include avatar of the template repo
  , generateRepoOptionDefaultBranch :: !(Maybe Text) -- ^ "default_branch" - Default branch of the new repository
  , generateRepoOptionDescription :: !(Maybe Text) -- ^ "description" - Description of the repository to create
  , generateRepoOptionGitContent :: !(Maybe Bool) -- ^ "git_content" - include git content of default branch in template repo
  , generateRepoOptionGitHooks :: !(Maybe Bool) -- ^ "git_hooks" - include git hooks in template repo
  , generateRepoOptionLabels :: !(Maybe Bool) -- ^ "labels" - include labels in template repo
  , generateRepoOptionName :: !(Text) -- ^ /Required/ "name" - Name of the repository to create
  , generateRepoOptionOwner :: !(Text) -- ^ /Required/ "owner" - The organization or person who will own the new repository
  , generateRepoOptionPrivate :: !(Maybe Bool) -- ^ "private" - Whether the repository is private
  , generateRepoOptionTopics :: !(Maybe Bool) -- ^ "topics" - include topics in template repo
  , generateRepoOptionWebhooks :: !(Maybe Bool) -- ^ "webhooks" - include webhooks in template repo
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenerateRepoOption
instance A.FromJSON GenerateRepoOption where
  parseJSON = A.withObject "GenerateRepoOption" $ \o ->
    GenerateRepoOption
      <$> (o .:? "avatar")
      <*> (o .:? "default_branch")
      <*> (o .:? "description")
      <*> (o .:? "git_content")
      <*> (o .:? "git_hooks")
      <*> (o .:? "labels")
      <*> (o .:  "name")
      <*> (o .:  "owner")
      <*> (o .:? "private")
      <*> (o .:? "topics")
      <*> (o .:? "webhooks")

-- | ToJSON GenerateRepoOption
instance A.ToJSON GenerateRepoOption where
  toJSON GenerateRepoOption {..} =
   _omitNulls
      [ "avatar" .= generateRepoOptionAvatar
      , "default_branch" .= generateRepoOptionDefaultBranch
      , "description" .= generateRepoOptionDescription
      , "git_content" .= generateRepoOptionGitContent
      , "git_hooks" .= generateRepoOptionGitHooks
      , "labels" .= generateRepoOptionLabels
      , "name" .= generateRepoOptionName
      , "owner" .= generateRepoOptionOwner
      , "private" .= generateRepoOptionPrivate
      , "topics" .= generateRepoOptionTopics
      , "webhooks" .= generateRepoOptionWebhooks
      ]


-- | Construct a value of type 'GenerateRepoOption' (by applying it's required fields, if any)
mkGenerateRepoOption
  :: Text -- ^ 'generateRepoOptionName': Name of the repository to create
  -> Text -- ^ 'generateRepoOptionOwner': The organization or person who will own the new repository
  -> GenerateRepoOption
mkGenerateRepoOption generateRepoOptionName generateRepoOptionOwner =
  GenerateRepoOption
  { generateRepoOptionAvatar = Nothing
  , generateRepoOptionDefaultBranch = Nothing
  , generateRepoOptionDescription = Nothing
  , generateRepoOptionGitContent = Nothing
  , generateRepoOptionGitHooks = Nothing
  , generateRepoOptionLabels = Nothing
  , generateRepoOptionName
  , generateRepoOptionOwner
  , generateRepoOptionPrivate = Nothing
  , generateRepoOptionTopics = Nothing
  , generateRepoOptionWebhooks = Nothing
  }

-- ** GitBlobResponse
-- | GitBlobResponse
-- GitBlobResponse represents a git blob
data GitBlobResponse = GitBlobResponse
  { gitBlobResponseContent :: !(Maybe Text) -- ^ "content"
  , gitBlobResponseEncoding :: !(Maybe Text) -- ^ "encoding"
  , gitBlobResponseSha :: !(Maybe Text) -- ^ "sha"
  , gitBlobResponseSize :: !(Maybe Integer) -- ^ "size"
  , gitBlobResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitBlobResponse
instance A.FromJSON GitBlobResponse where
  parseJSON = A.withObject "GitBlobResponse" $ \o ->
    GitBlobResponse
      <$> (o .:? "content")
      <*> (o .:? "encoding")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "url")

-- | ToJSON GitBlobResponse
instance A.ToJSON GitBlobResponse where
  toJSON GitBlobResponse {..} =
   _omitNulls
      [ "content" .= gitBlobResponseContent
      , "encoding" .= gitBlobResponseEncoding
      , "sha" .= gitBlobResponseSha
      , "size" .= gitBlobResponseSize
      , "url" .= gitBlobResponseUrl
      ]


-- | Construct a value of type 'GitBlobResponse' (by applying it's required fields, if any)
mkGitBlobResponse
  :: GitBlobResponse
mkGitBlobResponse =
  GitBlobResponse
  { gitBlobResponseContent = Nothing
  , gitBlobResponseEncoding = Nothing
  , gitBlobResponseSha = Nothing
  , gitBlobResponseSize = Nothing
  , gitBlobResponseUrl = Nothing
  }

-- ** GitEntry
-- | GitEntry
-- GitEntry represents a git tree
data GitEntry = GitEntry
  { gitEntryMode :: !(Maybe Text) -- ^ "mode"
  , gitEntryPath :: !(Maybe Text) -- ^ "path"
  , gitEntrySha :: !(Maybe Text) -- ^ "sha"
  , gitEntrySize :: !(Maybe Integer) -- ^ "size"
  , gitEntryType :: !(Maybe Text) -- ^ "type"
  , gitEntryUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitEntry
instance A.FromJSON GitEntry where
  parseJSON = A.withObject "GitEntry" $ \o ->
    GitEntry
      <$> (o .:? "mode")
      <*> (o .:? "path")
      <*> (o .:? "sha")
      <*> (o .:? "size")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON GitEntry
instance A.ToJSON GitEntry where
  toJSON GitEntry {..} =
   _omitNulls
      [ "mode" .= gitEntryMode
      , "path" .= gitEntryPath
      , "sha" .= gitEntrySha
      , "size" .= gitEntrySize
      , "type" .= gitEntryType
      , "url" .= gitEntryUrl
      ]


-- | Construct a value of type 'GitEntry' (by applying it's required fields, if any)
mkGitEntry
  :: GitEntry
mkGitEntry =
  GitEntry
  { gitEntryMode = Nothing
  , gitEntryPath = Nothing
  , gitEntrySha = Nothing
  , gitEntrySize = Nothing
  , gitEntryType = Nothing
  , gitEntryUrl = Nothing
  }

-- ** GitHook
-- | GitHook
-- GitHook represents a Git repository hook
data GitHook = GitHook
  { gitHookContent :: !(Maybe Text) -- ^ "content"
  , gitHookIsActive :: !(Maybe Bool) -- ^ "is_active"
  , gitHookName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitHook
instance A.FromJSON GitHook where
  parseJSON = A.withObject "GitHook" $ \o ->
    GitHook
      <$> (o .:? "content")
      <*> (o .:? "is_active")
      <*> (o .:? "name")

-- | ToJSON GitHook
instance A.ToJSON GitHook where
  toJSON GitHook {..} =
   _omitNulls
      [ "content" .= gitHookContent
      , "is_active" .= gitHookIsActive
      , "name" .= gitHookName
      ]


-- | Construct a value of type 'GitHook' (by applying it's required fields, if any)
mkGitHook
  :: GitHook
mkGitHook =
  GitHook
  { gitHookContent = Nothing
  , gitHookIsActive = Nothing
  , gitHookName = Nothing
  }

-- ** GitObject
-- | GitObject
-- GitObject represents a Git object.
-- 
data GitObject = GitObject
  { gitObjectSha :: !(Maybe Text) -- ^ "sha"
  , gitObjectType :: !(Maybe Text) -- ^ "type"
  , gitObjectUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitObject
instance A.FromJSON GitObject where
  parseJSON = A.withObject "GitObject" $ \o ->
    GitObject
      <$> (o .:? "sha")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON GitObject
instance A.ToJSON GitObject where
  toJSON GitObject {..} =
   _omitNulls
      [ "sha" .= gitObjectSha
      , "type" .= gitObjectType
      , "url" .= gitObjectUrl
      ]


-- | Construct a value of type 'GitObject' (by applying it's required fields, if any)
mkGitObject
  :: GitObject
mkGitObject =
  GitObject
  { gitObjectSha = Nothing
  , gitObjectType = Nothing
  , gitObjectUrl = Nothing
  }

-- ** GitTreeResponse
-- | GitTreeResponse
-- GitTreeResponse returns a git tree
data GitTreeResponse = GitTreeResponse
  { gitTreeResponsePage :: !(Maybe Integer) -- ^ "page"
  , gitTreeResponseSha :: !(Maybe Text) -- ^ "sha"
  , gitTreeResponseTotalCount :: !(Maybe Integer) -- ^ "total_count"
  , gitTreeResponseTree :: !(Maybe [GitEntry]) -- ^ "tree"
  , gitTreeResponseTruncated :: !(Maybe Bool) -- ^ "truncated"
  , gitTreeResponseUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitTreeResponse
instance A.FromJSON GitTreeResponse where
  parseJSON = A.withObject "GitTreeResponse" $ \o ->
    GitTreeResponse
      <$> (o .:? "page")
      <*> (o .:? "sha")
      <*> (o .:? "total_count")
      <*> (o .:? "tree")
      <*> (o .:? "truncated")
      <*> (o .:? "url")

-- | ToJSON GitTreeResponse
instance A.ToJSON GitTreeResponse where
  toJSON GitTreeResponse {..} =
   _omitNulls
      [ "page" .= gitTreeResponsePage
      , "sha" .= gitTreeResponseSha
      , "total_count" .= gitTreeResponseTotalCount
      , "tree" .= gitTreeResponseTree
      , "truncated" .= gitTreeResponseTruncated
      , "url" .= gitTreeResponseUrl
      ]


-- | Construct a value of type 'GitTreeResponse' (by applying it's required fields, if any)
mkGitTreeResponse
  :: GitTreeResponse
mkGitTreeResponse =
  GitTreeResponse
  { gitTreeResponsePage = Nothing
  , gitTreeResponseSha = Nothing
  , gitTreeResponseTotalCount = Nothing
  , gitTreeResponseTree = Nothing
  , gitTreeResponseTruncated = Nothing
  , gitTreeResponseUrl = Nothing
  }

-- ** GitignoreTemplateInfo
-- | GitignoreTemplateInfo
-- GitignoreTemplateInfo name and text of a gitignore template
data GitignoreTemplateInfo = GitignoreTemplateInfo
  { gitignoreTemplateInfoName :: !(Maybe Text) -- ^ "name"
  , gitignoreTemplateInfoSource :: !(Maybe Text) -- ^ "source"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GitignoreTemplateInfo
instance A.FromJSON GitignoreTemplateInfo where
  parseJSON = A.withObject "GitignoreTemplateInfo" $ \o ->
    GitignoreTemplateInfo
      <$> (o .:? "name")
      <*> (o .:? "source")

-- | ToJSON GitignoreTemplateInfo
instance A.ToJSON GitignoreTemplateInfo where
  toJSON GitignoreTemplateInfo {..} =
   _omitNulls
      [ "name" .= gitignoreTemplateInfoName
      , "source" .= gitignoreTemplateInfoSource
      ]


-- | Construct a value of type 'GitignoreTemplateInfo' (by applying it's required fields, if any)
mkGitignoreTemplateInfo
  :: GitignoreTemplateInfo
mkGitignoreTemplateInfo =
  GitignoreTemplateInfo
  { gitignoreTemplateInfoName = Nothing
  , gitignoreTemplateInfoSource = Nothing
  }

-- ** Hook
-- | Hook
-- Hook a hook is a web hook when one repository changed
data Hook = Hook
  { hookActive :: !(Maybe Bool) -- ^ "active"
  , hookAuthorizationHeader :: !(Maybe Text) -- ^ "authorization_header"
  , hookBranchFilter :: !(Maybe Text) -- ^ "branch_filter"
  , hookConfig :: !(Maybe (Map.Map String Text)) -- ^ "config"
  , hookCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , hookEvents :: !(Maybe [Text]) -- ^ "events"
  , hookId :: !(Maybe Integer) -- ^ "id"
  , hookType :: !(Maybe Text) -- ^ "type"
  , hookUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Hook
instance A.FromJSON Hook where
  parseJSON = A.withObject "Hook" $ \o ->
    Hook
      <$> (o .:? "active")
      <*> (o .:? "authorization_header")
      <*> (o .:? "branch_filter")
      <*> (o .:? "config")
      <*> (o .:? "created_at")
      <*> (o .:? "events")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "updated_at")

-- | ToJSON Hook
instance A.ToJSON Hook where
  toJSON Hook {..} =
   _omitNulls
      [ "active" .= hookActive
      , "authorization_header" .= hookAuthorizationHeader
      , "branch_filter" .= hookBranchFilter
      , "config" .= hookConfig
      , "created_at" .= hookCreatedAt
      , "events" .= hookEvents
      , "id" .= hookId
      , "type" .= hookType
      , "updated_at" .= hookUpdatedAt
      ]


-- | Construct a value of type 'Hook' (by applying it's required fields, if any)
mkHook
  :: Hook
mkHook =
  Hook
  { hookActive = Nothing
  , hookAuthorizationHeader = Nothing
  , hookBranchFilter = Nothing
  , hookConfig = Nothing
  , hookCreatedAt = Nothing
  , hookEvents = Nothing
  , hookId = Nothing
  , hookType = Nothing
  , hookUpdatedAt = Nothing
  }

-- ** Identity
-- | Identity
-- Identity for a person's identity like an author or committer
data Identity = Identity
  { identityEmail :: !(Maybe Text) -- ^ "email"
  , identityName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Identity
instance A.FromJSON Identity where
  parseJSON = A.withObject "Identity" $ \o ->
    Identity
      <$> (o .:? "email")
      <*> (o .:? "name")

-- | ToJSON Identity
instance A.ToJSON Identity where
  toJSON Identity {..} =
   _omitNulls
      [ "email" .= identityEmail
      , "name" .= identityName
      ]


-- | Construct a value of type 'Identity' (by applying it's required fields, if any)
mkIdentity
  :: Identity
mkIdentity =
  Identity
  { identityEmail = Nothing
  , identityName = Nothing
  }

-- ** InternalTracker
-- | InternalTracker
-- InternalTracker represents settings for internal tracker
data InternalTracker = InternalTracker
  { internalTrackerAllowOnlyContributorsToTrackTime :: !(Maybe Bool) -- ^ "allow_only_contributors_to_track_time" - Let only contributors track time (Built-in issue tracker)
  , internalTrackerEnableIssueDependencies :: !(Maybe Bool) -- ^ "enable_issue_dependencies" - Enable dependencies for issues and pull requests (Built-in issue tracker)
  , internalTrackerEnableTimeTracker :: !(Maybe Bool) -- ^ "enable_time_tracker" - Enable time tracking (Built-in issue tracker)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InternalTracker
instance A.FromJSON InternalTracker where
  parseJSON = A.withObject "InternalTracker" $ \o ->
    InternalTracker
      <$> (o .:? "allow_only_contributors_to_track_time")
      <*> (o .:? "enable_issue_dependencies")
      <*> (o .:? "enable_time_tracker")

-- | ToJSON InternalTracker
instance A.ToJSON InternalTracker where
  toJSON InternalTracker {..} =
   _omitNulls
      [ "allow_only_contributors_to_track_time" .= internalTrackerAllowOnlyContributorsToTrackTime
      , "enable_issue_dependencies" .= internalTrackerEnableIssueDependencies
      , "enable_time_tracker" .= internalTrackerEnableTimeTracker
      ]


-- | Construct a value of type 'InternalTracker' (by applying it's required fields, if any)
mkInternalTracker
  :: InternalTracker
mkInternalTracker =
  InternalTracker
  { internalTrackerAllowOnlyContributorsToTrackTime = Nothing
  , internalTrackerEnableIssueDependencies = Nothing
  , internalTrackerEnableTimeTracker = Nothing
  }

-- ** Issue
-- | Issue
-- Issue represents an issue in a repository
data Issue = Issue
  { issueAssets :: !(Maybe [Attachment]) -- ^ "assets"
  , issueAssignee :: !(Maybe User) -- ^ "assignee"
  , issueAssignees :: !(Maybe [User]) -- ^ "assignees"
  , issueBody :: !(Maybe Text) -- ^ "body"
  , issueClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , issueComments :: !(Maybe Integer) -- ^ "comments"
  , issueCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , issueDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , issueHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , issueId :: !(Maybe Integer) -- ^ "id"
  , issueIsLocked :: !(Maybe Bool) -- ^ "is_locked"
  , issueLabels :: !(Maybe [Label]) -- ^ "labels"
  , issueMilestone :: !(Maybe Milestone) -- ^ "milestone"
  , issueNumber :: !(Maybe Integer) -- ^ "number"
  , issueOriginalAuthor :: !(Maybe Text) -- ^ "original_author"
  , issueOriginalAuthorId :: !(Maybe Integer) -- ^ "original_author_id"
  , issuePinOrder :: !(Maybe Integer) -- ^ "pin_order"
  , issuePullRequest :: !(Maybe PullRequestMeta) -- ^ "pull_request"
  , issueRef :: !(Maybe Text) -- ^ "ref"
  , issueRepository :: !(Maybe RepositoryMeta) -- ^ "repository"
  , issueState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , issueTitle :: !(Maybe Text) -- ^ "title"
  , issueUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , issueUrl :: !(Maybe Text) -- ^ "url"
  , issueUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Issue
instance A.FromJSON Issue where
  parseJSON = A.withObject "Issue" $ \o ->
    Issue
      <$> (o .:? "assets")
      <*> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "body")
      <*> (o .:? "closed_at")
      <*> (o .:? "comments")
      <*> (o .:? "created_at")
      <*> (o .:? "due_date")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "is_locked")
      <*> (o .:? "labels")
      <*> (o .:? "milestone")
      <*> (o .:? "number")
      <*> (o .:? "original_author")
      <*> (o .:? "original_author_id")
      <*> (o .:? "pin_order")
      <*> (o .:? "pull_request")
      <*> (o .:? "ref")
      <*> (o .:? "repository")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON Issue
instance A.ToJSON Issue where
  toJSON Issue {..} =
   _omitNulls
      [ "assets" .= issueAssets
      , "assignee" .= issueAssignee
      , "assignees" .= issueAssignees
      , "body" .= issueBody
      , "closed_at" .= issueClosedAt
      , "comments" .= issueComments
      , "created_at" .= issueCreatedAt
      , "due_date" .= issueDueDate
      , "html_url" .= issueHtmlUrl
      , "id" .= issueId
      , "is_locked" .= issueIsLocked
      , "labels" .= issueLabels
      , "milestone" .= issueMilestone
      , "number" .= issueNumber
      , "original_author" .= issueOriginalAuthor
      , "original_author_id" .= issueOriginalAuthorId
      , "pin_order" .= issuePinOrder
      , "pull_request" .= issuePullRequest
      , "ref" .= issueRef
      , "repository" .= issueRepository
      , "state" .= issueState
      , "title" .= issueTitle
      , "updated_at" .= issueUpdatedAt
      , "url" .= issueUrl
      , "user" .= issueUser
      ]


-- | Construct a value of type 'Issue' (by applying it's required fields, if any)
mkIssue
  :: Issue
mkIssue =
  Issue
  { issueAssets = Nothing
  , issueAssignee = Nothing
  , issueAssignees = Nothing
  , issueBody = Nothing
  , issueClosedAt = Nothing
  , issueComments = Nothing
  , issueCreatedAt = Nothing
  , issueDueDate = Nothing
  , issueHtmlUrl = Nothing
  , issueId = Nothing
  , issueIsLocked = Nothing
  , issueLabels = Nothing
  , issueMilestone = Nothing
  , issueNumber = Nothing
  , issueOriginalAuthor = Nothing
  , issueOriginalAuthorId = Nothing
  , issuePinOrder = Nothing
  , issuePullRequest = Nothing
  , issueRef = Nothing
  , issueRepository = Nothing
  , issueState = Nothing
  , issueTitle = Nothing
  , issueUpdatedAt = Nothing
  , issueUrl = Nothing
  , issueUser = Nothing
  }

-- ** IssueConfig
-- | IssueConfig
data IssueConfig = IssueConfig
  { issueConfigBlankIssuesEnabled :: !(Maybe Bool) -- ^ "blank_issues_enabled"
  , issueConfigContactLinks :: !(Maybe [IssueConfigContactLink]) -- ^ "contact_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueConfig
instance A.FromJSON IssueConfig where
  parseJSON = A.withObject "IssueConfig" $ \o ->
    IssueConfig
      <$> (o .:? "blank_issues_enabled")
      <*> (o .:? "contact_links")

-- | ToJSON IssueConfig
instance A.ToJSON IssueConfig where
  toJSON IssueConfig {..} =
   _omitNulls
      [ "blank_issues_enabled" .= issueConfigBlankIssuesEnabled
      , "contact_links" .= issueConfigContactLinks
      ]


-- | Construct a value of type 'IssueConfig' (by applying it's required fields, if any)
mkIssueConfig
  :: IssueConfig
mkIssueConfig =
  IssueConfig
  { issueConfigBlankIssuesEnabled = Nothing
  , issueConfigContactLinks = Nothing
  }

-- ** IssueConfigContactLink
-- | IssueConfigContactLink
data IssueConfigContactLink = IssueConfigContactLink
  { issueConfigContactLinkAbout :: !(Maybe Text) -- ^ "about"
  , issueConfigContactLinkName :: !(Maybe Text) -- ^ "name"
  , issueConfigContactLinkUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueConfigContactLink
instance A.FromJSON IssueConfigContactLink where
  parseJSON = A.withObject "IssueConfigContactLink" $ \o ->
    IssueConfigContactLink
      <$> (o .:? "about")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON IssueConfigContactLink
instance A.ToJSON IssueConfigContactLink where
  toJSON IssueConfigContactLink {..} =
   _omitNulls
      [ "about" .= issueConfigContactLinkAbout
      , "name" .= issueConfigContactLinkName
      , "url" .= issueConfigContactLinkUrl
      ]


-- | Construct a value of type 'IssueConfigContactLink' (by applying it's required fields, if any)
mkIssueConfigContactLink
  :: IssueConfigContactLink
mkIssueConfigContactLink =
  IssueConfigContactLink
  { issueConfigContactLinkAbout = Nothing
  , issueConfigContactLinkName = Nothing
  , issueConfigContactLinkUrl = Nothing
  }

-- ** IssueConfigValidation
-- | IssueConfigValidation
data IssueConfigValidation = IssueConfigValidation
  { issueConfigValidationMessage :: !(Maybe Text) -- ^ "message"
  , issueConfigValidationValid :: !(Maybe Bool) -- ^ "valid"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueConfigValidation
instance A.FromJSON IssueConfigValidation where
  parseJSON = A.withObject "IssueConfigValidation" $ \o ->
    IssueConfigValidation
      <$> (o .:? "message")
      <*> (o .:? "valid")

-- | ToJSON IssueConfigValidation
instance A.ToJSON IssueConfigValidation where
  toJSON IssueConfigValidation {..} =
   _omitNulls
      [ "message" .= issueConfigValidationMessage
      , "valid" .= issueConfigValidationValid
      ]


-- | Construct a value of type 'IssueConfigValidation' (by applying it's required fields, if any)
mkIssueConfigValidation
  :: IssueConfigValidation
mkIssueConfigValidation =
  IssueConfigValidation
  { issueConfigValidationMessage = Nothing
  , issueConfigValidationValid = Nothing
  }

-- ** IssueDeadline
-- | IssueDeadline
-- IssueDeadline represents an issue deadline
data IssueDeadline = IssueDeadline
  { issueDeadlineDueDate :: !(Maybe DateTime) -- ^ "due_date"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueDeadline
instance A.FromJSON IssueDeadline where
  parseJSON = A.withObject "IssueDeadline" $ \o ->
    IssueDeadline
      <$> (o .:? "due_date")

-- | ToJSON IssueDeadline
instance A.ToJSON IssueDeadline where
  toJSON IssueDeadline {..} =
   _omitNulls
      [ "due_date" .= issueDeadlineDueDate
      ]


-- | Construct a value of type 'IssueDeadline' (by applying it's required fields, if any)
mkIssueDeadline
  :: IssueDeadline
mkIssueDeadline =
  IssueDeadline
  { issueDeadlineDueDate = Nothing
  }

-- ** IssueFormField
-- | IssueFormField
-- IssueFormField represents a form field
data IssueFormField = IssueFormField
  { issueFormFieldAttributes :: !(Maybe (Map.Map String A.Value)) -- ^ "attributes"
  , issueFormFieldId :: !(Maybe Text) -- ^ "id"
  , issueFormFieldType :: !(Maybe Text) -- ^ "type"
  , issueFormFieldValidations :: !(Maybe (Map.Map String A.Value)) -- ^ "validations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueFormField
instance A.FromJSON IssueFormField where
  parseJSON = A.withObject "IssueFormField" $ \o ->
    IssueFormField
      <$> (o .:? "attributes")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "validations")

-- | ToJSON IssueFormField
instance A.ToJSON IssueFormField where
  toJSON IssueFormField {..} =
   _omitNulls
      [ "attributes" .= issueFormFieldAttributes
      , "id" .= issueFormFieldId
      , "type" .= issueFormFieldType
      , "validations" .= issueFormFieldValidations
      ]


-- | Construct a value of type 'IssueFormField' (by applying it's required fields, if any)
mkIssueFormField
  :: IssueFormField
mkIssueFormField =
  IssueFormField
  { issueFormFieldAttributes = Nothing
  , issueFormFieldId = Nothing
  , issueFormFieldType = Nothing
  , issueFormFieldValidations = Nothing
  }

-- ** IssueLabelsOption
-- | IssueLabelsOption
-- IssueLabelsOption a collection of labels
data IssueLabelsOption = IssueLabelsOption
  { issueLabelsOptionLabels :: !(Maybe [Integer]) -- ^ "labels" - list of label IDs
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueLabelsOption
instance A.FromJSON IssueLabelsOption where
  parseJSON = A.withObject "IssueLabelsOption" $ \o ->
    IssueLabelsOption
      <$> (o .:? "labels")

-- | ToJSON IssueLabelsOption
instance A.ToJSON IssueLabelsOption where
  toJSON IssueLabelsOption {..} =
   _omitNulls
      [ "labels" .= issueLabelsOptionLabels
      ]


-- | Construct a value of type 'IssueLabelsOption' (by applying it's required fields, if any)
mkIssueLabelsOption
  :: IssueLabelsOption
mkIssueLabelsOption =
  IssueLabelsOption
  { issueLabelsOptionLabels = Nothing
  }

-- ** IssueMeta
-- | IssueMeta
-- IssueMeta basic issue information
data IssueMeta = IssueMeta
  { issueMetaIndex :: !(Maybe Integer) -- ^ "index"
  , issueMetaOwner :: !(Maybe Text) -- ^ "owner"
  , issueMetaRepo :: !(Maybe Text) -- ^ "repo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueMeta
instance A.FromJSON IssueMeta where
  parseJSON = A.withObject "IssueMeta" $ \o ->
    IssueMeta
      <$> (o .:? "index")
      <*> (o .:? "owner")
      <*> (o .:? "repo")

-- | ToJSON IssueMeta
instance A.ToJSON IssueMeta where
  toJSON IssueMeta {..} =
   _omitNulls
      [ "index" .= issueMetaIndex
      , "owner" .= issueMetaOwner
      , "repo" .= issueMetaRepo
      ]


-- | Construct a value of type 'IssueMeta' (by applying it's required fields, if any)
mkIssueMeta
  :: IssueMeta
mkIssueMeta =
  IssueMeta
  { issueMetaIndex = Nothing
  , issueMetaOwner = Nothing
  , issueMetaRepo = Nothing
  }

-- ** IssueTemplate
-- | IssueTemplate
-- IssueTemplate represents an issue template for a repository
data IssueTemplate = IssueTemplate
  { issueTemplateAbout :: !(Maybe Text) -- ^ "about"
  , issueTemplateBody :: !(Maybe [IssueFormField]) -- ^ "body"
  , issueTemplateContent :: !(Maybe Text) -- ^ "content"
  , issueTemplateFileName :: !(Maybe Text) -- ^ "file_name"
  , issueTemplateLabels :: !(Maybe [Text]) -- ^ "labels"
  , issueTemplateName :: !(Maybe Text) -- ^ "name"
  , issueTemplateRef :: !(Maybe Text) -- ^ "ref"
  , issueTemplateTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IssueTemplate
instance A.FromJSON IssueTemplate where
  parseJSON = A.withObject "IssueTemplate" $ \o ->
    IssueTemplate
      <$> (o .:? "about")
      <*> (o .:? "body")
      <*> (o .:? "content")
      <*> (o .:? "file_name")
      <*> (o .:? "labels")
      <*> (o .:? "name")
      <*> (o .:? "ref")
      <*> (o .:? "title")

-- | ToJSON IssueTemplate
instance A.ToJSON IssueTemplate where
  toJSON IssueTemplate {..} =
   _omitNulls
      [ "about" .= issueTemplateAbout
      , "body" .= issueTemplateBody
      , "content" .= issueTemplateContent
      , "file_name" .= issueTemplateFileName
      , "labels" .= issueTemplateLabels
      , "name" .= issueTemplateName
      , "ref" .= issueTemplateRef
      , "title" .= issueTemplateTitle
      ]


-- | Construct a value of type 'IssueTemplate' (by applying it's required fields, if any)
mkIssueTemplate
  :: IssueTemplate
mkIssueTemplate =
  IssueTemplate
  { issueTemplateAbout = Nothing
  , issueTemplateBody = Nothing
  , issueTemplateContent = Nothing
  , issueTemplateFileName = Nothing
  , issueTemplateLabels = Nothing
  , issueTemplateName = Nothing
  , issueTemplateRef = Nothing
  , issueTemplateTitle = Nothing
  }

-- ** Label
-- | Label
-- Label a label to an issue or a pr
data Label = Label
  { labelColor :: !(Maybe Text) -- ^ "color"
  , labelDescription :: !(Maybe Text) -- ^ "description"
  , labelExclusive :: !(Maybe Bool) -- ^ "exclusive"
  , labelId :: !(Maybe Integer) -- ^ "id"
  , labelName :: !(Maybe Text) -- ^ "name"
  , labelUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Label
instance A.FromJSON Label where
  parseJSON = A.withObject "Label" $ \o ->
    Label
      <$> (o .:? "color")
      <*> (o .:? "description")
      <*> (o .:? "exclusive")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON Label
instance A.ToJSON Label where
  toJSON Label {..} =
   _omitNulls
      [ "color" .= labelColor
      , "description" .= labelDescription
      , "exclusive" .= labelExclusive
      , "id" .= labelId
      , "name" .= labelName
      , "url" .= labelUrl
      ]


-- | Construct a value of type 'Label' (by applying it's required fields, if any)
mkLabel
  :: Label
mkLabel =
  Label
  { labelColor = Nothing
  , labelDescription = Nothing
  , labelExclusive = Nothing
  , labelId = Nothing
  , labelName = Nothing
  , labelUrl = Nothing
  }

-- ** LabelTemplate
-- | LabelTemplate
-- LabelTemplate info of a Label template
data LabelTemplate = LabelTemplate
  { labelTemplateColor :: !(Maybe Text) -- ^ "color"
  , labelTemplateDescription :: !(Maybe Text) -- ^ "description"
  , labelTemplateExclusive :: !(Maybe Bool) -- ^ "exclusive"
  , labelTemplateName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LabelTemplate
instance A.FromJSON LabelTemplate where
  parseJSON = A.withObject "LabelTemplate" $ \o ->
    LabelTemplate
      <$> (o .:? "color")
      <*> (o .:? "description")
      <*> (o .:? "exclusive")
      <*> (o .:? "name")

-- | ToJSON LabelTemplate
instance A.ToJSON LabelTemplate where
  toJSON LabelTemplate {..} =
   _omitNulls
      [ "color" .= labelTemplateColor
      , "description" .= labelTemplateDescription
      , "exclusive" .= labelTemplateExclusive
      , "name" .= labelTemplateName
      ]


-- | Construct a value of type 'LabelTemplate' (by applying it's required fields, if any)
mkLabelTemplate
  :: LabelTemplate
mkLabelTemplate =
  LabelTemplate
  { labelTemplateColor = Nothing
  , labelTemplateDescription = Nothing
  , labelTemplateExclusive = Nothing
  , labelTemplateName = Nothing
  }

-- ** LicenseTemplateInfo
-- | LicenseTemplateInfo
-- LicensesInfo contains information about a License
data LicenseTemplateInfo = LicenseTemplateInfo
  { licenseTemplateInfoBody :: !(Maybe Text) -- ^ "body"
  , licenseTemplateInfoImplementation :: !(Maybe Text) -- ^ "implementation"
  , licenseTemplateInfoKey :: !(Maybe Text) -- ^ "key"
  , licenseTemplateInfoName :: !(Maybe Text) -- ^ "name"
  , licenseTemplateInfoUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LicenseTemplateInfo
instance A.FromJSON LicenseTemplateInfo where
  parseJSON = A.withObject "LicenseTemplateInfo" $ \o ->
    LicenseTemplateInfo
      <$> (o .:? "body")
      <*> (o .:? "implementation")
      <*> (o .:? "key")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON LicenseTemplateInfo
instance A.ToJSON LicenseTemplateInfo where
  toJSON LicenseTemplateInfo {..} =
   _omitNulls
      [ "body" .= licenseTemplateInfoBody
      , "implementation" .= licenseTemplateInfoImplementation
      , "key" .= licenseTemplateInfoKey
      , "name" .= licenseTemplateInfoName
      , "url" .= licenseTemplateInfoUrl
      ]


-- | Construct a value of type 'LicenseTemplateInfo' (by applying it's required fields, if any)
mkLicenseTemplateInfo
  :: LicenseTemplateInfo
mkLicenseTemplateInfo =
  LicenseTemplateInfo
  { licenseTemplateInfoBody = Nothing
  , licenseTemplateInfoImplementation = Nothing
  , licenseTemplateInfoKey = Nothing
  , licenseTemplateInfoName = Nothing
  , licenseTemplateInfoUrl = Nothing
  }

-- ** LicensesTemplateListEntry
-- | LicensesTemplateListEntry
-- LicensesListEntry is used for the API
data LicensesTemplateListEntry = LicensesTemplateListEntry
  { licensesTemplateListEntryKey :: !(Maybe Text) -- ^ "key"
  , licensesTemplateListEntryName :: !(Maybe Text) -- ^ "name"
  , licensesTemplateListEntryUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LicensesTemplateListEntry
instance A.FromJSON LicensesTemplateListEntry where
  parseJSON = A.withObject "LicensesTemplateListEntry" $ \o ->
    LicensesTemplateListEntry
      <$> (o .:? "key")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON LicensesTemplateListEntry
instance A.ToJSON LicensesTemplateListEntry where
  toJSON LicensesTemplateListEntry {..} =
   _omitNulls
      [ "key" .= licensesTemplateListEntryKey
      , "name" .= licensesTemplateListEntryName
      , "url" .= licensesTemplateListEntryUrl
      ]


-- | Construct a value of type 'LicensesTemplateListEntry' (by applying it's required fields, if any)
mkLicensesTemplateListEntry
  :: LicensesTemplateListEntry
mkLicensesTemplateListEntry =
  LicensesTemplateListEntry
  { licensesTemplateListEntryKey = Nothing
  , licensesTemplateListEntryName = Nothing
  , licensesTemplateListEntryUrl = Nothing
  }

-- ** MarkdownOption
-- | MarkdownOption
-- MarkdownOption markdown options
data MarkdownOption = MarkdownOption
  { markdownOptionContext :: !(Maybe Text) -- ^ "Context" - Context to render  in: body
  , markdownOptionMode :: !(Maybe Text) -- ^ "Mode" - Mode to render (comment, gfm, markdown)  in: body
  , markdownOptionText :: !(Maybe Text) -- ^ "Text" - Text markdown to render  in: body
  , markdownOptionWiki :: !(Maybe Bool) -- ^ "Wiki" - Is it a wiki page ?  in: body
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MarkdownOption
instance A.FromJSON MarkdownOption where
  parseJSON = A.withObject "MarkdownOption" $ \o ->
    MarkdownOption
      <$> (o .:? "Context")
      <*> (o .:? "Mode")
      <*> (o .:? "Text")
      <*> (o .:? "Wiki")

-- | ToJSON MarkdownOption
instance A.ToJSON MarkdownOption where
  toJSON MarkdownOption {..} =
   _omitNulls
      [ "Context" .= markdownOptionContext
      , "Mode" .= markdownOptionMode
      , "Text" .= markdownOptionText
      , "Wiki" .= markdownOptionWiki
      ]


-- | Construct a value of type 'MarkdownOption' (by applying it's required fields, if any)
mkMarkdownOption
  :: MarkdownOption
mkMarkdownOption =
  MarkdownOption
  { markdownOptionContext = Nothing
  , markdownOptionMode = Nothing
  , markdownOptionText = Nothing
  , markdownOptionWiki = Nothing
  }

-- ** MarkupOption
-- | MarkupOption
-- MarkupOption markup options
data MarkupOption = MarkupOption
  { markupOptionContext :: !(Maybe Text) -- ^ "Context" - Context to render  in: body
  , markupOptionFilePath :: !(Maybe Text) -- ^ "FilePath" - File path for detecting extension in file mode  in: body
  , markupOptionMode :: !(Maybe Text) -- ^ "Mode" - Mode to render (comment, gfm, markdown, file)  in: body
  , markupOptionText :: !(Maybe Text) -- ^ "Text" - Text markup to render  in: body
  , markupOptionWiki :: !(Maybe Bool) -- ^ "Wiki" - Is it a wiki page ?  in: body
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MarkupOption
instance A.FromJSON MarkupOption where
  parseJSON = A.withObject "MarkupOption" $ \o ->
    MarkupOption
      <$> (o .:? "Context")
      <*> (o .:? "FilePath")
      <*> (o .:? "Mode")
      <*> (o .:? "Text")
      <*> (o .:? "Wiki")

-- | ToJSON MarkupOption
instance A.ToJSON MarkupOption where
  toJSON MarkupOption {..} =
   _omitNulls
      [ "Context" .= markupOptionContext
      , "FilePath" .= markupOptionFilePath
      , "Mode" .= markupOptionMode
      , "Text" .= markupOptionText
      , "Wiki" .= markupOptionWiki
      ]


-- | Construct a value of type 'MarkupOption' (by applying it's required fields, if any)
mkMarkupOption
  :: MarkupOption
mkMarkupOption =
  MarkupOption
  { markupOptionContext = Nothing
  , markupOptionFilePath = Nothing
  , markupOptionMode = Nothing
  , markupOptionText = Nothing
  , markupOptionWiki = Nothing
  }

-- ** MergePullRequestOption
-- | MergePullRequestOption
-- MergePullRequestForm form for merging Pull Request
data MergePullRequestOption = MergePullRequestOption
  { mergePullRequestOptionDo :: !(E'Do) -- ^ /Required/ "Do"
  , mergePullRequestOptionMergeCommitId :: !(Maybe Text) -- ^ "MergeCommitID"
  , mergePullRequestOptionMergeMessageField :: !(Maybe Text) -- ^ "MergeMessageField"
  , mergePullRequestOptionMergeTitleField :: !(Maybe Text) -- ^ "MergeTitleField"
  , mergePullRequestOptionDeleteBranchAfterMerge :: !(Maybe Bool) -- ^ "delete_branch_after_merge"
  , mergePullRequestOptionForceMerge :: !(Maybe Bool) -- ^ "force_merge"
  , mergePullRequestOptionHeadCommitId :: !(Maybe Text) -- ^ "head_commit_id"
  , mergePullRequestOptionMergeWhenChecksSucceed :: !(Maybe Bool) -- ^ "merge_when_checks_succeed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MergePullRequestOption
instance A.FromJSON MergePullRequestOption where
  parseJSON = A.withObject "MergePullRequestOption" $ \o ->
    MergePullRequestOption
      <$> (o .:  "Do")
      <*> (o .:? "MergeCommitID")
      <*> (o .:? "MergeMessageField")
      <*> (o .:? "MergeTitleField")
      <*> (o .:? "delete_branch_after_merge")
      <*> (o .:? "force_merge")
      <*> (o .:? "head_commit_id")
      <*> (o .:? "merge_when_checks_succeed")

-- | ToJSON MergePullRequestOption
instance A.ToJSON MergePullRequestOption where
  toJSON MergePullRequestOption {..} =
   _omitNulls
      [ "Do" .= mergePullRequestOptionDo
      , "MergeCommitID" .= mergePullRequestOptionMergeCommitId
      , "MergeMessageField" .= mergePullRequestOptionMergeMessageField
      , "MergeTitleField" .= mergePullRequestOptionMergeTitleField
      , "delete_branch_after_merge" .= mergePullRequestOptionDeleteBranchAfterMerge
      , "force_merge" .= mergePullRequestOptionForceMerge
      , "head_commit_id" .= mergePullRequestOptionHeadCommitId
      , "merge_when_checks_succeed" .= mergePullRequestOptionMergeWhenChecksSucceed
      ]


-- | Construct a value of type 'MergePullRequestOption' (by applying it's required fields, if any)
mkMergePullRequestOption
  :: E'Do -- ^ 'mergePullRequestOptionDo' 
  -> MergePullRequestOption
mkMergePullRequestOption mergePullRequestOptionDo =
  MergePullRequestOption
  { mergePullRequestOptionDo
  , mergePullRequestOptionMergeCommitId = Nothing
  , mergePullRequestOptionMergeMessageField = Nothing
  , mergePullRequestOptionMergeTitleField = Nothing
  , mergePullRequestOptionDeleteBranchAfterMerge = Nothing
  , mergePullRequestOptionForceMerge = Nothing
  , mergePullRequestOptionHeadCommitId = Nothing
  , mergePullRequestOptionMergeWhenChecksSucceed = Nothing
  }

-- ** MigrateRepoOptions
-- | MigrateRepoOptions
-- MigrateRepoOptions options for migrating repository's this is used to interact with api v1
data MigrateRepoOptions = MigrateRepoOptions
  { migrateRepoOptionsAuthPassword :: !(Maybe Text) -- ^ "auth_password"
  , migrateRepoOptionsAuthToken :: !(Maybe Text) -- ^ "auth_token"
  , migrateRepoOptionsAuthUsername :: !(Maybe Text) -- ^ "auth_username"
  , migrateRepoOptionsCloneAddr :: !(Text) -- ^ /Required/ "clone_addr"
  , migrateRepoOptionsDescription :: !(Maybe Text) -- ^ "description"
  , migrateRepoOptionsIssues :: !(Maybe Bool) -- ^ "issues"
  , migrateRepoOptionsLabels :: !(Maybe Bool) -- ^ "labels"
  , migrateRepoOptionsLfs :: !(Maybe Bool) -- ^ "lfs"
  , migrateRepoOptionsLfsEndpoint :: !(Maybe Text) -- ^ "lfs_endpoint"
  , migrateRepoOptionsMilestones :: !(Maybe Bool) -- ^ "milestones"
  , migrateRepoOptionsMirror :: !(Maybe Bool) -- ^ "mirror"
  , migrateRepoOptionsMirrorInterval :: !(Maybe Text) -- ^ "mirror_interval"
  , migrateRepoOptionsPrivate :: !(Maybe Bool) -- ^ "private"
  , migrateRepoOptionsPullRequests :: !(Maybe Bool) -- ^ "pull_requests"
  , migrateRepoOptionsReleases :: !(Maybe Bool) -- ^ "releases"
  , migrateRepoOptionsRepoName :: !(Text) -- ^ /Required/ "repo_name"
  , migrateRepoOptionsRepoOwner :: !(Maybe Text) -- ^ "repo_owner" - Name of User or Organisation who will own Repo after migration
  , migrateRepoOptionsService :: !(Maybe E'Service) -- ^ "service"
  , migrateRepoOptionsUid :: !(Maybe Integer) -- ^ "uid" - deprecated (only for backwards compatibility)
  , migrateRepoOptionsWiki :: !(Maybe Bool) -- ^ "wiki"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MigrateRepoOptions
instance A.FromJSON MigrateRepoOptions where
  parseJSON = A.withObject "MigrateRepoOptions" $ \o ->
    MigrateRepoOptions
      <$> (o .:? "auth_password")
      <*> (o .:? "auth_token")
      <*> (o .:? "auth_username")
      <*> (o .:  "clone_addr")
      <*> (o .:? "description")
      <*> (o .:? "issues")
      <*> (o .:? "labels")
      <*> (o .:? "lfs")
      <*> (o .:? "lfs_endpoint")
      <*> (o .:? "milestones")
      <*> (o .:? "mirror")
      <*> (o .:? "mirror_interval")
      <*> (o .:? "private")
      <*> (o .:? "pull_requests")
      <*> (o .:? "releases")
      <*> (o .:  "repo_name")
      <*> (o .:? "repo_owner")
      <*> (o .:? "service")
      <*> (o .:? "uid")
      <*> (o .:? "wiki")

-- | ToJSON MigrateRepoOptions
instance A.ToJSON MigrateRepoOptions where
  toJSON MigrateRepoOptions {..} =
   _omitNulls
      [ "auth_password" .= migrateRepoOptionsAuthPassword
      , "auth_token" .= migrateRepoOptionsAuthToken
      , "auth_username" .= migrateRepoOptionsAuthUsername
      , "clone_addr" .= migrateRepoOptionsCloneAddr
      , "description" .= migrateRepoOptionsDescription
      , "issues" .= migrateRepoOptionsIssues
      , "labels" .= migrateRepoOptionsLabels
      , "lfs" .= migrateRepoOptionsLfs
      , "lfs_endpoint" .= migrateRepoOptionsLfsEndpoint
      , "milestones" .= migrateRepoOptionsMilestones
      , "mirror" .= migrateRepoOptionsMirror
      , "mirror_interval" .= migrateRepoOptionsMirrorInterval
      , "private" .= migrateRepoOptionsPrivate
      , "pull_requests" .= migrateRepoOptionsPullRequests
      , "releases" .= migrateRepoOptionsReleases
      , "repo_name" .= migrateRepoOptionsRepoName
      , "repo_owner" .= migrateRepoOptionsRepoOwner
      , "service" .= migrateRepoOptionsService
      , "uid" .= migrateRepoOptionsUid
      , "wiki" .= migrateRepoOptionsWiki
      ]


-- | Construct a value of type 'MigrateRepoOptions' (by applying it's required fields, if any)
mkMigrateRepoOptions
  :: Text -- ^ 'migrateRepoOptionsCloneAddr' 
  -> Text -- ^ 'migrateRepoOptionsRepoName' 
  -> MigrateRepoOptions
mkMigrateRepoOptions migrateRepoOptionsCloneAddr migrateRepoOptionsRepoName =
  MigrateRepoOptions
  { migrateRepoOptionsAuthPassword = Nothing
  , migrateRepoOptionsAuthToken = Nothing
  , migrateRepoOptionsAuthUsername = Nothing
  , migrateRepoOptionsCloneAddr
  , migrateRepoOptionsDescription = Nothing
  , migrateRepoOptionsIssues = Nothing
  , migrateRepoOptionsLabels = Nothing
  , migrateRepoOptionsLfs = Nothing
  , migrateRepoOptionsLfsEndpoint = Nothing
  , migrateRepoOptionsMilestones = Nothing
  , migrateRepoOptionsMirror = Nothing
  , migrateRepoOptionsMirrorInterval = Nothing
  , migrateRepoOptionsPrivate = Nothing
  , migrateRepoOptionsPullRequests = Nothing
  , migrateRepoOptionsReleases = Nothing
  , migrateRepoOptionsRepoName
  , migrateRepoOptionsRepoOwner = Nothing
  , migrateRepoOptionsService = Nothing
  , migrateRepoOptionsUid = Nothing
  , migrateRepoOptionsWiki = Nothing
  }

-- ** Milestone
-- | Milestone
-- Milestone milestone is a collection of issues on one repository
data Milestone = Milestone
  { milestoneClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , milestoneClosedIssues :: !(Maybe Integer) -- ^ "closed_issues"
  , milestoneCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , milestoneDescription :: !(Maybe Text) -- ^ "description"
  , milestoneDueOn :: !(Maybe DateTime) -- ^ "due_on"
  , milestoneId :: !(Maybe Integer) -- ^ "id"
  , milestoneOpenIssues :: !(Maybe Integer) -- ^ "open_issues"
  , milestoneState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , milestoneTitle :: !(Maybe Text) -- ^ "title"
  , milestoneUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Milestone
instance A.FromJSON Milestone where
  parseJSON = A.withObject "Milestone" $ \o ->
    Milestone
      <$> (o .:? "closed_at")
      <*> (o .:? "closed_issues")
      <*> (o .:? "created_at")
      <*> (o .:? "description")
      <*> (o .:? "due_on")
      <*> (o .:? "id")
      <*> (o .:? "open_issues")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "updated_at")

-- | ToJSON Milestone
instance A.ToJSON Milestone where
  toJSON Milestone {..} =
   _omitNulls
      [ "closed_at" .= milestoneClosedAt
      , "closed_issues" .= milestoneClosedIssues
      , "created_at" .= milestoneCreatedAt
      , "description" .= milestoneDescription
      , "due_on" .= milestoneDueOn
      , "id" .= milestoneId
      , "open_issues" .= milestoneOpenIssues
      , "state" .= milestoneState
      , "title" .= milestoneTitle
      , "updated_at" .= milestoneUpdatedAt
      ]


-- | Construct a value of type 'Milestone' (by applying it's required fields, if any)
mkMilestone
  :: Milestone
mkMilestone =
  Milestone
  { milestoneClosedAt = Nothing
  , milestoneClosedIssues = Nothing
  , milestoneCreatedAt = Nothing
  , milestoneDescription = Nothing
  , milestoneDueOn = Nothing
  , milestoneId = Nothing
  , milestoneOpenIssues = Nothing
  , milestoneState = Nothing
  , milestoneTitle = Nothing
  , milestoneUpdatedAt = Nothing
  }

-- ** NewIssuePinsAllowed
-- | NewIssuePinsAllowed
-- NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed
data NewIssuePinsAllowed = NewIssuePinsAllowed
  { newIssuePinsAllowedIssues :: !(Maybe Bool) -- ^ "issues"
  , newIssuePinsAllowedPullRequests :: !(Maybe Bool) -- ^ "pull_requests"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewIssuePinsAllowed
instance A.FromJSON NewIssuePinsAllowed where
  parseJSON = A.withObject "NewIssuePinsAllowed" $ \o ->
    NewIssuePinsAllowed
      <$> (o .:? "issues")
      <*> (o .:? "pull_requests")

-- | ToJSON NewIssuePinsAllowed
instance A.ToJSON NewIssuePinsAllowed where
  toJSON NewIssuePinsAllowed {..} =
   _omitNulls
      [ "issues" .= newIssuePinsAllowedIssues
      , "pull_requests" .= newIssuePinsAllowedPullRequests
      ]


-- | Construct a value of type 'NewIssuePinsAllowed' (by applying it's required fields, if any)
mkNewIssuePinsAllowed
  :: NewIssuePinsAllowed
mkNewIssuePinsAllowed =
  NewIssuePinsAllowed
  { newIssuePinsAllowedIssues = Nothing
  , newIssuePinsAllowedPullRequests = Nothing
  }

-- ** NodeInfo
-- | NodeInfo
-- NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks
data NodeInfo = NodeInfo
  { nodeInfoMetadata :: !(Maybe A.Value) -- ^ "metadata"
  , nodeInfoOpenRegistrations :: !(Maybe Bool) -- ^ "openRegistrations"
  , nodeInfoProtocols :: !(Maybe [Text]) -- ^ "protocols"
  , nodeInfoServices :: !(Maybe NodeInfoServices) -- ^ "services"
  , nodeInfoSoftware :: !(Maybe NodeInfoSoftware) -- ^ "software"
  , nodeInfoUsage :: !(Maybe NodeInfoUsage) -- ^ "usage"
  , nodeInfoVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeInfo
instance A.FromJSON NodeInfo where
  parseJSON = A.withObject "NodeInfo" $ \o ->
    NodeInfo
      <$> (o .:? "metadata")
      <*> (o .:? "openRegistrations")
      <*> (o .:? "protocols")
      <*> (o .:? "services")
      <*> (o .:? "software")
      <*> (o .:? "usage")
      <*> (o .:? "version")

-- | ToJSON NodeInfo
instance A.ToJSON NodeInfo where
  toJSON NodeInfo {..} =
   _omitNulls
      [ "metadata" .= nodeInfoMetadata
      , "openRegistrations" .= nodeInfoOpenRegistrations
      , "protocols" .= nodeInfoProtocols
      , "services" .= nodeInfoServices
      , "software" .= nodeInfoSoftware
      , "usage" .= nodeInfoUsage
      , "version" .= nodeInfoVersion
      ]


-- | Construct a value of type 'NodeInfo' (by applying it's required fields, if any)
mkNodeInfo
  :: NodeInfo
mkNodeInfo =
  NodeInfo
  { nodeInfoMetadata = Nothing
  , nodeInfoOpenRegistrations = Nothing
  , nodeInfoProtocols = Nothing
  , nodeInfoServices = Nothing
  , nodeInfoSoftware = Nothing
  , nodeInfoUsage = Nothing
  , nodeInfoVersion = Nothing
  }

-- ** NodeInfoServices
-- | NodeInfoServices
-- NodeInfoServices contains the third party sites this server can connect to via their application API
data NodeInfoServices = NodeInfoServices
  { nodeInfoServicesInbound :: !(Maybe [Text]) -- ^ "inbound"
  , nodeInfoServicesOutbound :: !(Maybe [Text]) -- ^ "outbound"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeInfoServices
instance A.FromJSON NodeInfoServices where
  parseJSON = A.withObject "NodeInfoServices" $ \o ->
    NodeInfoServices
      <$> (o .:? "inbound")
      <*> (o .:? "outbound")

-- | ToJSON NodeInfoServices
instance A.ToJSON NodeInfoServices where
  toJSON NodeInfoServices {..} =
   _omitNulls
      [ "inbound" .= nodeInfoServicesInbound
      , "outbound" .= nodeInfoServicesOutbound
      ]


-- | Construct a value of type 'NodeInfoServices' (by applying it's required fields, if any)
mkNodeInfoServices
  :: NodeInfoServices
mkNodeInfoServices =
  NodeInfoServices
  { nodeInfoServicesInbound = Nothing
  , nodeInfoServicesOutbound = Nothing
  }

-- ** NodeInfoSoftware
-- | NodeInfoSoftware
-- NodeInfoSoftware contains Metadata about server software in use
data NodeInfoSoftware = NodeInfoSoftware
  { nodeInfoSoftwareHomepage :: !(Maybe Text) -- ^ "homepage"
  , nodeInfoSoftwareName :: !(Maybe Text) -- ^ "name"
  , nodeInfoSoftwareRepository :: !(Maybe Text) -- ^ "repository"
  , nodeInfoSoftwareVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeInfoSoftware
instance A.FromJSON NodeInfoSoftware where
  parseJSON = A.withObject "NodeInfoSoftware" $ \o ->
    NodeInfoSoftware
      <$> (o .:? "homepage")
      <*> (o .:? "name")
      <*> (o .:? "repository")
      <*> (o .:? "version")

-- | ToJSON NodeInfoSoftware
instance A.ToJSON NodeInfoSoftware where
  toJSON NodeInfoSoftware {..} =
   _omitNulls
      [ "homepage" .= nodeInfoSoftwareHomepage
      , "name" .= nodeInfoSoftwareName
      , "repository" .= nodeInfoSoftwareRepository
      , "version" .= nodeInfoSoftwareVersion
      ]


-- | Construct a value of type 'NodeInfoSoftware' (by applying it's required fields, if any)
mkNodeInfoSoftware
  :: NodeInfoSoftware
mkNodeInfoSoftware =
  NodeInfoSoftware
  { nodeInfoSoftwareHomepage = Nothing
  , nodeInfoSoftwareName = Nothing
  , nodeInfoSoftwareRepository = Nothing
  , nodeInfoSoftwareVersion = Nothing
  }

-- ** NodeInfoUsage
-- | NodeInfoUsage
-- NodeInfoUsage contains usage statistics for this server
data NodeInfoUsage = NodeInfoUsage
  { nodeInfoUsageLocalComments :: !(Maybe Integer) -- ^ "localComments"
  , nodeInfoUsageLocalPosts :: !(Maybe Integer) -- ^ "localPosts"
  , nodeInfoUsageUsers :: !(Maybe NodeInfoUsageUsers) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeInfoUsage
instance A.FromJSON NodeInfoUsage where
  parseJSON = A.withObject "NodeInfoUsage" $ \o ->
    NodeInfoUsage
      <$> (o .:? "localComments")
      <*> (o .:? "localPosts")
      <*> (o .:? "users")

-- | ToJSON NodeInfoUsage
instance A.ToJSON NodeInfoUsage where
  toJSON NodeInfoUsage {..} =
   _omitNulls
      [ "localComments" .= nodeInfoUsageLocalComments
      , "localPosts" .= nodeInfoUsageLocalPosts
      , "users" .= nodeInfoUsageUsers
      ]


-- | Construct a value of type 'NodeInfoUsage' (by applying it's required fields, if any)
mkNodeInfoUsage
  :: NodeInfoUsage
mkNodeInfoUsage =
  NodeInfoUsage
  { nodeInfoUsageLocalComments = Nothing
  , nodeInfoUsageLocalPosts = Nothing
  , nodeInfoUsageUsers = Nothing
  }

-- ** NodeInfoUsageUsers
-- | NodeInfoUsageUsers
-- NodeInfoUsageUsers contains statistics about the users of this server
data NodeInfoUsageUsers = NodeInfoUsageUsers
  { nodeInfoUsageUsersActiveHalfyear :: !(Maybe Integer) -- ^ "activeHalfyear"
  , nodeInfoUsageUsersActiveMonth :: !(Maybe Integer) -- ^ "activeMonth"
  , nodeInfoUsageUsersTotal :: !(Maybe Integer) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeInfoUsageUsers
instance A.FromJSON NodeInfoUsageUsers where
  parseJSON = A.withObject "NodeInfoUsageUsers" $ \o ->
    NodeInfoUsageUsers
      <$> (o .:? "activeHalfyear")
      <*> (o .:? "activeMonth")
      <*> (o .:? "total")

-- | ToJSON NodeInfoUsageUsers
instance A.ToJSON NodeInfoUsageUsers where
  toJSON NodeInfoUsageUsers {..} =
   _omitNulls
      [ "activeHalfyear" .= nodeInfoUsageUsersActiveHalfyear
      , "activeMonth" .= nodeInfoUsageUsersActiveMonth
      , "total" .= nodeInfoUsageUsersTotal
      ]


-- | Construct a value of type 'NodeInfoUsageUsers' (by applying it's required fields, if any)
mkNodeInfoUsageUsers
  :: NodeInfoUsageUsers
mkNodeInfoUsageUsers =
  NodeInfoUsageUsers
  { nodeInfoUsageUsersActiveHalfyear = Nothing
  , nodeInfoUsageUsersActiveMonth = Nothing
  , nodeInfoUsageUsersTotal = Nothing
  }

-- ** Note
-- | Note
-- Note contains information related to a git note
data Note = Note
  { noteCommit :: !(Maybe Commit) -- ^ "commit"
  , noteMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Note
instance A.FromJSON Note where
  parseJSON = A.withObject "Note" $ \o ->
    Note
      <$> (o .:? "commit")
      <*> (o .:? "message")

-- | ToJSON Note
instance A.ToJSON Note where
  toJSON Note {..} =
   _omitNulls
      [ "commit" .= noteCommit
      , "message" .= noteMessage
      ]


-- | Construct a value of type 'Note' (by applying it's required fields, if any)
mkNote
  :: Note
mkNote =
  Note
  { noteCommit = Nothing
  , noteMessage = Nothing
  }

-- ** NotificationCount
-- | NotificationCount
-- NotificationCount number of unread notifications
data NotificationCount = NotificationCount
  { notificationCountNew :: !(Maybe Integer) -- ^ "new"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NotificationCount
instance A.FromJSON NotificationCount where
  parseJSON = A.withObject "NotificationCount" $ \o ->
    NotificationCount
      <$> (o .:? "new")

-- | ToJSON NotificationCount
instance A.ToJSON NotificationCount where
  toJSON NotificationCount {..} =
   _omitNulls
      [ "new" .= notificationCountNew
      ]


-- | Construct a value of type 'NotificationCount' (by applying it's required fields, if any)
mkNotificationCount
  :: NotificationCount
mkNotificationCount =
  NotificationCount
  { notificationCountNew = Nothing
  }

-- ** NotificationSubject
-- | NotificationSubject
-- NotificationSubject contains the notification subject (Issue/Pull/Commit)
data NotificationSubject = NotificationSubject
  { notificationSubjectHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , notificationSubjectLatestCommentHtmlUrl :: !(Maybe Text) -- ^ "latest_comment_html_url"
  , notificationSubjectLatestCommentUrl :: !(Maybe Text) -- ^ "latest_comment_url"
  , notificationSubjectState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , notificationSubjectTitle :: !(Maybe Text) -- ^ "title"
  , notificationSubjectType :: !(Maybe Text) -- ^ "type" - NotifySubjectType represent type of notification subject
  , notificationSubjectUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NotificationSubject
instance A.FromJSON NotificationSubject where
  parseJSON = A.withObject "NotificationSubject" $ \o ->
    NotificationSubject
      <$> (o .:? "html_url")
      <*> (o .:? "latest_comment_html_url")
      <*> (o .:? "latest_comment_url")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON NotificationSubject
instance A.ToJSON NotificationSubject where
  toJSON NotificationSubject {..} =
   _omitNulls
      [ "html_url" .= notificationSubjectHtmlUrl
      , "latest_comment_html_url" .= notificationSubjectLatestCommentHtmlUrl
      , "latest_comment_url" .= notificationSubjectLatestCommentUrl
      , "state" .= notificationSubjectState
      , "title" .= notificationSubjectTitle
      , "type" .= notificationSubjectType
      , "url" .= notificationSubjectUrl
      ]


-- | Construct a value of type 'NotificationSubject' (by applying it's required fields, if any)
mkNotificationSubject
  :: NotificationSubject
mkNotificationSubject =
  NotificationSubject
  { notificationSubjectHtmlUrl = Nothing
  , notificationSubjectLatestCommentHtmlUrl = Nothing
  , notificationSubjectLatestCommentUrl = Nothing
  , notificationSubjectState = Nothing
  , notificationSubjectTitle = Nothing
  , notificationSubjectType = Nothing
  , notificationSubjectUrl = Nothing
  }

-- ** NotificationThread
-- | NotificationThread
-- NotificationThread expose Notification on API
data NotificationThread = NotificationThread
  { notificationThreadId :: !(Maybe Integer) -- ^ "id"
  , notificationThreadPinned :: !(Maybe Bool) -- ^ "pinned"
  , notificationThreadRepository :: !(Maybe Repository) -- ^ "repository"
  , notificationThreadSubject :: !(Maybe NotificationSubject) -- ^ "subject"
  , notificationThreadUnread :: !(Maybe Bool) -- ^ "unread"
  , notificationThreadUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , notificationThreadUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NotificationThread
instance A.FromJSON NotificationThread where
  parseJSON = A.withObject "NotificationThread" $ \o ->
    NotificationThread
      <$> (o .:? "id")
      <*> (o .:? "pinned")
      <*> (o .:? "repository")
      <*> (o .:? "subject")
      <*> (o .:? "unread")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")

-- | ToJSON NotificationThread
instance A.ToJSON NotificationThread where
  toJSON NotificationThread {..} =
   _omitNulls
      [ "id" .= notificationThreadId
      , "pinned" .= notificationThreadPinned
      , "repository" .= notificationThreadRepository
      , "subject" .= notificationThreadSubject
      , "unread" .= notificationThreadUnread
      , "updated_at" .= notificationThreadUpdatedAt
      , "url" .= notificationThreadUrl
      ]


-- | Construct a value of type 'NotificationThread' (by applying it's required fields, if any)
mkNotificationThread
  :: NotificationThread
mkNotificationThread =
  NotificationThread
  { notificationThreadId = Nothing
  , notificationThreadPinned = Nothing
  , notificationThreadRepository = Nothing
  , notificationThreadSubject = Nothing
  , notificationThreadUnread = Nothing
  , notificationThreadUpdatedAt = Nothing
  , notificationThreadUrl = Nothing
  }

-- ** OAuth2Application
-- | OAuth2Application
-- OAuth2Application represents an OAuth2 application.
-- 
data OAuth2Application = OAuth2Application
  { oAuth2ApplicationClientId :: !(Maybe Text) -- ^ "client_id"
  , oAuth2ApplicationClientSecret :: !(Maybe Text) -- ^ "client_secret"
  , oAuth2ApplicationConfidentialClient :: !(Maybe Bool) -- ^ "confidential_client"
  , oAuth2ApplicationCreated :: !(Maybe DateTime) -- ^ "created"
  , oAuth2ApplicationId :: !(Maybe Integer) -- ^ "id"
  , oAuth2ApplicationName :: !(Maybe Text) -- ^ "name"
  , oAuth2ApplicationRedirectUris :: !(Maybe [Text]) -- ^ "redirect_uris"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Application
instance A.FromJSON OAuth2Application where
  parseJSON = A.withObject "OAuth2Application" $ \o ->
    OAuth2Application
      <$> (o .:? "client_id")
      <*> (o .:? "client_secret")
      <*> (o .:? "confidential_client")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "redirect_uris")

-- | ToJSON OAuth2Application
instance A.ToJSON OAuth2Application where
  toJSON OAuth2Application {..} =
   _omitNulls
      [ "client_id" .= oAuth2ApplicationClientId
      , "client_secret" .= oAuth2ApplicationClientSecret
      , "confidential_client" .= oAuth2ApplicationConfidentialClient
      , "created" .= oAuth2ApplicationCreated
      , "id" .= oAuth2ApplicationId
      , "name" .= oAuth2ApplicationName
      , "redirect_uris" .= oAuth2ApplicationRedirectUris
      ]


-- | Construct a value of type 'OAuth2Application' (by applying it's required fields, if any)
mkOAuth2Application
  :: OAuth2Application
mkOAuth2Application =
  OAuth2Application
  { oAuth2ApplicationClientId = Nothing
  , oAuth2ApplicationClientSecret = Nothing
  , oAuth2ApplicationConfidentialClient = Nothing
  , oAuth2ApplicationCreated = Nothing
  , oAuth2ApplicationId = Nothing
  , oAuth2ApplicationName = Nothing
  , oAuth2ApplicationRedirectUris = Nothing
  }

-- ** Organization
-- | Organization
-- Organization represents an organization
data Organization = Organization
  { organizationAvatarUrl :: !(Maybe Text) -- ^ "avatar_url"
  , organizationDescription :: !(Maybe Text) -- ^ "description"
  , organizationFullName :: !(Maybe Text) -- ^ "full_name"
  , organizationId :: !(Maybe Integer) -- ^ "id"
  , organizationLocation :: !(Maybe Text) -- ^ "location"
  , organizationName :: !(Maybe Text) -- ^ "name"
  , organizationRepoAdminChangeTeamAccess :: !(Maybe Bool) -- ^ "repo_admin_change_team_access"
  , organizationUsername :: !(Maybe Text) -- ^ "username" - deprecated
  , organizationVisibility :: !(Maybe Text) -- ^ "visibility"
  , organizationWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Organization
instance A.FromJSON Organization where
  parseJSON = A.withObject "Organization" $ \o ->
    Organization
      <$> (o .:? "avatar_url")
      <*> (o .:? "description")
      <*> (o .:? "full_name")
      <*> (o .:? "id")
      <*> (o .:? "location")
      <*> (o .:? "name")
      <*> (o .:? "repo_admin_change_team_access")
      <*> (o .:? "username")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON Organization
instance A.ToJSON Organization where
  toJSON Organization {..} =
   _omitNulls
      [ "avatar_url" .= organizationAvatarUrl
      , "description" .= organizationDescription
      , "full_name" .= organizationFullName
      , "id" .= organizationId
      , "location" .= organizationLocation
      , "name" .= organizationName
      , "repo_admin_change_team_access" .= organizationRepoAdminChangeTeamAccess
      , "username" .= organizationUsername
      , "visibility" .= organizationVisibility
      , "website" .= organizationWebsite
      ]


-- | Construct a value of type 'Organization' (by applying it's required fields, if any)
mkOrganization
  :: Organization
mkOrganization =
  Organization
  { organizationAvatarUrl = Nothing
  , organizationDescription = Nothing
  , organizationFullName = Nothing
  , organizationId = Nothing
  , organizationLocation = Nothing
  , organizationName = Nothing
  , organizationRepoAdminChangeTeamAccess = Nothing
  , organizationUsername = Nothing
  , organizationVisibility = Nothing
  , organizationWebsite = Nothing
  }

-- ** OrganizationPermissions
-- | OrganizationPermissions
-- OrganizationPermissions list different users permissions on an organization
data OrganizationPermissions = OrganizationPermissions
  { organizationPermissionsCanCreateRepository :: !(Maybe Bool) -- ^ "can_create_repository"
  , organizationPermissionsCanRead :: !(Maybe Bool) -- ^ "can_read"
  , organizationPermissionsCanWrite :: !(Maybe Bool) -- ^ "can_write"
  , organizationPermissionsIsAdmin :: !(Maybe Bool) -- ^ "is_admin"
  , organizationPermissionsIsOwner :: !(Maybe Bool) -- ^ "is_owner"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrganizationPermissions
instance A.FromJSON OrganizationPermissions where
  parseJSON = A.withObject "OrganizationPermissions" $ \o ->
    OrganizationPermissions
      <$> (o .:? "can_create_repository")
      <*> (o .:? "can_read")
      <*> (o .:? "can_write")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_owner")

-- | ToJSON OrganizationPermissions
instance A.ToJSON OrganizationPermissions where
  toJSON OrganizationPermissions {..} =
   _omitNulls
      [ "can_create_repository" .= organizationPermissionsCanCreateRepository
      , "can_read" .= organizationPermissionsCanRead
      , "can_write" .= organizationPermissionsCanWrite
      , "is_admin" .= organizationPermissionsIsAdmin
      , "is_owner" .= organizationPermissionsIsOwner
      ]


-- | Construct a value of type 'OrganizationPermissions' (by applying it's required fields, if any)
mkOrganizationPermissions
  :: OrganizationPermissions
mkOrganizationPermissions =
  OrganizationPermissions
  { organizationPermissionsCanCreateRepository = Nothing
  , organizationPermissionsCanRead = Nothing
  , organizationPermissionsCanWrite = Nothing
  , organizationPermissionsIsAdmin = Nothing
  , organizationPermissionsIsOwner = Nothing
  }

-- ** PRBranchInfo
-- | PRBranchInfo
-- PRBranchInfo information about a branch
data PRBranchInfo = PRBranchInfo
  { pRBranchInfoLabel :: !(Maybe Text) -- ^ "label"
  , pRBranchInfoRef :: !(Maybe Text) -- ^ "ref"
  , pRBranchInfoRepo :: !(Maybe Repository) -- ^ "repo"
  , pRBranchInfoRepoId :: !(Maybe Integer) -- ^ "repo_id"
  , pRBranchInfoSha :: !(Maybe Text) -- ^ "sha"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PRBranchInfo
instance A.FromJSON PRBranchInfo where
  parseJSON = A.withObject "PRBranchInfo" $ \o ->
    PRBranchInfo
      <$> (o .:? "label")
      <*> (o .:? "ref")
      <*> (o .:? "repo")
      <*> (o .:? "repo_id")
      <*> (o .:? "sha")

-- | ToJSON PRBranchInfo
instance A.ToJSON PRBranchInfo where
  toJSON PRBranchInfo {..} =
   _omitNulls
      [ "label" .= pRBranchInfoLabel
      , "ref" .= pRBranchInfoRef
      , "repo" .= pRBranchInfoRepo
      , "repo_id" .= pRBranchInfoRepoId
      , "sha" .= pRBranchInfoSha
      ]


-- | Construct a value of type 'PRBranchInfo' (by applying it's required fields, if any)
mkPRBranchInfo
  :: PRBranchInfo
mkPRBranchInfo =
  PRBranchInfo
  { pRBranchInfoLabel = Nothing
  , pRBranchInfoRef = Nothing
  , pRBranchInfoRepo = Nothing
  , pRBranchInfoRepoId = Nothing
  , pRBranchInfoSha = Nothing
  }

-- ** Package
-- | Package
-- Package represents a package
data Package = Package
  { packageCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , packageCreator :: !(Maybe User) -- ^ "creator"
  , packageHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , packageId :: !(Maybe Integer) -- ^ "id"
  , packageName :: !(Maybe Text) -- ^ "name"
  , packageOwner :: !(Maybe User) -- ^ "owner"
  , packageRepository :: !(Maybe Repository) -- ^ "repository"
  , packageType :: !(Maybe Text) -- ^ "type"
  , packageVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Package
instance A.FromJSON Package where
  parseJSON = A.withObject "Package" $ \o ->
    Package
      <$> (o .:? "created_at")
      <*> (o .:? "creator")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "owner")
      <*> (o .:? "repository")
      <*> (o .:? "type")
      <*> (o .:? "version")

-- | ToJSON Package
instance A.ToJSON Package where
  toJSON Package {..} =
   _omitNulls
      [ "created_at" .= packageCreatedAt
      , "creator" .= packageCreator
      , "html_url" .= packageHtmlUrl
      , "id" .= packageId
      , "name" .= packageName
      , "owner" .= packageOwner
      , "repository" .= packageRepository
      , "type" .= packageType
      , "version" .= packageVersion
      ]


-- | Construct a value of type 'Package' (by applying it's required fields, if any)
mkPackage
  :: Package
mkPackage =
  Package
  { packageCreatedAt = Nothing
  , packageCreator = Nothing
  , packageHtmlUrl = Nothing
  , packageId = Nothing
  , packageName = Nothing
  , packageOwner = Nothing
  , packageRepository = Nothing
  , packageType = Nothing
  , packageVersion = Nothing
  }

-- ** PackageFile
-- | PackageFile
-- PackageFile represents a package file
data PackageFile = PackageFile
  { packageFileSize :: !(Maybe Integer) -- ^ "Size"
  , packageFileId :: !(Maybe Integer) -- ^ "id"
  , packageFileMd5 :: !(Maybe Text) -- ^ "md5"
  , packageFileName :: !(Maybe Text) -- ^ "name"
  , packageFileSha1 :: !(Maybe Text) -- ^ "sha1"
  , packageFileSha256 :: !(Maybe Text) -- ^ "sha256"
  , packageFileSha512 :: !(Maybe Text) -- ^ "sha512"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PackageFile
instance A.FromJSON PackageFile where
  parseJSON = A.withObject "PackageFile" $ \o ->
    PackageFile
      <$> (o .:? "Size")
      <*> (o .:? "id")
      <*> (o .:? "md5")
      <*> (o .:? "name")
      <*> (o .:? "sha1")
      <*> (o .:? "sha256")
      <*> (o .:? "sha512")

-- | ToJSON PackageFile
instance A.ToJSON PackageFile where
  toJSON PackageFile {..} =
   _omitNulls
      [ "Size" .= packageFileSize
      , "id" .= packageFileId
      , "md5" .= packageFileMd5
      , "name" .= packageFileName
      , "sha1" .= packageFileSha1
      , "sha256" .= packageFileSha256
      , "sha512" .= packageFileSha512
      ]


-- | Construct a value of type 'PackageFile' (by applying it's required fields, if any)
mkPackageFile
  :: PackageFile
mkPackageFile =
  PackageFile
  { packageFileSize = Nothing
  , packageFileId = Nothing
  , packageFileMd5 = Nothing
  , packageFileName = Nothing
  , packageFileSha1 = Nothing
  , packageFileSha256 = Nothing
  , packageFileSha512 = Nothing
  }

-- ** PayloadCommit
-- | PayloadCommit
-- PayloadCommit represents a commit
data PayloadCommit = PayloadCommit
  { payloadCommitAdded :: !(Maybe [Text]) -- ^ "added"
  , payloadCommitAuthor :: !(Maybe PayloadUser) -- ^ "author"
  , payloadCommitCommitter :: !(Maybe PayloadUser) -- ^ "committer"
  , payloadCommitId :: !(Maybe Text) -- ^ "id" - sha1 hash of the commit
  , payloadCommitMessage :: !(Maybe Text) -- ^ "message"
  , payloadCommitModified :: !(Maybe [Text]) -- ^ "modified"
  , payloadCommitRemoved :: !(Maybe [Text]) -- ^ "removed"
  , payloadCommitTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , payloadCommitUrl :: !(Maybe Text) -- ^ "url"
  , payloadCommitVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadCommit
instance A.FromJSON PayloadCommit where
  parseJSON = A.withObject "PayloadCommit" $ \o ->
    PayloadCommit
      <$> (o .:? "added")
      <*> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "id")
      <*> (o .:? "message")
      <*> (o .:? "modified")
      <*> (o .:? "removed")
      <*> (o .:? "timestamp")
      <*> (o .:? "url")
      <*> (o .:? "verification")

-- | ToJSON PayloadCommit
instance A.ToJSON PayloadCommit where
  toJSON PayloadCommit {..} =
   _omitNulls
      [ "added" .= payloadCommitAdded
      , "author" .= payloadCommitAuthor
      , "committer" .= payloadCommitCommitter
      , "id" .= payloadCommitId
      , "message" .= payloadCommitMessage
      , "modified" .= payloadCommitModified
      , "removed" .= payloadCommitRemoved
      , "timestamp" .= payloadCommitTimestamp
      , "url" .= payloadCommitUrl
      , "verification" .= payloadCommitVerification
      ]


-- | Construct a value of type 'PayloadCommit' (by applying it's required fields, if any)
mkPayloadCommit
  :: PayloadCommit
mkPayloadCommit =
  PayloadCommit
  { payloadCommitAdded = Nothing
  , payloadCommitAuthor = Nothing
  , payloadCommitCommitter = Nothing
  , payloadCommitId = Nothing
  , payloadCommitMessage = Nothing
  , payloadCommitModified = Nothing
  , payloadCommitRemoved = Nothing
  , payloadCommitTimestamp = Nothing
  , payloadCommitUrl = Nothing
  , payloadCommitVerification = Nothing
  }

-- ** PayloadCommitVerification
-- | PayloadCommitVerification
-- PayloadCommitVerification represents the GPG verification of a commit
data PayloadCommitVerification = PayloadCommitVerification
  { payloadCommitVerificationPayload :: !(Maybe Text) -- ^ "payload"
  , payloadCommitVerificationReason :: !(Maybe Text) -- ^ "reason"
  , payloadCommitVerificationSignature :: !(Maybe Text) -- ^ "signature"
  , payloadCommitVerificationSigner :: !(Maybe PayloadUser) -- ^ "signer"
  , payloadCommitVerificationVerified :: !(Maybe Bool) -- ^ "verified"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadCommitVerification
instance A.FromJSON PayloadCommitVerification where
  parseJSON = A.withObject "PayloadCommitVerification" $ \o ->
    PayloadCommitVerification
      <$> (o .:? "payload")
      <*> (o .:? "reason")
      <*> (o .:? "signature")
      <*> (o .:? "signer")
      <*> (o .:? "verified")

-- | ToJSON PayloadCommitVerification
instance A.ToJSON PayloadCommitVerification where
  toJSON PayloadCommitVerification {..} =
   _omitNulls
      [ "payload" .= payloadCommitVerificationPayload
      , "reason" .= payloadCommitVerificationReason
      , "signature" .= payloadCommitVerificationSignature
      , "signer" .= payloadCommitVerificationSigner
      , "verified" .= payloadCommitVerificationVerified
      ]


-- | Construct a value of type 'PayloadCommitVerification' (by applying it's required fields, if any)
mkPayloadCommitVerification
  :: PayloadCommitVerification
mkPayloadCommitVerification =
  PayloadCommitVerification
  { payloadCommitVerificationPayload = Nothing
  , payloadCommitVerificationReason = Nothing
  , payloadCommitVerificationSignature = Nothing
  , payloadCommitVerificationSigner = Nothing
  , payloadCommitVerificationVerified = Nothing
  }

-- ** PayloadUser
-- | PayloadUser
-- PayloadUser represents the author or committer of a commit
data PayloadUser = PayloadUser
  { payloadUserEmail :: !(Maybe Text) -- ^ "email"
  , payloadUserName :: !(Maybe Text) -- ^ "name" - Full name of the commit author
  , payloadUserUsername :: !(Maybe Text) -- ^ "username"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayloadUser
instance A.FromJSON PayloadUser where
  parseJSON = A.withObject "PayloadUser" $ \o ->
    PayloadUser
      <$> (o .:? "email")
      <*> (o .:? "name")
      <*> (o .:? "username")

-- | ToJSON PayloadUser
instance A.ToJSON PayloadUser where
  toJSON PayloadUser {..} =
   _omitNulls
      [ "email" .= payloadUserEmail
      , "name" .= payloadUserName
      , "username" .= payloadUserUsername
      ]


-- | Construct a value of type 'PayloadUser' (by applying it's required fields, if any)
mkPayloadUser
  :: PayloadUser
mkPayloadUser =
  PayloadUser
  { payloadUserEmail = Nothing
  , payloadUserName = Nothing
  , payloadUserUsername = Nothing
  }

-- ** Permission
-- | Permission
-- Permission represents a set of permissions
data Permission = Permission
  { permissionAdmin :: !(Maybe Bool) -- ^ "admin"
  , permissionPull :: !(Maybe Bool) -- ^ "pull"
  , permissionPush :: !(Maybe Bool) -- ^ "push"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Permission
instance A.FromJSON Permission where
  parseJSON = A.withObject "Permission" $ \o ->
    Permission
      <$> (o .:? "admin")
      <*> (o .:? "pull")
      <*> (o .:? "push")

-- | ToJSON Permission
instance A.ToJSON Permission where
  toJSON Permission {..} =
   _omitNulls
      [ "admin" .= permissionAdmin
      , "pull" .= permissionPull
      , "push" .= permissionPush
      ]


-- | Construct a value of type 'Permission' (by applying it's required fields, if any)
mkPermission
  :: Permission
mkPermission =
  Permission
  { permissionAdmin = Nothing
  , permissionPull = Nothing
  , permissionPush = Nothing
  }

-- ** PublicKey
-- | PublicKey
-- PublicKey publickey is a user key to push code to repository
data PublicKey = PublicKey
  { publicKeyCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , publicKeyFingerprint :: !(Maybe Text) -- ^ "fingerprint"
  , publicKeyId :: !(Maybe Integer) -- ^ "id"
  , publicKeyKey :: !(Maybe Text) -- ^ "key"
  , publicKeyKeyType :: !(Maybe Text) -- ^ "key_type"
  , publicKeyReadOnly :: !(Maybe Bool) -- ^ "read_only"
  , publicKeyTitle :: !(Maybe Text) -- ^ "title"
  , publicKeyUrl :: !(Maybe Text) -- ^ "url"
  , publicKeyUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PublicKey
instance A.FromJSON PublicKey where
  parseJSON = A.withObject "PublicKey" $ \o ->
    PublicKey
      <$> (o .:? "created_at")
      <*> (o .:? "fingerprint")
      <*> (o .:? "id")
      <*> (o .:? "key")
      <*> (o .:? "key_type")
      <*> (o .:? "read_only")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON PublicKey
instance A.ToJSON PublicKey where
  toJSON PublicKey {..} =
   _omitNulls
      [ "created_at" .= publicKeyCreatedAt
      , "fingerprint" .= publicKeyFingerprint
      , "id" .= publicKeyId
      , "key" .= publicKeyKey
      , "key_type" .= publicKeyKeyType
      , "read_only" .= publicKeyReadOnly
      , "title" .= publicKeyTitle
      , "url" .= publicKeyUrl
      , "user" .= publicKeyUser
      ]


-- | Construct a value of type 'PublicKey' (by applying it's required fields, if any)
mkPublicKey
  :: PublicKey
mkPublicKey =
  PublicKey
  { publicKeyCreatedAt = Nothing
  , publicKeyFingerprint = Nothing
  , publicKeyId = Nothing
  , publicKeyKey = Nothing
  , publicKeyKeyType = Nothing
  , publicKeyReadOnly = Nothing
  , publicKeyTitle = Nothing
  , publicKeyUrl = Nothing
  , publicKeyUser = Nothing
  }

-- ** PullRequest
-- | PullRequest
-- PullRequest represents a pull request
data PullRequest = PullRequest
  { pullRequestAllowMaintainerEdit :: !(Maybe Bool) -- ^ "allow_maintainer_edit"
  , pullRequestAssignee :: !(Maybe User) -- ^ "assignee"
  , pullRequestAssignees :: !(Maybe [User]) -- ^ "assignees"
  , pullRequestBase :: !(Maybe PRBranchInfo) -- ^ "base"
  , pullRequestBody :: !(Maybe Text) -- ^ "body"
  , pullRequestClosedAt :: !(Maybe DateTime) -- ^ "closed_at"
  , pullRequestComments :: !(Maybe Integer) -- ^ "comments"
  , pullRequestCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , pullRequestDiffUrl :: !(Maybe Text) -- ^ "diff_url"
  , pullRequestDueDate :: !(Maybe DateTime) -- ^ "due_date"
  , pullRequestHead :: !(Maybe PRBranchInfo) -- ^ "head"
  , pullRequestHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , pullRequestId :: !(Maybe Integer) -- ^ "id"
  , pullRequestIsLocked :: !(Maybe Bool) -- ^ "is_locked"
  , pullRequestLabels :: !(Maybe [Label]) -- ^ "labels"
  , pullRequestMergeBase :: !(Maybe Text) -- ^ "merge_base"
  , pullRequestMergeCommitSha :: !(Maybe Text) -- ^ "merge_commit_sha"
  , pullRequestMergeable :: !(Maybe Bool) -- ^ "mergeable"
  , pullRequestMerged :: !(Maybe Bool) -- ^ "merged"
  , pullRequestMergedAt :: !(Maybe DateTime) -- ^ "merged_at"
  , pullRequestMergedBy :: !(Maybe User) -- ^ "merged_by"
  , pullRequestMilestone :: !(Maybe Milestone) -- ^ "milestone"
  , pullRequestNumber :: !(Maybe Integer) -- ^ "number"
  , pullRequestPatchUrl :: !(Maybe Text) -- ^ "patch_url"
  , pullRequestPinOrder :: !(Maybe Integer) -- ^ "pin_order"
  , pullRequestRequestedReviewers :: !(Maybe [User]) -- ^ "requested_reviewers"
  , pullRequestState :: !(Maybe Text) -- ^ "state" - StateType issue state type
  , pullRequestTitle :: !(Maybe Text) -- ^ "title"
  , pullRequestUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , pullRequestUrl :: !(Maybe Text) -- ^ "url"
  , pullRequestUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullRequest
instance A.FromJSON PullRequest where
  parseJSON = A.withObject "PullRequest" $ \o ->
    PullRequest
      <$> (o .:? "allow_maintainer_edit")
      <*> (o .:? "assignee")
      <*> (o .:? "assignees")
      <*> (o .:? "base")
      <*> (o .:? "body")
      <*> (o .:? "closed_at")
      <*> (o .:? "comments")
      <*> (o .:? "created_at")
      <*> (o .:? "diff_url")
      <*> (o .:? "due_date")
      <*> (o .:? "head")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "is_locked")
      <*> (o .:? "labels")
      <*> (o .:? "merge_base")
      <*> (o .:? "merge_commit_sha")
      <*> (o .:? "mergeable")
      <*> (o .:? "merged")
      <*> (o .:? "merged_at")
      <*> (o .:? "merged_by")
      <*> (o .:? "milestone")
      <*> (o .:? "number")
      <*> (o .:? "patch_url")
      <*> (o .:? "pin_order")
      <*> (o .:? "requested_reviewers")
      <*> (o .:? "state")
      <*> (o .:? "title")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")
      <*> (o .:? "user")

-- | ToJSON PullRequest
instance A.ToJSON PullRequest where
  toJSON PullRequest {..} =
   _omitNulls
      [ "allow_maintainer_edit" .= pullRequestAllowMaintainerEdit
      , "assignee" .= pullRequestAssignee
      , "assignees" .= pullRequestAssignees
      , "base" .= pullRequestBase
      , "body" .= pullRequestBody
      , "closed_at" .= pullRequestClosedAt
      , "comments" .= pullRequestComments
      , "created_at" .= pullRequestCreatedAt
      , "diff_url" .= pullRequestDiffUrl
      , "due_date" .= pullRequestDueDate
      , "head" .= pullRequestHead
      , "html_url" .= pullRequestHtmlUrl
      , "id" .= pullRequestId
      , "is_locked" .= pullRequestIsLocked
      , "labels" .= pullRequestLabels
      , "merge_base" .= pullRequestMergeBase
      , "merge_commit_sha" .= pullRequestMergeCommitSha
      , "mergeable" .= pullRequestMergeable
      , "merged" .= pullRequestMerged
      , "merged_at" .= pullRequestMergedAt
      , "merged_by" .= pullRequestMergedBy
      , "milestone" .= pullRequestMilestone
      , "number" .= pullRequestNumber
      , "patch_url" .= pullRequestPatchUrl
      , "pin_order" .= pullRequestPinOrder
      , "requested_reviewers" .= pullRequestRequestedReviewers
      , "state" .= pullRequestState
      , "title" .= pullRequestTitle
      , "updated_at" .= pullRequestUpdatedAt
      , "url" .= pullRequestUrl
      , "user" .= pullRequestUser
      ]


-- | Construct a value of type 'PullRequest' (by applying it's required fields, if any)
mkPullRequest
  :: PullRequest
mkPullRequest =
  PullRequest
  { pullRequestAllowMaintainerEdit = Nothing
  , pullRequestAssignee = Nothing
  , pullRequestAssignees = Nothing
  , pullRequestBase = Nothing
  , pullRequestBody = Nothing
  , pullRequestClosedAt = Nothing
  , pullRequestComments = Nothing
  , pullRequestCreatedAt = Nothing
  , pullRequestDiffUrl = Nothing
  , pullRequestDueDate = Nothing
  , pullRequestHead = Nothing
  , pullRequestHtmlUrl = Nothing
  , pullRequestId = Nothing
  , pullRequestIsLocked = Nothing
  , pullRequestLabels = Nothing
  , pullRequestMergeBase = Nothing
  , pullRequestMergeCommitSha = Nothing
  , pullRequestMergeable = Nothing
  , pullRequestMerged = Nothing
  , pullRequestMergedAt = Nothing
  , pullRequestMergedBy = Nothing
  , pullRequestMilestone = Nothing
  , pullRequestNumber = Nothing
  , pullRequestPatchUrl = Nothing
  , pullRequestPinOrder = Nothing
  , pullRequestRequestedReviewers = Nothing
  , pullRequestState = Nothing
  , pullRequestTitle = Nothing
  , pullRequestUpdatedAt = Nothing
  , pullRequestUrl = Nothing
  , pullRequestUser = Nothing
  }

-- ** PullRequestMeta
-- | PullRequestMeta
-- PullRequestMeta PR info if an issue is a PR
data PullRequestMeta = PullRequestMeta
  { pullRequestMetaMerged :: !(Maybe Bool) -- ^ "merged"
  , pullRequestMetaMergedAt :: !(Maybe DateTime) -- ^ "merged_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullRequestMeta
instance A.FromJSON PullRequestMeta where
  parseJSON = A.withObject "PullRequestMeta" $ \o ->
    PullRequestMeta
      <$> (o .:? "merged")
      <*> (o .:? "merged_at")

-- | ToJSON PullRequestMeta
instance A.ToJSON PullRequestMeta where
  toJSON PullRequestMeta {..} =
   _omitNulls
      [ "merged" .= pullRequestMetaMerged
      , "merged_at" .= pullRequestMetaMergedAt
      ]


-- | Construct a value of type 'PullRequestMeta' (by applying it's required fields, if any)
mkPullRequestMeta
  :: PullRequestMeta
mkPullRequestMeta =
  PullRequestMeta
  { pullRequestMetaMerged = Nothing
  , pullRequestMetaMergedAt = Nothing
  }

-- ** PullReview
-- | PullReview
-- PullReview represents a pull request review
data PullReview = PullReview
  { pullReviewBody :: !(Maybe Text) -- ^ "body"
  , pullReviewCommentsCount :: !(Maybe Integer) -- ^ "comments_count"
  , pullReviewCommitId :: !(Maybe Text) -- ^ "commit_id"
  , pullReviewDismissed :: !(Maybe Bool) -- ^ "dismissed"
  , pullReviewHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , pullReviewId :: !(Maybe Integer) -- ^ "id"
  , pullReviewOfficial :: !(Maybe Bool) -- ^ "official"
  , pullReviewPullRequestUrl :: !(Maybe Text) -- ^ "pull_request_url"
  , pullReviewStale :: !(Maybe Bool) -- ^ "stale"
  , pullReviewState :: !(Maybe Text) -- ^ "state" - ReviewStateType review state type
  , pullReviewSubmittedAt :: !(Maybe DateTime) -- ^ "submitted_at"
  , pullReviewTeam :: !(Maybe Team) -- ^ "team"
  , pullReviewUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , pullReviewUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullReview
instance A.FromJSON PullReview where
  parseJSON = A.withObject "PullReview" $ \o ->
    PullReview
      <$> (o .:? "body")
      <*> (o .:? "comments_count")
      <*> (o .:? "commit_id")
      <*> (o .:? "dismissed")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "official")
      <*> (o .:? "pull_request_url")
      <*> (o .:? "stale")
      <*> (o .:? "state")
      <*> (o .:? "submitted_at")
      <*> (o .:? "team")
      <*> (o .:? "updated_at")
      <*> (o .:? "user")

-- | ToJSON PullReview
instance A.ToJSON PullReview where
  toJSON PullReview {..} =
   _omitNulls
      [ "body" .= pullReviewBody
      , "comments_count" .= pullReviewCommentsCount
      , "commit_id" .= pullReviewCommitId
      , "dismissed" .= pullReviewDismissed
      , "html_url" .= pullReviewHtmlUrl
      , "id" .= pullReviewId
      , "official" .= pullReviewOfficial
      , "pull_request_url" .= pullReviewPullRequestUrl
      , "stale" .= pullReviewStale
      , "state" .= pullReviewState
      , "submitted_at" .= pullReviewSubmittedAt
      , "team" .= pullReviewTeam
      , "updated_at" .= pullReviewUpdatedAt
      , "user" .= pullReviewUser
      ]


-- | Construct a value of type 'PullReview' (by applying it's required fields, if any)
mkPullReview
  :: PullReview
mkPullReview =
  PullReview
  { pullReviewBody = Nothing
  , pullReviewCommentsCount = Nothing
  , pullReviewCommitId = Nothing
  , pullReviewDismissed = Nothing
  , pullReviewHtmlUrl = Nothing
  , pullReviewId = Nothing
  , pullReviewOfficial = Nothing
  , pullReviewPullRequestUrl = Nothing
  , pullReviewStale = Nothing
  , pullReviewState = Nothing
  , pullReviewSubmittedAt = Nothing
  , pullReviewTeam = Nothing
  , pullReviewUpdatedAt = Nothing
  , pullReviewUser = Nothing
  }

-- ** PullReviewComment
-- | PullReviewComment
-- PullReviewComment represents a comment on a pull request review
data PullReviewComment = PullReviewComment
  { pullReviewCommentBody :: !(Maybe Text) -- ^ "body"
  , pullReviewCommentCommitId :: !(Maybe Text) -- ^ "commit_id"
  , pullReviewCommentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , pullReviewCommentDiffHunk :: !(Maybe Text) -- ^ "diff_hunk"
  , pullReviewCommentHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , pullReviewCommentId :: !(Maybe Integer) -- ^ "id"
  , pullReviewCommentOriginalCommitId :: !(Maybe Text) -- ^ "original_commit_id"
  , pullReviewCommentOriginalPosition :: !(Maybe Int) -- ^ "original_position"
  , pullReviewCommentPath :: !(Maybe Text) -- ^ "path"
  , pullReviewCommentPosition :: !(Maybe Int) -- ^ "position"
  , pullReviewCommentPullRequestReviewId :: !(Maybe Integer) -- ^ "pull_request_review_id"
  , pullReviewCommentPullRequestUrl :: !(Maybe Text) -- ^ "pull_request_url"
  , pullReviewCommentResolver :: !(Maybe User) -- ^ "resolver"
  , pullReviewCommentUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , pullReviewCommentUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullReviewComment
instance A.FromJSON PullReviewComment where
  parseJSON = A.withObject "PullReviewComment" $ \o ->
    PullReviewComment
      <$> (o .:? "body")
      <*> (o .:? "commit_id")
      <*> (o .:? "created_at")
      <*> (o .:? "diff_hunk")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "original_commit_id")
      <*> (o .:? "original_position")
      <*> (o .:? "path")
      <*> (o .:? "position")
      <*> (o .:? "pull_request_review_id")
      <*> (o .:? "pull_request_url")
      <*> (o .:? "resolver")
      <*> (o .:? "updated_at")
      <*> (o .:? "user")

-- | ToJSON PullReviewComment
instance A.ToJSON PullReviewComment where
  toJSON PullReviewComment {..} =
   _omitNulls
      [ "body" .= pullReviewCommentBody
      , "commit_id" .= pullReviewCommentCommitId
      , "created_at" .= pullReviewCommentCreatedAt
      , "diff_hunk" .= pullReviewCommentDiffHunk
      , "html_url" .= pullReviewCommentHtmlUrl
      , "id" .= pullReviewCommentId
      , "original_commit_id" .= pullReviewCommentOriginalCommitId
      , "original_position" .= pullReviewCommentOriginalPosition
      , "path" .= pullReviewCommentPath
      , "position" .= pullReviewCommentPosition
      , "pull_request_review_id" .= pullReviewCommentPullRequestReviewId
      , "pull_request_url" .= pullReviewCommentPullRequestUrl
      , "resolver" .= pullReviewCommentResolver
      , "updated_at" .= pullReviewCommentUpdatedAt
      , "user" .= pullReviewCommentUser
      ]


-- | Construct a value of type 'PullReviewComment' (by applying it's required fields, if any)
mkPullReviewComment
  :: PullReviewComment
mkPullReviewComment =
  PullReviewComment
  { pullReviewCommentBody = Nothing
  , pullReviewCommentCommitId = Nothing
  , pullReviewCommentCreatedAt = Nothing
  , pullReviewCommentDiffHunk = Nothing
  , pullReviewCommentHtmlUrl = Nothing
  , pullReviewCommentId = Nothing
  , pullReviewCommentOriginalCommitId = Nothing
  , pullReviewCommentOriginalPosition = Nothing
  , pullReviewCommentPath = Nothing
  , pullReviewCommentPosition = Nothing
  , pullReviewCommentPullRequestReviewId = Nothing
  , pullReviewCommentPullRequestUrl = Nothing
  , pullReviewCommentResolver = Nothing
  , pullReviewCommentUpdatedAt = Nothing
  , pullReviewCommentUser = Nothing
  }

-- ** PullReviewRequestOptions
-- | PullReviewRequestOptions
-- PullReviewRequestOptions are options to add or remove pull review requests
data PullReviewRequestOptions = PullReviewRequestOptions
  { pullReviewRequestOptionsReviewers :: !(Maybe [Text]) -- ^ "reviewers"
  , pullReviewRequestOptionsTeamReviewers :: !(Maybe [Text]) -- ^ "team_reviewers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PullReviewRequestOptions
instance A.FromJSON PullReviewRequestOptions where
  parseJSON = A.withObject "PullReviewRequestOptions" $ \o ->
    PullReviewRequestOptions
      <$> (o .:? "reviewers")
      <*> (o .:? "team_reviewers")

-- | ToJSON PullReviewRequestOptions
instance A.ToJSON PullReviewRequestOptions where
  toJSON PullReviewRequestOptions {..} =
   _omitNulls
      [ "reviewers" .= pullReviewRequestOptionsReviewers
      , "team_reviewers" .= pullReviewRequestOptionsTeamReviewers
      ]


-- | Construct a value of type 'PullReviewRequestOptions' (by applying it's required fields, if any)
mkPullReviewRequestOptions
  :: PullReviewRequestOptions
mkPullReviewRequestOptions =
  PullReviewRequestOptions
  { pullReviewRequestOptionsReviewers = Nothing
  , pullReviewRequestOptionsTeamReviewers = Nothing
  }

-- ** PushMirror
-- | PushMirror
-- PushMirror represents information of a push mirror
data PushMirror = PushMirror
  { pushMirrorCreated :: !(Maybe Text) -- ^ "created"
  , pushMirrorInterval :: !(Maybe Text) -- ^ "interval"
  , pushMirrorLastError :: !(Maybe Text) -- ^ "last_error"
  , pushMirrorLastUpdate :: !(Maybe Text) -- ^ "last_update"
  , pushMirrorRemoteAddress :: !(Maybe Text) -- ^ "remote_address"
  , pushMirrorRemoteName :: !(Maybe Text) -- ^ "remote_name"
  , pushMirrorRepoName :: !(Maybe Text) -- ^ "repo_name"
  , pushMirrorSyncOnCommit :: !(Maybe Bool) -- ^ "sync_on_commit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushMirror
instance A.FromJSON PushMirror where
  parseJSON = A.withObject "PushMirror" $ \o ->
    PushMirror
      <$> (o .:? "created")
      <*> (o .:? "interval")
      <*> (o .:? "last_error")
      <*> (o .:? "last_update")
      <*> (o .:? "remote_address")
      <*> (o .:? "remote_name")
      <*> (o .:? "repo_name")
      <*> (o .:? "sync_on_commit")

-- | ToJSON PushMirror
instance A.ToJSON PushMirror where
  toJSON PushMirror {..} =
   _omitNulls
      [ "created" .= pushMirrorCreated
      , "interval" .= pushMirrorInterval
      , "last_error" .= pushMirrorLastError
      , "last_update" .= pushMirrorLastUpdate
      , "remote_address" .= pushMirrorRemoteAddress
      , "remote_name" .= pushMirrorRemoteName
      , "repo_name" .= pushMirrorRepoName
      , "sync_on_commit" .= pushMirrorSyncOnCommit
      ]


-- | Construct a value of type 'PushMirror' (by applying it's required fields, if any)
mkPushMirror
  :: PushMirror
mkPushMirror =
  PushMirror
  { pushMirrorCreated = Nothing
  , pushMirrorInterval = Nothing
  , pushMirrorLastError = Nothing
  , pushMirrorLastUpdate = Nothing
  , pushMirrorRemoteAddress = Nothing
  , pushMirrorRemoteName = Nothing
  , pushMirrorRepoName = Nothing
  , pushMirrorSyncOnCommit = Nothing
  }

-- ** Reaction
-- | Reaction
-- Reaction contain one reaction
data Reaction = Reaction
  { reactionContent :: !(Maybe Text) -- ^ "content"
  , reactionCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , reactionUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Reaction
instance A.FromJSON Reaction where
  parseJSON = A.withObject "Reaction" $ \o ->
    Reaction
      <$> (o .:? "content")
      <*> (o .:? "created_at")
      <*> (o .:? "user")

-- | ToJSON Reaction
instance A.ToJSON Reaction where
  toJSON Reaction {..} =
   _omitNulls
      [ "content" .= reactionContent
      , "created_at" .= reactionCreatedAt
      , "user" .= reactionUser
      ]


-- | Construct a value of type 'Reaction' (by applying it's required fields, if any)
mkReaction
  :: Reaction
mkReaction =
  Reaction
  { reactionContent = Nothing
  , reactionCreatedAt = Nothing
  , reactionUser = Nothing
  }

-- ** Reference
-- | Reference
-- Reference represents a Git reference.
-- 
data Reference = Reference
  { referenceObject :: !(Maybe GitObject) -- ^ "object"
  , referenceRef :: !(Maybe Text) -- ^ "ref"
  , referenceUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Reference
instance A.FromJSON Reference where
  parseJSON = A.withObject "Reference" $ \o ->
    Reference
      <$> (o .:? "object")
      <*> (o .:? "ref")
      <*> (o .:? "url")

-- | ToJSON Reference
instance A.ToJSON Reference where
  toJSON Reference {..} =
   _omitNulls
      [ "object" .= referenceObject
      , "ref" .= referenceRef
      , "url" .= referenceUrl
      ]


-- | Construct a value of type 'Reference' (by applying it's required fields, if any)
mkReference
  :: Reference
mkReference =
  Reference
  { referenceObject = Nothing
  , referenceRef = Nothing
  , referenceUrl = Nothing
  }

-- ** Release
-- | Release
-- Release represents a repository release
data Release = Release
  { releaseAssets :: !(Maybe [Attachment]) -- ^ "assets"
  , releaseAuthor :: !(Maybe User) -- ^ "author"
  , releaseBody :: !(Maybe Text) -- ^ "body"
  , releaseCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , releaseDraft :: !(Maybe Bool) -- ^ "draft"
  , releaseHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , releaseId :: !(Maybe Integer) -- ^ "id"
  , releaseName :: !(Maybe Text) -- ^ "name"
  , releasePrerelease :: !(Maybe Bool) -- ^ "prerelease"
  , releasePublishedAt :: !(Maybe DateTime) -- ^ "published_at"
  , releaseTagName :: !(Maybe Text) -- ^ "tag_name"
  , releaseTarballUrl :: !(Maybe Text) -- ^ "tarball_url"
  , releaseTargetCommitish :: !(Maybe Text) -- ^ "target_commitish"
  , releaseUrl :: !(Maybe Text) -- ^ "url"
  , releaseZipballUrl :: !(Maybe Text) -- ^ "zipball_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Release
instance A.FromJSON Release where
  parseJSON = A.withObject "Release" $ \o ->
    Release
      <$> (o .:? "assets")
      <*> (o .:? "author")
      <*> (o .:? "body")
      <*> (o .:? "created_at")
      <*> (o .:? "draft")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "prerelease")
      <*> (o .:? "published_at")
      <*> (o .:? "tag_name")
      <*> (o .:? "tarball_url")
      <*> (o .:? "target_commitish")
      <*> (o .:? "url")
      <*> (o .:? "zipball_url")

-- | ToJSON Release
instance A.ToJSON Release where
  toJSON Release {..} =
   _omitNulls
      [ "assets" .= releaseAssets
      , "author" .= releaseAuthor
      , "body" .= releaseBody
      , "created_at" .= releaseCreatedAt
      , "draft" .= releaseDraft
      , "html_url" .= releaseHtmlUrl
      , "id" .= releaseId
      , "name" .= releaseName
      , "prerelease" .= releasePrerelease
      , "published_at" .= releasePublishedAt
      , "tag_name" .= releaseTagName
      , "tarball_url" .= releaseTarballUrl
      , "target_commitish" .= releaseTargetCommitish
      , "url" .= releaseUrl
      , "zipball_url" .= releaseZipballUrl
      ]


-- | Construct a value of type 'Release' (by applying it's required fields, if any)
mkRelease
  :: Release
mkRelease =
  Release
  { releaseAssets = Nothing
  , releaseAuthor = Nothing
  , releaseBody = Nothing
  , releaseCreatedAt = Nothing
  , releaseDraft = Nothing
  , releaseHtmlUrl = Nothing
  , releaseId = Nothing
  , releaseName = Nothing
  , releasePrerelease = Nothing
  , releasePublishedAt = Nothing
  , releaseTagName = Nothing
  , releaseTarballUrl = Nothing
  , releaseTargetCommitish = Nothing
  , releaseUrl = Nothing
  , releaseZipballUrl = Nothing
  }

-- ** RenameUserOption
-- | RenameUserOption
-- RenameUserOption options when renaming a user
data RenameUserOption = RenameUserOption
  { renameUserOptionNewUsername :: !(Text) -- ^ /Required/ "new_username" - New username for this user. This name cannot be in use yet by any other user.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RenameUserOption
instance A.FromJSON RenameUserOption where
  parseJSON = A.withObject "RenameUserOption" $ \o ->
    RenameUserOption
      <$> (o .:  "new_username")

-- | ToJSON RenameUserOption
instance A.ToJSON RenameUserOption where
  toJSON RenameUserOption {..} =
   _omitNulls
      [ "new_username" .= renameUserOptionNewUsername
      ]


-- | Construct a value of type 'RenameUserOption' (by applying it's required fields, if any)
mkRenameUserOption
  :: Text -- ^ 'renameUserOptionNewUsername': New username for this user. This name cannot be in use yet by any other user.
  -> RenameUserOption
mkRenameUserOption renameUserOptionNewUsername =
  RenameUserOption
  { renameUserOptionNewUsername
  }

-- ** RepoCollaboratorPermission
-- | RepoCollaboratorPermission
-- RepoCollaboratorPermission to get repository permission for a collaborator
data RepoCollaboratorPermission = RepoCollaboratorPermission
  { repoCollaboratorPermissionPermission :: !(Maybe Text) -- ^ "permission"
  , repoCollaboratorPermissionRoleName :: !(Maybe Text) -- ^ "role_name"
  , repoCollaboratorPermissionUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepoCollaboratorPermission
instance A.FromJSON RepoCollaboratorPermission where
  parseJSON = A.withObject "RepoCollaboratorPermission" $ \o ->
    RepoCollaboratorPermission
      <$> (o .:? "permission")
      <*> (o .:? "role_name")
      <*> (o .:? "user")

-- | ToJSON RepoCollaboratorPermission
instance A.ToJSON RepoCollaboratorPermission where
  toJSON RepoCollaboratorPermission {..} =
   _omitNulls
      [ "permission" .= repoCollaboratorPermissionPermission
      , "role_name" .= repoCollaboratorPermissionRoleName
      , "user" .= repoCollaboratorPermissionUser
      ]


-- | Construct a value of type 'RepoCollaboratorPermission' (by applying it's required fields, if any)
mkRepoCollaboratorPermission
  :: RepoCollaboratorPermission
mkRepoCollaboratorPermission =
  RepoCollaboratorPermission
  { repoCollaboratorPermissionPermission = Nothing
  , repoCollaboratorPermissionRoleName = Nothing
  , repoCollaboratorPermissionUser = Nothing
  }

-- ** RepoCommit
-- | RepoCommit
-- RepoCommit contains information of a commit in the context of a repository.
-- 
data RepoCommit = RepoCommit
  { repoCommitAuthor :: !(Maybe CommitUser) -- ^ "author"
  , repoCommitCommitter :: !(Maybe CommitUser) -- ^ "committer"
  , repoCommitMessage :: !(Maybe Text) -- ^ "message"
  , repoCommitTree :: !(Maybe CommitMeta) -- ^ "tree"
  , repoCommitUrl :: !(Maybe Text) -- ^ "url"
  , repoCommitVerification :: !(Maybe PayloadCommitVerification) -- ^ "verification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepoCommit
instance A.FromJSON RepoCommit where
  parseJSON = A.withObject "RepoCommit" $ \o ->
    RepoCommit
      <$> (o .:? "author")
      <*> (o .:? "committer")
      <*> (o .:? "message")
      <*> (o .:? "tree")
      <*> (o .:? "url")
      <*> (o .:? "verification")

-- | ToJSON RepoCommit
instance A.ToJSON RepoCommit where
  toJSON RepoCommit {..} =
   _omitNulls
      [ "author" .= repoCommitAuthor
      , "committer" .= repoCommitCommitter
      , "message" .= repoCommitMessage
      , "tree" .= repoCommitTree
      , "url" .= repoCommitUrl
      , "verification" .= repoCommitVerification
      ]


-- | Construct a value of type 'RepoCommit' (by applying it's required fields, if any)
mkRepoCommit
  :: RepoCommit
mkRepoCommit =
  RepoCommit
  { repoCommitAuthor = Nothing
  , repoCommitCommitter = Nothing
  , repoCommitMessage = Nothing
  , repoCommitTree = Nothing
  , repoCommitUrl = Nothing
  , repoCommitVerification = Nothing
  }

-- ** RepoTopicOptions
-- | RepoTopicOptions
-- RepoTopicOptions a collection of repo topic names
data RepoTopicOptions = RepoTopicOptions
  { repoTopicOptionsTopics :: !(Maybe [Text]) -- ^ "topics" - list of topic names
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepoTopicOptions
instance A.FromJSON RepoTopicOptions where
  parseJSON = A.withObject "RepoTopicOptions" $ \o ->
    RepoTopicOptions
      <$> (o .:? "topics")

-- | ToJSON RepoTopicOptions
instance A.ToJSON RepoTopicOptions where
  toJSON RepoTopicOptions {..} =
   _omitNulls
      [ "topics" .= repoTopicOptionsTopics
      ]


-- | Construct a value of type 'RepoTopicOptions' (by applying it's required fields, if any)
mkRepoTopicOptions
  :: RepoTopicOptions
mkRepoTopicOptions =
  RepoTopicOptions
  { repoTopicOptionsTopics = Nothing
  }

-- ** RepoTransfer
-- | RepoTransfer
-- RepoTransfer represents a pending repo transfer
data RepoTransfer = RepoTransfer
  { repoTransferDoer :: !(Maybe User) -- ^ "doer"
  , repoTransferRecipient :: !(Maybe User) -- ^ "recipient"
  , repoTransferTeams :: !(Maybe [Team]) -- ^ "teams"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepoTransfer
instance A.FromJSON RepoTransfer where
  parseJSON = A.withObject "RepoTransfer" $ \o ->
    RepoTransfer
      <$> (o .:? "doer")
      <*> (o .:? "recipient")
      <*> (o .:? "teams")

-- | ToJSON RepoTransfer
instance A.ToJSON RepoTransfer where
  toJSON RepoTransfer {..} =
   _omitNulls
      [ "doer" .= repoTransferDoer
      , "recipient" .= repoTransferRecipient
      , "teams" .= repoTransferTeams
      ]


-- | Construct a value of type 'RepoTransfer' (by applying it's required fields, if any)
mkRepoTransfer
  :: RepoTransfer
mkRepoTransfer =
  RepoTransfer
  { repoTransferDoer = Nothing
  , repoTransferRecipient = Nothing
  , repoTransferTeams = Nothing
  }

-- ** Repository
-- | Repository
-- Repository represents a repository
data Repository = Repository
  { repositoryAllowMergeCommits :: !(Maybe Bool) -- ^ "allow_merge_commits"
  , repositoryAllowRebase :: !(Maybe Bool) -- ^ "allow_rebase"
  , repositoryAllowRebaseExplicit :: !(Maybe Bool) -- ^ "allow_rebase_explicit"
  , repositoryAllowRebaseUpdate :: !(Maybe Bool) -- ^ "allow_rebase_update"
  , repositoryAllowSquashMerge :: !(Maybe Bool) -- ^ "allow_squash_merge"
  , repositoryArchived :: !(Maybe Bool) -- ^ "archived"
  , repositoryArchivedAt :: !(Maybe DateTime) -- ^ "archived_at"
  , repositoryAvatarUrl :: !(Maybe Text) -- ^ "avatar_url"
  , repositoryCloneUrl :: !(Maybe Text) -- ^ "clone_url"
  , repositoryCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , repositoryDefaultAllowMaintainerEdit :: !(Maybe Bool) -- ^ "default_allow_maintainer_edit"
  , repositoryDefaultBranch :: !(Maybe Text) -- ^ "default_branch"
  , repositoryDefaultDeleteBranchAfterMerge :: !(Maybe Bool) -- ^ "default_delete_branch_after_merge"
  , repositoryDefaultMergeStyle :: !(Maybe Text) -- ^ "default_merge_style"
  , repositoryDescription :: !(Maybe Text) -- ^ "description"
  , repositoryEmpty :: !(Maybe Bool) -- ^ "empty"
  , repositoryExternalTracker :: !(Maybe ExternalTracker) -- ^ "external_tracker"
  , repositoryExternalWiki :: !(Maybe ExternalWiki) -- ^ "external_wiki"
  , repositoryFork :: !(Maybe Bool) -- ^ "fork"
  , repositoryForksCount :: !(Maybe Integer) -- ^ "forks_count"
  , repositoryFullName :: !(Maybe Text) -- ^ "full_name"
  , repositoryHasActions :: !(Maybe Bool) -- ^ "has_actions"
  , repositoryHasIssues :: !(Maybe Bool) -- ^ "has_issues"
  , repositoryHasPackages :: !(Maybe Bool) -- ^ "has_packages"
  , repositoryHasProjects :: !(Maybe Bool) -- ^ "has_projects"
  , repositoryHasPullRequests :: !(Maybe Bool) -- ^ "has_pull_requests"
  , repositoryHasReleases :: !(Maybe Bool) -- ^ "has_releases"
  , repositoryHasWiki :: !(Maybe Bool) -- ^ "has_wiki"
  , repositoryHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , repositoryId :: !(Maybe Integer) -- ^ "id"
  , repositoryIgnoreWhitespaceConflicts :: !(Maybe Bool) -- ^ "ignore_whitespace_conflicts"
  , repositoryInternal :: !(Maybe Bool) -- ^ "internal"
  , repositoryInternalTracker :: !(Maybe InternalTracker) -- ^ "internal_tracker"
  , repositoryLanguage :: !(Maybe Text) -- ^ "language"
  , repositoryLanguagesUrl :: !(Maybe Text) -- ^ "languages_url"
  , repositoryLink :: !(Maybe Text) -- ^ "link"
  , repositoryMirror :: !(Maybe Bool) -- ^ "mirror"
  , repositoryMirrorInterval :: !(Maybe Text) -- ^ "mirror_interval"
  , repositoryMirrorUpdated :: !(Maybe DateTime) -- ^ "mirror_updated"
  , repositoryName :: !(Maybe Text) -- ^ "name"
  , repositoryOpenIssuesCount :: !(Maybe Integer) -- ^ "open_issues_count"
  , repositoryOpenPrCounter :: !(Maybe Integer) -- ^ "open_pr_counter"
  , repositoryOriginalUrl :: !(Maybe Text) -- ^ "original_url"
  , repositoryOwner :: !(Maybe User) -- ^ "owner"
  , repositoryParent :: !(Maybe Repository) -- ^ "parent"
  , repositoryPermissions :: !(Maybe Permission) -- ^ "permissions"
  , repositoryPrivate :: !(Maybe Bool) -- ^ "private"
  , repositoryReleaseCounter :: !(Maybe Integer) -- ^ "release_counter"
  , repositoryRepoTransfer :: !(Maybe RepoTransfer) -- ^ "repo_transfer"
  , repositorySize :: !(Maybe Integer) -- ^ "size"
  , repositorySshUrl :: !(Maybe Text) -- ^ "ssh_url"
  , repositoryStarsCount :: !(Maybe Integer) -- ^ "stars_count"
  , repositoryTemplate :: !(Maybe Bool) -- ^ "template"
  , repositoryUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , repositoryUrl :: !(Maybe Text) -- ^ "url"
  , repositoryWatchersCount :: !(Maybe Integer) -- ^ "watchers_count"
  , repositoryWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Repository
instance A.FromJSON Repository where
  parseJSON = A.withObject "Repository" $ \o ->
    Repository
      <$> (o .:? "allow_merge_commits")
      <*> (o .:? "allow_rebase")
      <*> (o .:? "allow_rebase_explicit")
      <*> (o .:? "allow_rebase_update")
      <*> (o .:? "allow_squash_merge")
      <*> (o .:? "archived")
      <*> (o .:? "archived_at")
      <*> (o .:? "avatar_url")
      <*> (o .:? "clone_url")
      <*> (o .:? "created_at")
      <*> (o .:? "default_allow_maintainer_edit")
      <*> (o .:? "default_branch")
      <*> (o .:? "default_delete_branch_after_merge")
      <*> (o .:? "default_merge_style")
      <*> (o .:? "description")
      <*> (o .:? "empty")
      <*> (o .:? "external_tracker")
      <*> (o .:? "external_wiki")
      <*> (o .:? "fork")
      <*> (o .:? "forks_count")
      <*> (o .:? "full_name")
      <*> (o .:? "has_actions")
      <*> (o .:? "has_issues")
      <*> (o .:? "has_packages")
      <*> (o .:? "has_projects")
      <*> (o .:? "has_pull_requests")
      <*> (o .:? "has_releases")
      <*> (o .:? "has_wiki")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "ignore_whitespace_conflicts")
      <*> (o .:? "internal")
      <*> (o .:? "internal_tracker")
      <*> (o .:? "language")
      <*> (o .:? "languages_url")
      <*> (o .:? "link")
      <*> (o .:? "mirror")
      <*> (o .:? "mirror_interval")
      <*> (o .:? "mirror_updated")
      <*> (o .:? "name")
      <*> (o .:? "open_issues_count")
      <*> (o .:? "open_pr_counter")
      <*> (o .:? "original_url")
      <*> (o .:? "owner")
      <*> (o .:? "parent")
      <*> (o .:? "permissions")
      <*> (o .:? "private")
      <*> (o .:? "release_counter")
      <*> (o .:? "repo_transfer")
      <*> (o .:? "size")
      <*> (o .:? "ssh_url")
      <*> (o .:? "stars_count")
      <*> (o .:? "template")
      <*> (o .:? "updated_at")
      <*> (o .:? "url")
      <*> (o .:? "watchers_count")
      <*> (o .:? "website")

-- | ToJSON Repository
instance A.ToJSON Repository where
  toJSON Repository {..} =
   _omitNulls
      [ "allow_merge_commits" .= repositoryAllowMergeCommits
      , "allow_rebase" .= repositoryAllowRebase
      , "allow_rebase_explicit" .= repositoryAllowRebaseExplicit
      , "allow_rebase_update" .= repositoryAllowRebaseUpdate
      , "allow_squash_merge" .= repositoryAllowSquashMerge
      , "archived" .= repositoryArchived
      , "archived_at" .= repositoryArchivedAt
      , "avatar_url" .= repositoryAvatarUrl
      , "clone_url" .= repositoryCloneUrl
      , "created_at" .= repositoryCreatedAt
      , "default_allow_maintainer_edit" .= repositoryDefaultAllowMaintainerEdit
      , "default_branch" .= repositoryDefaultBranch
      , "default_delete_branch_after_merge" .= repositoryDefaultDeleteBranchAfterMerge
      , "default_merge_style" .= repositoryDefaultMergeStyle
      , "description" .= repositoryDescription
      , "empty" .= repositoryEmpty
      , "external_tracker" .= repositoryExternalTracker
      , "external_wiki" .= repositoryExternalWiki
      , "fork" .= repositoryFork
      , "forks_count" .= repositoryForksCount
      , "full_name" .= repositoryFullName
      , "has_actions" .= repositoryHasActions
      , "has_issues" .= repositoryHasIssues
      , "has_packages" .= repositoryHasPackages
      , "has_projects" .= repositoryHasProjects
      , "has_pull_requests" .= repositoryHasPullRequests
      , "has_releases" .= repositoryHasReleases
      , "has_wiki" .= repositoryHasWiki
      , "html_url" .= repositoryHtmlUrl
      , "id" .= repositoryId
      , "ignore_whitespace_conflicts" .= repositoryIgnoreWhitespaceConflicts
      , "internal" .= repositoryInternal
      , "internal_tracker" .= repositoryInternalTracker
      , "language" .= repositoryLanguage
      , "languages_url" .= repositoryLanguagesUrl
      , "link" .= repositoryLink
      , "mirror" .= repositoryMirror
      , "mirror_interval" .= repositoryMirrorInterval
      , "mirror_updated" .= repositoryMirrorUpdated
      , "name" .= repositoryName
      , "open_issues_count" .= repositoryOpenIssuesCount
      , "open_pr_counter" .= repositoryOpenPrCounter
      , "original_url" .= repositoryOriginalUrl
      , "owner" .= repositoryOwner
      , "parent" .= repositoryParent
      , "permissions" .= repositoryPermissions
      , "private" .= repositoryPrivate
      , "release_counter" .= repositoryReleaseCounter
      , "repo_transfer" .= repositoryRepoTransfer
      , "size" .= repositorySize
      , "ssh_url" .= repositorySshUrl
      , "stars_count" .= repositoryStarsCount
      , "template" .= repositoryTemplate
      , "updated_at" .= repositoryUpdatedAt
      , "url" .= repositoryUrl
      , "watchers_count" .= repositoryWatchersCount
      , "website" .= repositoryWebsite
      ]


-- | Construct a value of type 'Repository' (by applying it's required fields, if any)
mkRepository
  :: Repository
mkRepository =
  Repository
  { repositoryAllowMergeCommits = Nothing
  , repositoryAllowRebase = Nothing
  , repositoryAllowRebaseExplicit = Nothing
  , repositoryAllowRebaseUpdate = Nothing
  , repositoryAllowSquashMerge = Nothing
  , repositoryArchived = Nothing
  , repositoryArchivedAt = Nothing
  , repositoryAvatarUrl = Nothing
  , repositoryCloneUrl = Nothing
  , repositoryCreatedAt = Nothing
  , repositoryDefaultAllowMaintainerEdit = Nothing
  , repositoryDefaultBranch = Nothing
  , repositoryDefaultDeleteBranchAfterMerge = Nothing
  , repositoryDefaultMergeStyle = Nothing
  , repositoryDescription = Nothing
  , repositoryEmpty = Nothing
  , repositoryExternalTracker = Nothing
  , repositoryExternalWiki = Nothing
  , repositoryFork = Nothing
  , repositoryForksCount = Nothing
  , repositoryFullName = Nothing
  , repositoryHasActions = Nothing
  , repositoryHasIssues = Nothing
  , repositoryHasPackages = Nothing
  , repositoryHasProjects = Nothing
  , repositoryHasPullRequests = Nothing
  , repositoryHasReleases = Nothing
  , repositoryHasWiki = Nothing
  , repositoryHtmlUrl = Nothing
  , repositoryId = Nothing
  , repositoryIgnoreWhitespaceConflicts = Nothing
  , repositoryInternal = Nothing
  , repositoryInternalTracker = Nothing
  , repositoryLanguage = Nothing
  , repositoryLanguagesUrl = Nothing
  , repositoryLink = Nothing
  , repositoryMirror = Nothing
  , repositoryMirrorInterval = Nothing
  , repositoryMirrorUpdated = Nothing
  , repositoryName = Nothing
  , repositoryOpenIssuesCount = Nothing
  , repositoryOpenPrCounter = Nothing
  , repositoryOriginalUrl = Nothing
  , repositoryOwner = Nothing
  , repositoryParent = Nothing
  , repositoryPermissions = Nothing
  , repositoryPrivate = Nothing
  , repositoryReleaseCounter = Nothing
  , repositoryRepoTransfer = Nothing
  , repositorySize = Nothing
  , repositorySshUrl = Nothing
  , repositoryStarsCount = Nothing
  , repositoryTemplate = Nothing
  , repositoryUpdatedAt = Nothing
  , repositoryUrl = Nothing
  , repositoryWatchersCount = Nothing
  , repositoryWebsite = Nothing
  }

-- ** RepositoryMeta
-- | RepositoryMeta
-- RepositoryMeta basic repository information
data RepositoryMeta = RepositoryMeta
  { repositoryMetaFullName :: !(Maybe Text) -- ^ "full_name"
  , repositoryMetaId :: !(Maybe Integer) -- ^ "id"
  , repositoryMetaName :: !(Maybe Text) -- ^ "name"
  , repositoryMetaOwner :: !(Maybe Text) -- ^ "owner"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RepositoryMeta
instance A.FromJSON RepositoryMeta where
  parseJSON = A.withObject "RepositoryMeta" $ \o ->
    RepositoryMeta
      <$> (o .:? "full_name")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "owner")

-- | ToJSON RepositoryMeta
instance A.ToJSON RepositoryMeta where
  toJSON RepositoryMeta {..} =
   _omitNulls
      [ "full_name" .= repositoryMetaFullName
      , "id" .= repositoryMetaId
      , "name" .= repositoryMetaName
      , "owner" .= repositoryMetaOwner
      ]


-- | Construct a value of type 'RepositoryMeta' (by applying it's required fields, if any)
mkRepositoryMeta
  :: RepositoryMeta
mkRepositoryMeta =
  RepositoryMeta
  { repositoryMetaFullName = Nothing
  , repositoryMetaId = Nothing
  , repositoryMetaName = Nothing
  , repositoryMetaOwner = Nothing
  }

-- ** SearchResults
-- | SearchResults
-- SearchResults results of a successful search
data SearchResults = SearchResults
  { searchResultsData :: !(Maybe [Repository]) -- ^ "data"
  , searchResultsOk :: !(Maybe Bool) -- ^ "ok"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchResults
instance A.FromJSON SearchResults where
  parseJSON = A.withObject "SearchResults" $ \o ->
    SearchResults
      <$> (o .:? "data")
      <*> (o .:? "ok")

-- | ToJSON SearchResults
instance A.ToJSON SearchResults where
  toJSON SearchResults {..} =
   _omitNulls
      [ "data" .= searchResultsData
      , "ok" .= searchResultsOk
      ]


-- | Construct a value of type 'SearchResults' (by applying it's required fields, if any)
mkSearchResults
  :: SearchResults
mkSearchResults =
  SearchResults
  { searchResultsData = Nothing
  , searchResultsOk = Nothing
  }

-- ** ServerVersion
-- | ServerVersion
-- ServerVersion wraps the version of the server
data ServerVersion = ServerVersion
  { serverVersionVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServerVersion
instance A.FromJSON ServerVersion where
  parseJSON = A.withObject "ServerVersion" $ \o ->
    ServerVersion
      <$> (o .:? "version")

-- | ToJSON ServerVersion
instance A.ToJSON ServerVersion where
  toJSON ServerVersion {..} =
   _omitNulls
      [ "version" .= serverVersionVersion
      ]


-- | Construct a value of type 'ServerVersion' (by applying it's required fields, if any)
mkServerVersion
  :: ServerVersion
mkServerVersion =
  ServerVersion
  { serverVersionVersion = Nothing
  }

-- ** StopWatch
-- | StopWatch
-- StopWatch represent a running stopwatch
data StopWatch = StopWatch
  { stopWatchCreated :: !(Maybe DateTime) -- ^ "created"
  , stopWatchDuration :: !(Maybe Text) -- ^ "duration"
  , stopWatchIssueIndex :: !(Maybe Integer) -- ^ "issue_index"
  , stopWatchIssueTitle :: !(Maybe Text) -- ^ "issue_title"
  , stopWatchRepoName :: !(Maybe Text) -- ^ "repo_name"
  , stopWatchRepoOwnerName :: !(Maybe Text) -- ^ "repo_owner_name"
  , stopWatchSeconds :: !(Maybe Integer) -- ^ "seconds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StopWatch
instance A.FromJSON StopWatch where
  parseJSON = A.withObject "StopWatch" $ \o ->
    StopWatch
      <$> (o .:? "created")
      <*> (o .:? "duration")
      <*> (o .:? "issue_index")
      <*> (o .:? "issue_title")
      <*> (o .:? "repo_name")
      <*> (o .:? "repo_owner_name")
      <*> (o .:? "seconds")

-- | ToJSON StopWatch
instance A.ToJSON StopWatch where
  toJSON StopWatch {..} =
   _omitNulls
      [ "created" .= stopWatchCreated
      , "duration" .= stopWatchDuration
      , "issue_index" .= stopWatchIssueIndex
      , "issue_title" .= stopWatchIssueTitle
      , "repo_name" .= stopWatchRepoName
      , "repo_owner_name" .= stopWatchRepoOwnerName
      , "seconds" .= stopWatchSeconds
      ]


-- | Construct a value of type 'StopWatch' (by applying it's required fields, if any)
mkStopWatch
  :: StopWatch
mkStopWatch =
  StopWatch
  { stopWatchCreated = Nothing
  , stopWatchDuration = Nothing
  , stopWatchIssueIndex = Nothing
  , stopWatchIssueTitle = Nothing
  , stopWatchRepoName = Nothing
  , stopWatchRepoOwnerName = Nothing
  , stopWatchSeconds = Nothing
  }

-- ** SubmitPullReviewOptions
-- | SubmitPullReviewOptions
-- SubmitPullReviewOptions are options to submit a pending pull review
data SubmitPullReviewOptions = SubmitPullReviewOptions
  { submitPullReviewOptionsBody :: !(Maybe Text) -- ^ "body"
  , submitPullReviewOptionsEvent :: !(Maybe Text) -- ^ "event" - ReviewStateType review state type
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubmitPullReviewOptions
instance A.FromJSON SubmitPullReviewOptions where
  parseJSON = A.withObject "SubmitPullReviewOptions" $ \o ->
    SubmitPullReviewOptions
      <$> (o .:? "body")
      <*> (o .:? "event")

-- | ToJSON SubmitPullReviewOptions
instance A.ToJSON SubmitPullReviewOptions where
  toJSON SubmitPullReviewOptions {..} =
   _omitNulls
      [ "body" .= submitPullReviewOptionsBody
      , "event" .= submitPullReviewOptionsEvent
      ]


-- | Construct a value of type 'SubmitPullReviewOptions' (by applying it's required fields, if any)
mkSubmitPullReviewOptions
  :: SubmitPullReviewOptions
mkSubmitPullReviewOptions =
  SubmitPullReviewOptions
  { submitPullReviewOptionsBody = Nothing
  , submitPullReviewOptionsEvent = Nothing
  }

-- ** Tag
-- | Tag
-- Tag represents a repository tag
data Tag = Tag
  { tagCommit :: !(Maybe CommitMeta) -- ^ "commit"
  , tagId :: !(Maybe Text) -- ^ "id"
  , tagMessage :: !(Maybe Text) -- ^ "message"
  , tagName :: !(Maybe Text) -- ^ "name"
  , tagTarballUrl :: !(Maybe Text) -- ^ "tarball_url"
  , tagZipballUrl :: !(Maybe Text) -- ^ "zipball_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Tag
instance A.FromJSON Tag where
  parseJSON = A.withObject "Tag" $ \o ->
    Tag
      <$> (o .:? "commit")
      <*> (o .:? "id")
      <*> (o .:? "message")
      <*> (o .:? "name")
      <*> (o .:? "tarball_url")
      <*> (o .:? "zipball_url")

-- | ToJSON Tag
instance A.ToJSON Tag where
  toJSON Tag {..} =
   _omitNulls
      [ "commit" .= tagCommit
      , "id" .= tagId
      , "message" .= tagMessage
      , "name" .= tagName
      , "tarball_url" .= tagTarballUrl
      , "zipball_url" .= tagZipballUrl
      ]


-- | Construct a value of type 'Tag' (by applying it's required fields, if any)
mkTag
  :: Tag
mkTag =
  Tag
  { tagCommit = Nothing
  , tagId = Nothing
  , tagMessage = Nothing
  , tagName = Nothing
  , tagTarballUrl = Nothing
  , tagZipballUrl = Nothing
  }

-- ** Team
-- | Team
-- Team represents a team in an organization
data Team = Team
  { teamCanCreateOrgRepo :: !(Maybe Bool) -- ^ "can_create_org_repo"
  , teamDescription :: !(Maybe Text) -- ^ "description"
  , teamId :: !(Maybe Integer) -- ^ "id"
  , teamIncludesAllRepositories :: !(Maybe Bool) -- ^ "includes_all_repositories"
  , teamName :: !(Maybe Text) -- ^ "name"
  , teamOrganization :: !(Maybe Organization) -- ^ "organization"
  , teamPermission :: !(Maybe E'Permission2) -- ^ "permission"
  , teamUnits :: !(Maybe [Text]) -- ^ "units"
  , teamUnitsMap :: !(Maybe (Map.Map String Text)) -- ^ "units_map"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Team
instance A.FromJSON Team where
  parseJSON = A.withObject "Team" $ \o ->
    Team
      <$> (o .:? "can_create_org_repo")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "includes_all_repositories")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "permission")
      <*> (o .:? "units")
      <*> (o .:? "units_map")

-- | ToJSON Team
instance A.ToJSON Team where
  toJSON Team {..} =
   _omitNulls
      [ "can_create_org_repo" .= teamCanCreateOrgRepo
      , "description" .= teamDescription
      , "id" .= teamId
      , "includes_all_repositories" .= teamIncludesAllRepositories
      , "name" .= teamName
      , "organization" .= teamOrganization
      , "permission" .= teamPermission
      , "units" .= teamUnits
      , "units_map" .= teamUnitsMap
      ]


-- | Construct a value of type 'Team' (by applying it's required fields, if any)
mkTeam
  :: Team
mkTeam =
  Team
  { teamCanCreateOrgRepo = Nothing
  , teamDescription = Nothing
  , teamId = Nothing
  , teamIncludesAllRepositories = Nothing
  , teamName = Nothing
  , teamOrganization = Nothing
  , teamPermission = Nothing
  , teamUnits = Nothing
  , teamUnitsMap = Nothing
  }

-- ** TeamSearch200Response
-- | TeamSearch200Response
data TeamSearch200Response = TeamSearch200Response
  { teamSearch200ResponseData :: !(Maybe [Team]) -- ^ "data"
  , teamSearch200ResponseOk :: !(Maybe Bool) -- ^ "ok"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TeamSearch200Response
instance A.FromJSON TeamSearch200Response where
  parseJSON = A.withObject "TeamSearch200Response" $ \o ->
    TeamSearch200Response
      <$> (o .:? "data")
      <*> (o .:? "ok")

-- | ToJSON TeamSearch200Response
instance A.ToJSON TeamSearch200Response where
  toJSON TeamSearch200Response {..} =
   _omitNulls
      [ "data" .= teamSearch200ResponseData
      , "ok" .= teamSearch200ResponseOk
      ]


-- | Construct a value of type 'TeamSearch200Response' (by applying it's required fields, if any)
mkTeamSearch200Response
  :: TeamSearch200Response
mkTeamSearch200Response =
  TeamSearch200Response
  { teamSearch200ResponseData = Nothing
  , teamSearch200ResponseOk = Nothing
  }

-- ** TimelineComment
-- | TimelineComment
-- TimelineComment represents a timeline comment (comment of any type) on a commit or issue
data TimelineComment = TimelineComment
  { timelineCommentAssignee :: !(Maybe User) -- ^ "assignee"
  , timelineCommentAssigneeTeam :: !(Maybe Team) -- ^ "assignee_team"
  , timelineCommentBody :: !(Maybe Text) -- ^ "body"
  , timelineCommentCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , timelineCommentDependentIssue :: !(Maybe Issue) -- ^ "dependent_issue"
  , timelineCommentHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , timelineCommentId :: !(Maybe Integer) -- ^ "id"
  , timelineCommentIssueUrl :: !(Maybe Text) -- ^ "issue_url"
  , timelineCommentLabel :: !(Maybe Label) -- ^ "label"
  , timelineCommentMilestone :: !(Maybe Milestone) -- ^ "milestone"
  , timelineCommentNewRef :: !(Maybe Text) -- ^ "new_ref"
  , timelineCommentNewTitle :: !(Maybe Text) -- ^ "new_title"
  , timelineCommentOldMilestone :: !(Maybe Milestone) -- ^ "old_milestone"
  , timelineCommentOldProjectId :: !(Maybe Integer) -- ^ "old_project_id"
  , timelineCommentOldRef :: !(Maybe Text) -- ^ "old_ref"
  , timelineCommentOldTitle :: !(Maybe Text) -- ^ "old_title"
  , timelineCommentProjectId :: !(Maybe Integer) -- ^ "project_id"
  , timelineCommentPullRequestUrl :: !(Maybe Text) -- ^ "pull_request_url"
  , timelineCommentRefAction :: !(Maybe Text) -- ^ "ref_action"
  , timelineCommentRefComment :: !(Maybe Comment) -- ^ "ref_comment"
  , timelineCommentRefCommitSha :: !(Maybe Text) -- ^ "ref_commit_sha" - commit SHA where issue/PR was referenced
  , timelineCommentRefIssue :: !(Maybe Issue) -- ^ "ref_issue"
  , timelineCommentRemovedAssignee :: !(Maybe Bool) -- ^ "removed_assignee" - whether the assignees were removed or added
  , timelineCommentResolveDoer :: !(Maybe User) -- ^ "resolve_doer"
  , timelineCommentReviewId :: !(Maybe Integer) -- ^ "review_id"
  , timelineCommentTrackedTime :: !(Maybe TrackedTime) -- ^ "tracked_time"
  , timelineCommentType :: !(Maybe Text) -- ^ "type"
  , timelineCommentUpdatedAt :: !(Maybe DateTime) -- ^ "updated_at"
  , timelineCommentUser :: !(Maybe User) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TimelineComment
instance A.FromJSON TimelineComment where
  parseJSON = A.withObject "TimelineComment" $ \o ->
    TimelineComment
      <$> (o .:? "assignee")
      <*> (o .:? "assignee_team")
      <*> (o .:? "body")
      <*> (o .:? "created_at")
      <*> (o .:? "dependent_issue")
      <*> (o .:? "html_url")
      <*> (o .:? "id")
      <*> (o .:? "issue_url")
      <*> (o .:? "label")
      <*> (o .:? "milestone")
      <*> (o .:? "new_ref")
      <*> (o .:? "new_title")
      <*> (o .:? "old_milestone")
      <*> (o .:? "old_project_id")
      <*> (o .:? "old_ref")
      <*> (o .:? "old_title")
      <*> (o .:? "project_id")
      <*> (o .:? "pull_request_url")
      <*> (o .:? "ref_action")
      <*> (o .:? "ref_comment")
      <*> (o .:? "ref_commit_sha")
      <*> (o .:? "ref_issue")
      <*> (o .:? "removed_assignee")
      <*> (o .:? "resolve_doer")
      <*> (o .:? "review_id")
      <*> (o .:? "tracked_time")
      <*> (o .:? "type")
      <*> (o .:? "updated_at")
      <*> (o .:? "user")

-- | ToJSON TimelineComment
instance A.ToJSON TimelineComment where
  toJSON TimelineComment {..} =
   _omitNulls
      [ "assignee" .= timelineCommentAssignee
      , "assignee_team" .= timelineCommentAssigneeTeam
      , "body" .= timelineCommentBody
      , "created_at" .= timelineCommentCreatedAt
      , "dependent_issue" .= timelineCommentDependentIssue
      , "html_url" .= timelineCommentHtmlUrl
      , "id" .= timelineCommentId
      , "issue_url" .= timelineCommentIssueUrl
      , "label" .= timelineCommentLabel
      , "milestone" .= timelineCommentMilestone
      , "new_ref" .= timelineCommentNewRef
      , "new_title" .= timelineCommentNewTitle
      , "old_milestone" .= timelineCommentOldMilestone
      , "old_project_id" .= timelineCommentOldProjectId
      , "old_ref" .= timelineCommentOldRef
      , "old_title" .= timelineCommentOldTitle
      , "project_id" .= timelineCommentProjectId
      , "pull_request_url" .= timelineCommentPullRequestUrl
      , "ref_action" .= timelineCommentRefAction
      , "ref_comment" .= timelineCommentRefComment
      , "ref_commit_sha" .= timelineCommentRefCommitSha
      , "ref_issue" .= timelineCommentRefIssue
      , "removed_assignee" .= timelineCommentRemovedAssignee
      , "resolve_doer" .= timelineCommentResolveDoer
      , "review_id" .= timelineCommentReviewId
      , "tracked_time" .= timelineCommentTrackedTime
      , "type" .= timelineCommentType
      , "updated_at" .= timelineCommentUpdatedAt
      , "user" .= timelineCommentUser
      ]


-- | Construct a value of type 'TimelineComment' (by applying it's required fields, if any)
mkTimelineComment
  :: TimelineComment
mkTimelineComment =
  TimelineComment
  { timelineCommentAssignee = Nothing
  , timelineCommentAssigneeTeam = Nothing
  , timelineCommentBody = Nothing
  , timelineCommentCreatedAt = Nothing
  , timelineCommentDependentIssue = Nothing
  , timelineCommentHtmlUrl = Nothing
  , timelineCommentId = Nothing
  , timelineCommentIssueUrl = Nothing
  , timelineCommentLabel = Nothing
  , timelineCommentMilestone = Nothing
  , timelineCommentNewRef = Nothing
  , timelineCommentNewTitle = Nothing
  , timelineCommentOldMilestone = Nothing
  , timelineCommentOldProjectId = Nothing
  , timelineCommentOldRef = Nothing
  , timelineCommentOldTitle = Nothing
  , timelineCommentProjectId = Nothing
  , timelineCommentPullRequestUrl = Nothing
  , timelineCommentRefAction = Nothing
  , timelineCommentRefComment = Nothing
  , timelineCommentRefCommitSha = Nothing
  , timelineCommentRefIssue = Nothing
  , timelineCommentRemovedAssignee = Nothing
  , timelineCommentResolveDoer = Nothing
  , timelineCommentReviewId = Nothing
  , timelineCommentTrackedTime = Nothing
  , timelineCommentType = Nothing
  , timelineCommentUpdatedAt = Nothing
  , timelineCommentUser = Nothing
  }

-- ** TopicName
-- | TopicName
-- TopicName a list of repo topic names
data TopicName = TopicName
  { topicNameTopics :: !(Maybe [Text]) -- ^ "topics"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopicName
instance A.FromJSON TopicName where
  parseJSON = A.withObject "TopicName" $ \o ->
    TopicName
      <$> (o .:? "topics")

-- | ToJSON TopicName
instance A.ToJSON TopicName where
  toJSON TopicName {..} =
   _omitNulls
      [ "topics" .= topicNameTopics
      ]


-- | Construct a value of type 'TopicName' (by applying it's required fields, if any)
mkTopicName
  :: TopicName
mkTopicName =
  TopicName
  { topicNameTopics = Nothing
  }

-- ** TopicResponse
-- | TopicResponse
-- TopicResponse for returning topics
data TopicResponse = TopicResponse
  { topicResponseCreated :: !(Maybe DateTime) -- ^ "created"
  , topicResponseId :: !(Maybe Integer) -- ^ "id"
  , topicResponseRepoCount :: !(Maybe Integer) -- ^ "repo_count"
  , topicResponseTopicName :: !(Maybe Text) -- ^ "topic_name"
  , topicResponseUpdated :: !(Maybe DateTime) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopicResponse
instance A.FromJSON TopicResponse where
  parseJSON = A.withObject "TopicResponse" $ \o ->
    TopicResponse
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "repo_count")
      <*> (o .:? "topic_name")
      <*> (o .:? "updated")

-- | ToJSON TopicResponse
instance A.ToJSON TopicResponse where
  toJSON TopicResponse {..} =
   _omitNulls
      [ "created" .= topicResponseCreated
      , "id" .= topicResponseId
      , "repo_count" .= topicResponseRepoCount
      , "topic_name" .= topicResponseTopicName
      , "updated" .= topicResponseUpdated
      ]


-- | Construct a value of type 'TopicResponse' (by applying it's required fields, if any)
mkTopicResponse
  :: TopicResponse
mkTopicResponse =
  TopicResponse
  { topicResponseCreated = Nothing
  , topicResponseId = Nothing
  , topicResponseRepoCount = Nothing
  , topicResponseTopicName = Nothing
  , topicResponseUpdated = Nothing
  }

-- ** TrackedTime
-- | TrackedTime
-- TrackedTime worked time for an issue / pr
data TrackedTime = TrackedTime
  { trackedTimeCreated :: !(Maybe DateTime) -- ^ "created"
  , trackedTimeId :: !(Maybe Integer) -- ^ "id"
  , trackedTimeIssue :: !(Maybe Issue) -- ^ "issue"
  , trackedTimeIssueId :: !(Maybe Integer) -- ^ "issue_id" - deprecated (only for backwards compatibility)
  , trackedTimeTime :: !(Maybe Integer) -- ^ "time" - Time in seconds
  , trackedTimeUserId :: !(Maybe Integer) -- ^ "user_id" - deprecated (only for backwards compatibility)
  , trackedTimeUserName :: !(Maybe Text) -- ^ "user_name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrackedTime
instance A.FromJSON TrackedTime where
  parseJSON = A.withObject "TrackedTime" $ \o ->
    TrackedTime
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "issue")
      <*> (o .:? "issue_id")
      <*> (o .:? "time")
      <*> (o .:? "user_id")
      <*> (o .:? "user_name")

-- | ToJSON TrackedTime
instance A.ToJSON TrackedTime where
  toJSON TrackedTime {..} =
   _omitNulls
      [ "created" .= trackedTimeCreated
      , "id" .= trackedTimeId
      , "issue" .= trackedTimeIssue
      , "issue_id" .= trackedTimeIssueId
      , "time" .= trackedTimeTime
      , "user_id" .= trackedTimeUserId
      , "user_name" .= trackedTimeUserName
      ]


-- | Construct a value of type 'TrackedTime' (by applying it's required fields, if any)
mkTrackedTime
  :: TrackedTime
mkTrackedTime =
  TrackedTime
  { trackedTimeCreated = Nothing
  , trackedTimeId = Nothing
  , trackedTimeIssue = Nothing
  , trackedTimeIssueId = Nothing
  , trackedTimeTime = Nothing
  , trackedTimeUserId = Nothing
  , trackedTimeUserName = Nothing
  }

-- ** TransferRepoOption
-- | TransferRepoOption
-- TransferRepoOption options when transfer a repository's ownership
data TransferRepoOption = TransferRepoOption
  { transferRepoOptionNewOwner :: !(Text) -- ^ /Required/ "new_owner"
  , transferRepoOptionTeamIds :: !(Maybe [Integer]) -- ^ "team_ids" - ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferRepoOption
instance A.FromJSON TransferRepoOption where
  parseJSON = A.withObject "TransferRepoOption" $ \o ->
    TransferRepoOption
      <$> (o .:  "new_owner")
      <*> (o .:? "team_ids")

-- | ToJSON TransferRepoOption
instance A.ToJSON TransferRepoOption where
  toJSON TransferRepoOption {..} =
   _omitNulls
      [ "new_owner" .= transferRepoOptionNewOwner
      , "team_ids" .= transferRepoOptionTeamIds
      ]


-- | Construct a value of type 'TransferRepoOption' (by applying it's required fields, if any)
mkTransferRepoOption
  :: Text -- ^ 'transferRepoOptionNewOwner' 
  -> TransferRepoOption
mkTransferRepoOption transferRepoOptionNewOwner =
  TransferRepoOption
  { transferRepoOptionNewOwner
  , transferRepoOptionTeamIds = Nothing
  }

-- ** UpdateFileOptions
-- | UpdateFileOptions
-- UpdateFileOptions options for updating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
data UpdateFileOptions = UpdateFileOptions
  { updateFileOptionsAuthor :: !(Maybe Identity) -- ^ "author"
  , updateFileOptionsBranch :: !(Maybe Text) -- ^ "branch" - branch (optional) to base this file from. if not given, the default branch is used
  , updateFileOptionsCommitter :: !(Maybe Identity) -- ^ "committer"
  , updateFileOptionsContent :: !(Text) -- ^ /Required/ "content" - content must be base64 encoded
  , updateFileOptionsDates :: !(Maybe CommitDateOptions) -- ^ "dates"
  , updateFileOptionsFromPath :: !(Maybe Text) -- ^ "from_path" - from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
  , updateFileOptionsMessage :: !(Maybe Text) -- ^ "message" - message (optional) for the commit of this file. if not supplied, a default message will be used
  , updateFileOptionsNewBranch :: !(Maybe Text) -- ^ "new_branch" - new_branch (optional) will make a new branch from &#x60;branch&#x60; before creating the file
  , updateFileOptionsSha :: !(Text) -- ^ /Required/ "sha" - sha is the SHA for the file that already exists
  , updateFileOptionsSignoff :: !(Maybe Bool) -- ^ "signoff" - Add a Signed-off-by trailer by the committer at the end of the commit log message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateFileOptions
instance A.FromJSON UpdateFileOptions where
  parseJSON = A.withObject "UpdateFileOptions" $ \o ->
    UpdateFileOptions
      <$> (o .:? "author")
      <*> (o .:? "branch")
      <*> (o .:? "committer")
      <*> (o .:  "content")
      <*> (o .:? "dates")
      <*> (o .:? "from_path")
      <*> (o .:? "message")
      <*> (o .:? "new_branch")
      <*> (o .:  "sha")
      <*> (o .:? "signoff")

-- | ToJSON UpdateFileOptions
instance A.ToJSON UpdateFileOptions where
  toJSON UpdateFileOptions {..} =
   _omitNulls
      [ "author" .= updateFileOptionsAuthor
      , "branch" .= updateFileOptionsBranch
      , "committer" .= updateFileOptionsCommitter
      , "content" .= updateFileOptionsContent
      , "dates" .= updateFileOptionsDates
      , "from_path" .= updateFileOptionsFromPath
      , "message" .= updateFileOptionsMessage
      , "new_branch" .= updateFileOptionsNewBranch
      , "sha" .= updateFileOptionsSha
      , "signoff" .= updateFileOptionsSignoff
      ]


-- | Construct a value of type 'UpdateFileOptions' (by applying it's required fields, if any)
mkUpdateFileOptions
  :: Text -- ^ 'updateFileOptionsContent': content must be base64 encoded
  -> Text -- ^ 'updateFileOptionsSha': sha is the SHA for the file that already exists
  -> UpdateFileOptions
mkUpdateFileOptions updateFileOptionsContent updateFileOptionsSha =
  UpdateFileOptions
  { updateFileOptionsAuthor = Nothing
  , updateFileOptionsBranch = Nothing
  , updateFileOptionsCommitter = Nothing
  , updateFileOptionsContent
  , updateFileOptionsDates = Nothing
  , updateFileOptionsFromPath = Nothing
  , updateFileOptionsMessage = Nothing
  , updateFileOptionsNewBranch = Nothing
  , updateFileOptionsSha
  , updateFileOptionsSignoff = Nothing
  }

-- ** User
-- | User
-- User represents a user
data User = User
  { userActive :: !(Maybe Bool) -- ^ "active" - Is user active
  , userAvatarUrl :: !(Maybe Text) -- ^ "avatar_url" - URL to the user&#39;s avatar
  , userCreated :: !(Maybe DateTime) -- ^ "created"
  , userDescription :: !(Maybe Text) -- ^ "description" - the user&#39;s description
  , userEmail :: !(Maybe Text) -- ^ "email"
  , userFollowersCount :: !(Maybe Integer) -- ^ "followers_count" - user counts
  , userFollowingCount :: !(Maybe Integer) -- ^ "following_count"
  , userFullName :: !(Maybe Text) -- ^ "full_name" - the user&#39;s full name
  , userId :: !(Maybe Integer) -- ^ "id" - the user&#39;s id
  , userIsAdmin :: !(Maybe Bool) -- ^ "is_admin" - Is the user an administrator
  , userLanguage :: !(Maybe Text) -- ^ "language" - User locale
  , userLastLogin :: !(Maybe DateTime) -- ^ "last_login"
  , userLocation :: !(Maybe Text) -- ^ "location" - the user&#39;s location
  , userLogin :: !(Maybe Text) -- ^ "login" - the user&#39;s username
  , userLoginName :: !(Maybe Text) -- ^ "login_name" - the user&#39;s authentication sign-in name.
  , userProhibitLogin :: !(Maybe Bool) -- ^ "prohibit_login" - Is user login prohibited
  , userRestricted :: !(Maybe Bool) -- ^ "restricted" - Is user restricted
  , userStarredReposCount :: !(Maybe Integer) -- ^ "starred_repos_count"
  , userVisibility :: !(Maybe Text) -- ^ "visibility" - User visibility level option: public, limited, private
  , userWebsite :: !(Maybe Text) -- ^ "website" - the user&#39;s website
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "active")
      <*> (o .:? "avatar_url")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "email")
      <*> (o .:? "followers_count")
      <*> (o .:? "following_count")
      <*> (o .:? "full_name")
      <*> (o .:? "id")
      <*> (o .:? "is_admin")
      <*> (o .:? "language")
      <*> (o .:? "last_login")
      <*> (o .:? "location")
      <*> (o .:? "login")
      <*> (o .:? "login_name")
      <*> (o .:? "prohibit_login")
      <*> (o .:? "restricted")
      <*> (o .:? "starred_repos_count")
      <*> (o .:? "visibility")
      <*> (o .:? "website")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "active" .= userActive
      , "avatar_url" .= userAvatarUrl
      , "created" .= userCreated
      , "description" .= userDescription
      , "email" .= userEmail
      , "followers_count" .= userFollowersCount
      , "following_count" .= userFollowingCount
      , "full_name" .= userFullName
      , "id" .= userId
      , "is_admin" .= userIsAdmin
      , "language" .= userLanguage
      , "last_login" .= userLastLogin
      , "location" .= userLocation
      , "login" .= userLogin
      , "login_name" .= userLoginName
      , "prohibit_login" .= userProhibitLogin
      , "restricted" .= userRestricted
      , "starred_repos_count" .= userStarredReposCount
      , "visibility" .= userVisibility
      , "website" .= userWebsite
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userActive = Nothing
  , userAvatarUrl = Nothing
  , userCreated = Nothing
  , userDescription = Nothing
  , userEmail = Nothing
  , userFollowersCount = Nothing
  , userFollowingCount = Nothing
  , userFullName = Nothing
  , userId = Nothing
  , userIsAdmin = Nothing
  , userLanguage = Nothing
  , userLastLogin = Nothing
  , userLocation = Nothing
  , userLogin = Nothing
  , userLoginName = Nothing
  , userProhibitLogin = Nothing
  , userRestricted = Nothing
  , userStarredReposCount = Nothing
  , userVisibility = Nothing
  , userWebsite = Nothing
  }

-- ** UserHeatmapData
-- | UserHeatmapData
-- UserHeatmapData represents the data needed to create a heatmap
data UserHeatmapData = UserHeatmapData
  { userHeatmapDataContributions :: !(Maybe Integer) -- ^ "contributions"
  , userHeatmapDataTimestamp :: !(Maybe Integer) -- ^ "timestamp" - TimeStamp defines a timestamp
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserHeatmapData
instance A.FromJSON UserHeatmapData where
  parseJSON = A.withObject "UserHeatmapData" $ \o ->
    UserHeatmapData
      <$> (o .:? "contributions")
      <*> (o .:? "timestamp")

-- | ToJSON UserHeatmapData
instance A.ToJSON UserHeatmapData where
  toJSON UserHeatmapData {..} =
   _omitNulls
      [ "contributions" .= userHeatmapDataContributions
      , "timestamp" .= userHeatmapDataTimestamp
      ]


-- | Construct a value of type 'UserHeatmapData' (by applying it's required fields, if any)
mkUserHeatmapData
  :: UserHeatmapData
mkUserHeatmapData =
  UserHeatmapData
  { userHeatmapDataContributions = Nothing
  , userHeatmapDataTimestamp = Nothing
  }

-- ** UserSearch200Response
-- | UserSearch200Response
data UserSearch200Response = UserSearch200Response
  { userSearch200ResponseData :: !(Maybe [User]) -- ^ "data"
  , userSearch200ResponseOk :: !(Maybe Bool) -- ^ "ok"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSearch200Response
instance A.FromJSON UserSearch200Response where
  parseJSON = A.withObject "UserSearch200Response" $ \o ->
    UserSearch200Response
      <$> (o .:? "data")
      <*> (o .:? "ok")

-- | ToJSON UserSearch200Response
instance A.ToJSON UserSearch200Response where
  toJSON UserSearch200Response {..} =
   _omitNulls
      [ "data" .= userSearch200ResponseData
      , "ok" .= userSearch200ResponseOk
      ]


-- | Construct a value of type 'UserSearch200Response' (by applying it's required fields, if any)
mkUserSearch200Response
  :: UserSearch200Response
mkUserSearch200Response =
  UserSearch200Response
  { userSearch200ResponseData = Nothing
  , userSearch200ResponseOk = Nothing
  }

-- ** UserSettings
-- | UserSettings
-- UserSettings represents user settings
data UserSettings = UserSettings
  { userSettingsDescription :: !(Maybe Text) -- ^ "description"
  , userSettingsDiffViewStyle :: !(Maybe Text) -- ^ "diff_view_style"
  , userSettingsFullName :: !(Maybe Text) -- ^ "full_name"
  , userSettingsHideActivity :: !(Maybe Bool) -- ^ "hide_activity"
  , userSettingsHideEmail :: !(Maybe Bool) -- ^ "hide_email" - Privacy
  , userSettingsLanguage :: !(Maybe Text) -- ^ "language"
  , userSettingsLocation :: !(Maybe Text) -- ^ "location"
  , userSettingsTheme :: !(Maybe Text) -- ^ "theme"
  , userSettingsWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSettings
instance A.FromJSON UserSettings where
  parseJSON = A.withObject "UserSettings" $ \o ->
    UserSettings
      <$> (o .:? "description")
      <*> (o .:? "diff_view_style")
      <*> (o .:? "full_name")
      <*> (o .:? "hide_activity")
      <*> (o .:? "hide_email")
      <*> (o .:? "language")
      <*> (o .:? "location")
      <*> (o .:? "theme")
      <*> (o .:? "website")

-- | ToJSON UserSettings
instance A.ToJSON UserSettings where
  toJSON UserSettings {..} =
   _omitNulls
      [ "description" .= userSettingsDescription
      , "diff_view_style" .= userSettingsDiffViewStyle
      , "full_name" .= userSettingsFullName
      , "hide_activity" .= userSettingsHideActivity
      , "hide_email" .= userSettingsHideEmail
      , "language" .= userSettingsLanguage
      , "location" .= userSettingsLocation
      , "theme" .= userSettingsTheme
      , "website" .= userSettingsWebsite
      ]


-- | Construct a value of type 'UserSettings' (by applying it's required fields, if any)
mkUserSettings
  :: UserSettings
mkUserSettings =
  UserSettings
  { userSettingsDescription = Nothing
  , userSettingsDiffViewStyle = Nothing
  , userSettingsFullName = Nothing
  , userSettingsHideActivity = Nothing
  , userSettingsHideEmail = Nothing
  , userSettingsLanguage = Nothing
  , userSettingsLocation = Nothing
  , userSettingsTheme = Nothing
  , userSettingsWebsite = Nothing
  }

-- ** UserSettingsOptions
-- | UserSettingsOptions
-- UserSettingsOptions represents options to change user settings
data UserSettingsOptions = UserSettingsOptions
  { userSettingsOptionsDescription :: !(Maybe Text) -- ^ "description"
  , userSettingsOptionsDiffViewStyle :: !(Maybe Text) -- ^ "diff_view_style"
  , userSettingsOptionsFullName :: !(Maybe Text) -- ^ "full_name"
  , userSettingsOptionsHideActivity :: !(Maybe Bool) -- ^ "hide_activity"
  , userSettingsOptionsHideEmail :: !(Maybe Bool) -- ^ "hide_email" - Privacy
  , userSettingsOptionsLanguage :: !(Maybe Text) -- ^ "language"
  , userSettingsOptionsLocation :: !(Maybe Text) -- ^ "location"
  , userSettingsOptionsTheme :: !(Maybe Text) -- ^ "theme"
  , userSettingsOptionsWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSettingsOptions
instance A.FromJSON UserSettingsOptions where
  parseJSON = A.withObject "UserSettingsOptions" $ \o ->
    UserSettingsOptions
      <$> (o .:? "description")
      <*> (o .:? "diff_view_style")
      <*> (o .:? "full_name")
      <*> (o .:? "hide_activity")
      <*> (o .:? "hide_email")
      <*> (o .:? "language")
      <*> (o .:? "location")
      <*> (o .:? "theme")
      <*> (o .:? "website")

-- | ToJSON UserSettingsOptions
instance A.ToJSON UserSettingsOptions where
  toJSON UserSettingsOptions {..} =
   _omitNulls
      [ "description" .= userSettingsOptionsDescription
      , "diff_view_style" .= userSettingsOptionsDiffViewStyle
      , "full_name" .= userSettingsOptionsFullName
      , "hide_activity" .= userSettingsOptionsHideActivity
      , "hide_email" .= userSettingsOptionsHideEmail
      , "language" .= userSettingsOptionsLanguage
      , "location" .= userSettingsOptionsLocation
      , "theme" .= userSettingsOptionsTheme
      , "website" .= userSettingsOptionsWebsite
      ]


-- | Construct a value of type 'UserSettingsOptions' (by applying it's required fields, if any)
mkUserSettingsOptions
  :: UserSettingsOptions
mkUserSettingsOptions =
  UserSettingsOptions
  { userSettingsOptionsDescription = Nothing
  , userSettingsOptionsDiffViewStyle = Nothing
  , userSettingsOptionsFullName = Nothing
  , userSettingsOptionsHideActivity = Nothing
  , userSettingsOptionsHideEmail = Nothing
  , userSettingsOptionsLanguage = Nothing
  , userSettingsOptionsLocation = Nothing
  , userSettingsOptionsTheme = Nothing
  , userSettingsOptionsWebsite = Nothing
  }

-- ** WatchInfo
-- | WatchInfo
-- WatchInfo represents an API watch status of one repository
data WatchInfo = WatchInfo
  { watchInfoCreatedAt :: !(Maybe DateTime) -- ^ "created_at"
  , watchInfoIgnored :: !(Maybe Bool) -- ^ "ignored"
  , watchInfoReason :: !(Maybe A.Value) -- ^ "reason"
  , watchInfoRepositoryUrl :: !(Maybe Text) -- ^ "repository_url"
  , watchInfoSubscribed :: !(Maybe Bool) -- ^ "subscribed"
  , watchInfoUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WatchInfo
instance A.FromJSON WatchInfo where
  parseJSON = A.withObject "WatchInfo" $ \o ->
    WatchInfo
      <$> (o .:? "created_at")
      <*> (o .:? "ignored")
      <*> (o .:? "reason")
      <*> (o .:? "repository_url")
      <*> (o .:? "subscribed")
      <*> (o .:? "url")

-- | ToJSON WatchInfo
instance A.ToJSON WatchInfo where
  toJSON WatchInfo {..} =
   _omitNulls
      [ "created_at" .= watchInfoCreatedAt
      , "ignored" .= watchInfoIgnored
      , "reason" .= watchInfoReason
      , "repository_url" .= watchInfoRepositoryUrl
      , "subscribed" .= watchInfoSubscribed
      , "url" .= watchInfoUrl
      ]


-- | Construct a value of type 'WatchInfo' (by applying it's required fields, if any)
mkWatchInfo
  :: WatchInfo
mkWatchInfo =
  WatchInfo
  { watchInfoCreatedAt = Nothing
  , watchInfoIgnored = Nothing
  , watchInfoReason = Nothing
  , watchInfoRepositoryUrl = Nothing
  , watchInfoSubscribed = Nothing
  , watchInfoUrl = Nothing
  }

-- ** WikiCommit
-- | WikiCommit
-- WikiCommit page commit/revision
data WikiCommit = WikiCommit
  { wikiCommitAuthor :: !(Maybe CommitUser) -- ^ "author"
  , wikiCommitCommiter :: !(Maybe CommitUser) -- ^ "commiter"
  , wikiCommitMessage :: !(Maybe Text) -- ^ "message"
  , wikiCommitSha :: !(Maybe Text) -- ^ "sha"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WikiCommit
instance A.FromJSON WikiCommit where
  parseJSON = A.withObject "WikiCommit" $ \o ->
    WikiCommit
      <$> (o .:? "author")
      <*> (o .:? "commiter")
      <*> (o .:? "message")
      <*> (o .:? "sha")

-- | ToJSON WikiCommit
instance A.ToJSON WikiCommit where
  toJSON WikiCommit {..} =
   _omitNulls
      [ "author" .= wikiCommitAuthor
      , "commiter" .= wikiCommitCommiter
      , "message" .= wikiCommitMessage
      , "sha" .= wikiCommitSha
      ]


-- | Construct a value of type 'WikiCommit' (by applying it's required fields, if any)
mkWikiCommit
  :: WikiCommit
mkWikiCommit =
  WikiCommit
  { wikiCommitAuthor = Nothing
  , wikiCommitCommiter = Nothing
  , wikiCommitMessage = Nothing
  , wikiCommitSha = Nothing
  }

-- ** WikiCommitList
-- | WikiCommitList
-- WikiCommitList commit/revision list
data WikiCommitList = WikiCommitList
  { wikiCommitListCommits :: !(Maybe [WikiCommit]) -- ^ "commits"
  , wikiCommitListCount :: !(Maybe Integer) -- ^ "count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WikiCommitList
instance A.FromJSON WikiCommitList where
  parseJSON = A.withObject "WikiCommitList" $ \o ->
    WikiCommitList
      <$> (o .:? "commits")
      <*> (o .:? "count")

-- | ToJSON WikiCommitList
instance A.ToJSON WikiCommitList where
  toJSON WikiCommitList {..} =
   _omitNulls
      [ "commits" .= wikiCommitListCommits
      , "count" .= wikiCommitListCount
      ]


-- | Construct a value of type 'WikiCommitList' (by applying it's required fields, if any)
mkWikiCommitList
  :: WikiCommitList
mkWikiCommitList =
  WikiCommitList
  { wikiCommitListCommits = Nothing
  , wikiCommitListCount = Nothing
  }

-- ** WikiPage
-- | WikiPage
-- WikiPage a wiki page
data WikiPage = WikiPage
  { wikiPageCommitCount :: !(Maybe Integer) -- ^ "commit_count"
  , wikiPageContentBase64 :: !(Maybe Text) -- ^ "content_base64" - Page content, base64 encoded
  , wikiPageFooter :: !(Maybe Text) -- ^ "footer"
  , wikiPageHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , wikiPageLastCommit :: !(Maybe WikiCommit) -- ^ "last_commit"
  , wikiPageSidebar :: !(Maybe Text) -- ^ "sidebar"
  , wikiPageSubUrl :: !(Maybe Text) -- ^ "sub_url"
  , wikiPageTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WikiPage
instance A.FromJSON WikiPage where
  parseJSON = A.withObject "WikiPage" $ \o ->
    WikiPage
      <$> (o .:? "commit_count")
      <*> (o .:? "content_base64")
      <*> (o .:? "footer")
      <*> (o .:? "html_url")
      <*> (o .:? "last_commit")
      <*> (o .:? "sidebar")
      <*> (o .:? "sub_url")
      <*> (o .:? "title")

-- | ToJSON WikiPage
instance A.ToJSON WikiPage where
  toJSON WikiPage {..} =
   _omitNulls
      [ "commit_count" .= wikiPageCommitCount
      , "content_base64" .= wikiPageContentBase64
      , "footer" .= wikiPageFooter
      , "html_url" .= wikiPageHtmlUrl
      , "last_commit" .= wikiPageLastCommit
      , "sidebar" .= wikiPageSidebar
      , "sub_url" .= wikiPageSubUrl
      , "title" .= wikiPageTitle
      ]


-- | Construct a value of type 'WikiPage' (by applying it's required fields, if any)
mkWikiPage
  :: WikiPage
mkWikiPage =
  WikiPage
  { wikiPageCommitCount = Nothing
  , wikiPageContentBase64 = Nothing
  , wikiPageFooter = Nothing
  , wikiPageHtmlUrl = Nothing
  , wikiPageLastCommit = Nothing
  , wikiPageSidebar = Nothing
  , wikiPageSubUrl = Nothing
  , wikiPageTitle = Nothing
  }

-- ** WikiPageMetaData
-- | WikiPageMetaData
-- WikiPageMetaData wiki page meta information
data WikiPageMetaData = WikiPageMetaData
  { wikiPageMetaDataHtmlUrl :: !(Maybe Text) -- ^ "html_url"
  , wikiPageMetaDataLastCommit :: !(Maybe WikiCommit) -- ^ "last_commit"
  , wikiPageMetaDataSubUrl :: !(Maybe Text) -- ^ "sub_url"
  , wikiPageMetaDataTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WikiPageMetaData
instance A.FromJSON WikiPageMetaData where
  parseJSON = A.withObject "WikiPageMetaData" $ \o ->
    WikiPageMetaData
      <$> (o .:? "html_url")
      <*> (o .:? "last_commit")
      <*> (o .:? "sub_url")
      <*> (o .:? "title")

-- | ToJSON WikiPageMetaData
instance A.ToJSON WikiPageMetaData where
  toJSON WikiPageMetaData {..} =
   _omitNulls
      [ "html_url" .= wikiPageMetaDataHtmlUrl
      , "last_commit" .= wikiPageMetaDataLastCommit
      , "sub_url" .= wikiPageMetaDataSubUrl
      , "title" .= wikiPageMetaDataTitle
      ]


-- | Construct a value of type 'WikiPageMetaData' (by applying it's required fields, if any)
mkWikiPageMetaData
  :: WikiPageMetaData
mkWikiPageMetaData =
  WikiPageMetaData
  { wikiPageMetaDataHtmlUrl = Nothing
  , wikiPageMetaDataLastCommit = Nothing
  , wikiPageMetaDataSubUrl = Nothing
  , wikiPageMetaDataTitle = Nothing
  }


-- * Enums


-- ** E'DiffType

-- | Enum of 'Text'
data E'DiffType
  = E'DiffType'Diff -- ^ @"diff"@
  | E'DiffType'Patch -- ^ @"patch"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DiffType where toJSON = A.toJSON . fromE'DiffType
instance A.FromJSON E'DiffType where parseJSON o = P.either P.fail (pure . P.id) . toE'DiffType =<< A.parseJSON o
instance WH.ToHttpApiData E'DiffType where toQueryParam = WH.toQueryParam . fromE'DiffType
instance WH.FromHttpApiData E'DiffType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DiffType
instance MimeRender MimeMultipartFormData E'DiffType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DiffType' enum
fromE'DiffType :: E'DiffType -> Text
fromE'DiffType = \case
  E'DiffType'Diff -> "diff"
  E'DiffType'Patch -> "patch"

-- | parse 'E'DiffType' enum
toE'DiffType :: Text -> P.Either String E'DiffType
toE'DiffType = \case
  "diff" -> P.Right E'DiffType'Diff
  "patch" -> P.Right E'DiffType'Patch
  s -> P.Left $ "toE'DiffType: enum parse failure: " P.++ P.show s


-- ** E'Do

-- | Enum of 'Text'
data E'Do
  = E'Do'Merge -- ^ @"merge"@
  | E'Do'Rebase -- ^ @"rebase"@
  | E'Do'Rebase_merge -- ^ @"rebase-merge"@
  | E'Do'Squash -- ^ @"squash"@
  | E'Do'Manually_merged -- ^ @"manually-merged"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Do where toJSON = A.toJSON . fromE'Do
instance A.FromJSON E'Do where parseJSON o = P.either P.fail (pure . P.id) . toE'Do =<< A.parseJSON o
instance WH.ToHttpApiData E'Do where toQueryParam = WH.toQueryParam . fromE'Do
instance WH.FromHttpApiData E'Do where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Do
instance MimeRender MimeMultipartFormData E'Do where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Do' enum
fromE'Do :: E'Do -> Text
fromE'Do = \case
  E'Do'Merge -> "merge"
  E'Do'Rebase -> "rebase"
  E'Do'Rebase_merge -> "rebase-merge"
  E'Do'Squash -> "squash"
  E'Do'Manually_merged -> "manually-merged"

-- | parse 'E'Do' enum
toE'Do :: Text -> P.Either String E'Do
toE'Do = \case
  "merge" -> P.Right E'Do'Merge
  "rebase" -> P.Right E'Do'Rebase
  "rebase-merge" -> P.Right E'Do'Rebase_merge
  "squash" -> P.Right E'Do'Squash
  "manually-merged" -> P.Right E'Do'Manually_merged
  s -> P.Left $ "toE'Do: enum parse failure: " P.++ P.show s


-- ** E'Operation

-- | Enum of 'Text' .
-- indicates what to do with the file
data E'Operation
  = E'Operation'Create -- ^ @"create"@
  | E'Operation'Update -- ^ @"update"@
  | E'Operation'Delete -- ^ @"delete"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Operation where toJSON = A.toJSON . fromE'Operation
instance A.FromJSON E'Operation where parseJSON o = P.either P.fail (pure . P.id) . toE'Operation =<< A.parseJSON o
instance WH.ToHttpApiData E'Operation where toQueryParam = WH.toQueryParam . fromE'Operation
instance WH.FromHttpApiData E'Operation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Operation
instance MimeRender MimeMultipartFormData E'Operation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Operation' enum
fromE'Operation :: E'Operation -> Text
fromE'Operation = \case
  E'Operation'Create -> "create"
  E'Operation'Update -> "update"
  E'Operation'Delete -> "delete"

-- | parse 'E'Operation' enum
toE'Operation :: Text -> P.Either String E'Operation
toE'Operation = \case
  "create" -> P.Right E'Operation'Create
  "update" -> P.Right E'Operation'Update
  "delete" -> P.Right E'Operation'Delete
  s -> P.Left $ "toE'Operation: enum parse failure: " P.++ P.show s


-- ** E'Permission

-- | Enum of 'Text'
data E'Permission
  = E'Permission'Read -- ^ @"read"@
  | E'Permission'Write -- ^ @"write"@
  | E'Permission'Admin -- ^ @"admin"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Permission where toJSON = A.toJSON . fromE'Permission
instance A.FromJSON E'Permission where parseJSON o = P.either P.fail (pure . P.id) . toE'Permission =<< A.parseJSON o
instance WH.ToHttpApiData E'Permission where toQueryParam = WH.toQueryParam . fromE'Permission
instance WH.FromHttpApiData E'Permission where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Permission
instance MimeRender MimeMultipartFormData E'Permission where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Permission' enum
fromE'Permission :: E'Permission -> Text
fromE'Permission = \case
  E'Permission'Read -> "read"
  E'Permission'Write -> "write"
  E'Permission'Admin -> "admin"

-- | parse 'E'Permission' enum
toE'Permission :: Text -> P.Either String E'Permission
toE'Permission = \case
  "read" -> P.Right E'Permission'Read
  "write" -> P.Right E'Permission'Write
  "admin" -> P.Right E'Permission'Admin
  s -> P.Left $ "toE'Permission: enum parse failure: " P.++ P.show s


-- ** E'Permission2

-- | Enum of 'Text'
data E'Permission2
  = E'Permission2'None -- ^ @"none"@
  | E'Permission2'Read -- ^ @"read"@
  | E'Permission2'Write -- ^ @"write"@
  | E'Permission2'Admin -- ^ @"admin"@
  | E'Permission2'Owner -- ^ @"owner"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Permission2 where toJSON = A.toJSON . fromE'Permission2
instance A.FromJSON E'Permission2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Permission2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Permission2 where toQueryParam = WH.toQueryParam . fromE'Permission2
instance WH.FromHttpApiData E'Permission2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Permission2
instance MimeRender MimeMultipartFormData E'Permission2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Permission2' enum
fromE'Permission2 :: E'Permission2 -> Text
fromE'Permission2 = \case
  E'Permission2'None -> "none"
  E'Permission2'Read -> "read"
  E'Permission2'Write -> "write"
  E'Permission2'Admin -> "admin"
  E'Permission2'Owner -> "owner"

-- | parse 'E'Permission2' enum
toE'Permission2 :: Text -> P.Either String E'Permission2
toE'Permission2 = \case
  "none" -> P.Right E'Permission2'None
  "read" -> P.Right E'Permission2'Read
  "write" -> P.Right E'Permission2'Write
  "admin" -> P.Right E'Permission2'Admin
  "owner" -> P.Right E'Permission2'Owner
  s -> P.Left $ "toE'Permission2: enum parse failure: " P.++ P.show s


-- ** E'Service

-- | Enum of 'Text'
data E'Service
  = E'Service'Git -- ^ @"git"@
  | E'Service'Github -- ^ @"github"@
  | E'Service'Gitea -- ^ @"gitea"@
  | E'Service'Gitlab -- ^ @"gitlab"@
  | E'Service'Gogs -- ^ @"gogs"@
  | E'Service'Onedev -- ^ @"onedev"@
  | E'Service'Gitbucket -- ^ @"gitbucket"@
  | E'Service'Codebase -- ^ @"codebase"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Service where toJSON = A.toJSON . fromE'Service
instance A.FromJSON E'Service where parseJSON o = P.either P.fail (pure . P.id) . toE'Service =<< A.parseJSON o
instance WH.ToHttpApiData E'Service where toQueryParam = WH.toQueryParam . fromE'Service
instance WH.FromHttpApiData E'Service where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Service
instance MimeRender MimeMultipartFormData E'Service where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Service' enum
fromE'Service :: E'Service -> Text
fromE'Service = \case
  E'Service'Git -> "git"
  E'Service'Github -> "github"
  E'Service'Gitea -> "gitea"
  E'Service'Gitlab -> "gitlab"
  E'Service'Gogs -> "gogs"
  E'Service'Onedev -> "onedev"
  E'Service'Gitbucket -> "gitbucket"
  E'Service'Codebase -> "codebase"

-- | parse 'E'Service' enum
toE'Service :: Text -> P.Either String E'Service
toE'Service = \case
  "git" -> P.Right E'Service'Git
  "github" -> P.Right E'Service'Github
  "gitea" -> P.Right E'Service'Gitea
  "gitlab" -> P.Right E'Service'Gitlab
  "gogs" -> P.Right E'Service'Gogs
  "onedev" -> P.Right E'Service'Onedev
  "gitbucket" -> P.Right E'Service'Gitbucket
  "codebase" -> P.Right E'Service'Codebase
  s -> P.Left $ "toE'Service: enum parse failure: " P.++ P.show s


-- ** E'Sort

-- | Enum of 'Text'
data E'Sort
  = E'Sort'Oldest -- ^ @"oldest"@
  | E'Sort'Recentupdate -- ^ @"recentupdate"@
  | E'Sort'Leastupdate -- ^ @"leastupdate"@
  | E'Sort'Leastindex -- ^ @"leastindex"@
  | E'Sort'Highestindex -- ^ @"highestindex"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sort where toJSON = A.toJSON . fromE'Sort
instance A.FromJSON E'Sort where parseJSON o = P.either P.fail (pure . P.id) . toE'Sort =<< A.parseJSON o
instance WH.ToHttpApiData E'Sort where toQueryParam = WH.toQueryParam . fromE'Sort
instance WH.FromHttpApiData E'Sort where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sort
instance MimeRender MimeMultipartFormData E'Sort where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sort' enum
fromE'Sort :: E'Sort -> Text
fromE'Sort = \case
  E'Sort'Oldest -> "oldest"
  E'Sort'Recentupdate -> "recentupdate"
  E'Sort'Leastupdate -> "leastupdate"
  E'Sort'Leastindex -> "leastindex"
  E'Sort'Highestindex -> "highestindex"

-- | parse 'E'Sort' enum
toE'Sort :: Text -> P.Either String E'Sort
toE'Sort = \case
  "oldest" -> P.Right E'Sort'Oldest
  "recentupdate" -> P.Right E'Sort'Recentupdate
  "leastupdate" -> P.Right E'Sort'Leastupdate
  "leastindex" -> P.Right E'Sort'Leastindex
  "highestindex" -> P.Right E'Sort'Highestindex
  s -> P.Left $ "toE'Sort: enum parse failure: " P.++ P.show s


-- ** E'Sort2

-- | Enum of 'Text'
data E'Sort2
  = E'Sort2'Oldest -- ^ @"oldest"@
  | E'Sort2'Recentupdate -- ^ @"recentupdate"@
  | E'Sort2'Leastupdate -- ^ @"leastupdate"@
  | E'Sort2'Mostcomment -- ^ @"mostcomment"@
  | E'Sort2'Leastcomment -- ^ @"leastcomment"@
  | E'Sort2'Priority -- ^ @"priority"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sort2 where toJSON = A.toJSON . fromE'Sort2
instance A.FromJSON E'Sort2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Sort2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Sort2 where toQueryParam = WH.toQueryParam . fromE'Sort2
instance WH.FromHttpApiData E'Sort2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sort2
instance MimeRender MimeMultipartFormData E'Sort2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sort2' enum
fromE'Sort2 :: E'Sort2 -> Text
fromE'Sort2 = \case
  E'Sort2'Oldest -> "oldest"
  E'Sort2'Recentupdate -> "recentupdate"
  E'Sort2'Leastupdate -> "leastupdate"
  E'Sort2'Mostcomment -> "mostcomment"
  E'Sort2'Leastcomment -> "leastcomment"
  E'Sort2'Priority -> "priority"

-- | parse 'E'Sort2' enum
toE'Sort2 :: Text -> P.Either String E'Sort2
toE'Sort2 = \case
  "oldest" -> P.Right E'Sort2'Oldest
  "recentupdate" -> P.Right E'Sort2'Recentupdate
  "leastupdate" -> P.Right E'Sort2'Leastupdate
  "mostcomment" -> P.Right E'Sort2'Mostcomment
  "leastcomment" -> P.Right E'Sort2'Leastcomment
  "priority" -> P.Right E'Sort2'Priority
  s -> P.Left $ "toE'Sort2: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Open -- ^ @"open"@
  | E'State'Closed -- ^ @"closed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Open -> "open"
  E'State'Closed -> "closed"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "open" -> P.Right E'State'Open
  "closed" -> P.Right E'State'Closed
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'State2

-- | Enum of 'Text'
data E'State2
  = E'State2'Pending -- ^ @"pending"@
  | E'State2'Success -- ^ @"success"@
  | E'State2'Error -- ^ @"error"@
  | E'State2'Failure -- ^ @"failure"@
  | E'State2'Warning -- ^ @"warning"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State2 where toJSON = A.toJSON . fromE'State2
instance A.FromJSON E'State2 where parseJSON o = P.either P.fail (pure . P.id) . toE'State2 =<< A.parseJSON o
instance WH.ToHttpApiData E'State2 where toQueryParam = WH.toQueryParam . fromE'State2
instance WH.FromHttpApiData E'State2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State2
instance MimeRender MimeMultipartFormData E'State2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State2' enum
fromE'State2 :: E'State2 -> Text
fromE'State2 = \case
  E'State2'Pending -> "pending"
  E'State2'Success -> "success"
  E'State2'Error -> "error"
  E'State2'Failure -> "failure"
  E'State2'Warning -> "warning"

-- | parse 'E'State2' enum
toE'State2 :: Text -> P.Either String E'State2
toE'State2 = \case
  "pending" -> P.Right E'State2'Pending
  "success" -> P.Right E'State2'Success
  "error" -> P.Right E'State2'Error
  "failure" -> P.Right E'State2'Failure
  "warning" -> P.Right E'State2'Warning
  s -> P.Left $ "toE'State2: enum parse failure: " P.++ P.show s


-- ** E'State3

-- | Enum of 'Text'
data E'State3
  = E'State3'Closed -- ^ @"closed"@
  | E'State3'Open -- ^ @"open"@
  | E'State3'All -- ^ @"all"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State3 where toJSON = A.toJSON . fromE'State3
instance A.FromJSON E'State3 where parseJSON o = P.either P.fail (pure . P.id) . toE'State3 =<< A.parseJSON o
instance WH.ToHttpApiData E'State3 where toQueryParam = WH.toQueryParam . fromE'State3
instance WH.FromHttpApiData E'State3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State3
instance MimeRender MimeMultipartFormData E'State3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State3' enum
fromE'State3 :: E'State3 -> Text
fromE'State3 = \case
  E'State3'Closed -> "closed"
  E'State3'Open -> "open"
  E'State3'All -> "all"

-- | parse 'E'State3' enum
toE'State3 :: Text -> P.Either String E'State3
toE'State3 = \case
  "closed" -> P.Right E'State3'Closed
  "open" -> P.Right E'State3'Open
  "all" -> P.Right E'State3'All
  s -> P.Left $ "toE'State3: enum parse failure: " P.++ P.show s


-- ** E'Style

-- | Enum of 'Text'
data E'Style
  = E'Style'Merge -- ^ @"merge"@
  | E'Style'Rebase -- ^ @"rebase"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Style where toJSON = A.toJSON . fromE'Style
instance A.FromJSON E'Style where parseJSON o = P.either P.fail (pure . P.id) . toE'Style =<< A.parseJSON o
instance WH.ToHttpApiData E'Style where toQueryParam = WH.toQueryParam . fromE'Style
instance WH.FromHttpApiData E'Style where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Style
instance MimeRender MimeMultipartFormData E'Style where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Style' enum
fromE'Style :: E'Style -> Text
fromE'Style = \case
  E'Style'Merge -> "merge"
  E'Style'Rebase -> "rebase"

-- | parse 'E'Style' enum
toE'Style :: Text -> P.Either String E'Style
toE'Style = \case
  "merge" -> P.Right E'Style'Merge
  "rebase" -> P.Right E'Style'Rebase
  s -> P.Left $ "toE'Style: enum parse failure: " P.++ P.show s


-- ** E'SubjectType

-- | Enum of 'Text'
data E'SubjectType
  = E'SubjectType'Issue -- ^ @"issue"@
  | E'SubjectType'Pull -- ^ @"pull"@
  | E'SubjectType'Commit -- ^ @"commit"@
  | E'SubjectType'Repository -- ^ @"repository"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SubjectType where toJSON = A.toJSON . fromE'SubjectType
instance A.FromJSON E'SubjectType where parseJSON o = P.either P.fail (pure . P.id) . toE'SubjectType =<< A.parseJSON o
instance WH.ToHttpApiData E'SubjectType where toQueryParam = WH.toQueryParam . fromE'SubjectType
instance WH.FromHttpApiData E'SubjectType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SubjectType
instance MimeRender MimeMultipartFormData E'SubjectType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SubjectType' enum
fromE'SubjectType :: E'SubjectType -> Text
fromE'SubjectType = \case
  E'SubjectType'Issue -> "issue"
  E'SubjectType'Pull -> "pull"
  E'SubjectType'Commit -> "commit"
  E'SubjectType'Repository -> "repository"

-- | parse 'E'SubjectType' enum
toE'SubjectType :: Text -> P.Either String E'SubjectType
toE'SubjectType = \case
  "issue" -> P.Right E'SubjectType'Issue
  "pull" -> P.Right E'SubjectType'Pull
  "commit" -> P.Right E'SubjectType'Commit
  "repository" -> P.Right E'SubjectType'Repository
  s -> P.Left $ "toE'SubjectType: enum parse failure: " P.++ P.show s


-- ** E'TrustModel

-- | Enum of 'Text' .
-- TrustModel of the repository
data E'TrustModel
  = E'TrustModel'Default -- ^ @"default"@
  | E'TrustModel'Collaborator -- ^ @"collaborator"@
  | E'TrustModel'Committer -- ^ @"committer"@
  | E'TrustModel'Collaboratorcommitter -- ^ @"collaboratorcommitter"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TrustModel where toJSON = A.toJSON . fromE'TrustModel
instance A.FromJSON E'TrustModel where parseJSON o = P.either P.fail (pure . P.id) . toE'TrustModel =<< A.parseJSON o
instance WH.ToHttpApiData E'TrustModel where toQueryParam = WH.toQueryParam . fromE'TrustModel
instance WH.FromHttpApiData E'TrustModel where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TrustModel
instance MimeRender MimeMultipartFormData E'TrustModel where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TrustModel' enum
fromE'TrustModel :: E'TrustModel -> Text
fromE'TrustModel = \case
  E'TrustModel'Default -> "default"
  E'TrustModel'Collaborator -> "collaborator"
  E'TrustModel'Committer -> "committer"
  E'TrustModel'Collaboratorcommitter -> "collaboratorcommitter"

-- | parse 'E'TrustModel' enum
toE'TrustModel :: Text -> P.Either String E'TrustModel
toE'TrustModel = \case
  "default" -> P.Right E'TrustModel'Default
  "collaborator" -> P.Right E'TrustModel'Collaborator
  "committer" -> P.Right E'TrustModel'Committer
  "collaboratorcommitter" -> P.Right E'TrustModel'Collaboratorcommitter
  s -> P.Left $ "toE'TrustModel: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Dingtalk -- ^ @"dingtalk"@
  | E'Type'Discord -- ^ @"discord"@
  | E'Type'Gitea -- ^ @"gitea"@
  | E'Type'Gogs -- ^ @"gogs"@
  | E'Type'Msteams -- ^ @"msteams"@
  | E'Type'Slack -- ^ @"slack"@
  | E'Type'Telegram -- ^ @"telegram"@
  | E'Type'Feishu -- ^ @"feishu"@
  | E'Type'Wechatwork -- ^ @"wechatwork"@
  | E'Type'Packagist -- ^ @"packagist"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Dingtalk -> "dingtalk"
  E'Type'Discord -> "discord"
  E'Type'Gitea -> "gitea"
  E'Type'Gogs -> "gogs"
  E'Type'Msteams -> "msteams"
  E'Type'Slack -> "slack"
  E'Type'Telegram -> "telegram"
  E'Type'Feishu -> "feishu"
  E'Type'Wechatwork -> "wechatwork"
  E'Type'Packagist -> "packagist"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "dingtalk" -> P.Right E'Type'Dingtalk
  "discord" -> P.Right E'Type'Discord
  "gitea" -> P.Right E'Type'Gitea
  "gogs" -> P.Right E'Type'Gogs
  "msteams" -> P.Right E'Type'Msteams
  "slack" -> P.Right E'Type'Slack
  "telegram" -> P.Right E'Type'Telegram
  "feishu" -> P.Right E'Type'Feishu
  "wechatwork" -> P.Right E'Type'Wechatwork
  "packagist" -> P.Right E'Type'Packagist
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text'
data E'Type2
  = E'Type2'Alpine -- ^ @"alpine"@
  | E'Type2'Cargo -- ^ @"cargo"@
  | E'Type2'Chef -- ^ @"chef"@
  | E'Type2'Composer -- ^ @"composer"@
  | E'Type2'Conan -- ^ @"conan"@
  | E'Type2'Conda -- ^ @"conda"@
  | E'Type2'Container -- ^ @"container"@
  | E'Type2'Cran -- ^ @"cran"@
  | E'Type2'Debian -- ^ @"debian"@
  | E'Type2'Generic -- ^ @"generic"@
  | E'Type2'Go -- ^ @"go"@
  | E'Type2'Helm -- ^ @"helm"@
  | E'Type2'Maven -- ^ @"maven"@
  | E'Type2'Npm -- ^ @"npm"@
  | E'Type2'Nuget -- ^ @"nuget"@
  | E'Type2'Pub -- ^ @"pub"@
  | E'Type2'Pypi -- ^ @"pypi"@
  | E'Type2'Rpm -- ^ @"rpm"@
  | E'Type2'Rubygems -- ^ @"rubygems"@
  | E'Type2'Swift -- ^ @"swift"@
  | E'Type2'Vagrant -- ^ @"vagrant"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Alpine -> "alpine"
  E'Type2'Cargo -> "cargo"
  E'Type2'Chef -> "chef"
  E'Type2'Composer -> "composer"
  E'Type2'Conan -> "conan"
  E'Type2'Conda -> "conda"
  E'Type2'Container -> "container"
  E'Type2'Cran -> "cran"
  E'Type2'Debian -> "debian"
  E'Type2'Generic -> "generic"
  E'Type2'Go -> "go"
  E'Type2'Helm -> "helm"
  E'Type2'Maven -> "maven"
  E'Type2'Npm -> "npm"
  E'Type2'Nuget -> "nuget"
  E'Type2'Pub -> "pub"
  E'Type2'Pypi -> "pypi"
  E'Type2'Rpm -> "rpm"
  E'Type2'Rubygems -> "rubygems"
  E'Type2'Swift -> "swift"
  E'Type2'Vagrant -> "vagrant"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "alpine" -> P.Right E'Type2'Alpine
  "cargo" -> P.Right E'Type2'Cargo
  "chef" -> P.Right E'Type2'Chef
  "composer" -> P.Right E'Type2'Composer
  "conan" -> P.Right E'Type2'Conan
  "conda" -> P.Right E'Type2'Conda
  "container" -> P.Right E'Type2'Container
  "cran" -> P.Right E'Type2'Cran
  "debian" -> P.Right E'Type2'Debian
  "generic" -> P.Right E'Type2'Generic
  "go" -> P.Right E'Type2'Go
  "helm" -> P.Right E'Type2'Helm
  "maven" -> P.Right E'Type2'Maven
  "npm" -> P.Right E'Type2'Npm
  "nuget" -> P.Right E'Type2'Nuget
  "pub" -> P.Right E'Type2'Pub
  "pypi" -> P.Right E'Type2'Pypi
  "rpm" -> P.Right E'Type2'Rpm
  "rubygems" -> P.Right E'Type2'Rubygems
  "swift" -> P.Right E'Type2'Swift
  "vagrant" -> P.Right E'Type2'Vagrant
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'Issues -- ^ @"issues"@
  | E'Type3'Pulls -- ^ @"pulls"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Issues -> "issues"
  E'Type3'Pulls -> "pulls"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "issues" -> P.Right E'Type3'Issues
  "pulls" -> P.Right E'Type3'Pulls
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Visibility

-- | Enum of 'Text' .
-- possible values are `public` (default), `limited` or `private`
data E'Visibility
  = E'Visibility'Public -- ^ @"public"@
  | E'Visibility'Limited -- ^ @"limited"@
  | E'Visibility'Private -- ^ @"private"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Visibility where toJSON = A.toJSON . fromE'Visibility
instance A.FromJSON E'Visibility where parseJSON o = P.either P.fail (pure . P.id) . toE'Visibility =<< A.parseJSON o
instance WH.ToHttpApiData E'Visibility where toQueryParam = WH.toQueryParam . fromE'Visibility
instance WH.FromHttpApiData E'Visibility where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Visibility
instance MimeRender MimeMultipartFormData E'Visibility where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Visibility' enum
fromE'Visibility :: E'Visibility -> Text
fromE'Visibility = \case
  E'Visibility'Public -> "public"
  E'Visibility'Limited -> "limited"
  E'Visibility'Private -> "private"

-- | parse 'E'Visibility' enum
toE'Visibility :: Text -> P.Either String E'Visibility
toE'Visibility = \case
  "public" -> P.Right E'Visibility'Public
  "limited" -> P.Right E'Visibility'Limited
  "private" -> P.Right E'Visibility'Private
  s -> P.Left $ "toE'Visibility: enum parse failure: " P.++ P.show s


-- ** E'Whitespace

-- | Enum of 'Text'
data E'Whitespace
  = E'Whitespace'Ignore_all -- ^ @"ignore-all"@
  | E'Whitespace'Ignore_change -- ^ @"ignore-change"@
  | E'Whitespace'Ignore_eol -- ^ @"ignore-eol"@
  | E'Whitespace'Show_all -- ^ @"show-all"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Whitespace where toJSON = A.toJSON . fromE'Whitespace
instance A.FromJSON E'Whitespace where parseJSON o = P.either P.fail (pure . P.id) . toE'Whitespace =<< A.parseJSON o
instance WH.ToHttpApiData E'Whitespace where toQueryParam = WH.toQueryParam . fromE'Whitespace
instance WH.FromHttpApiData E'Whitespace where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Whitespace
instance MimeRender MimeMultipartFormData E'Whitespace where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Whitespace' enum
fromE'Whitespace :: E'Whitespace -> Text
fromE'Whitespace = \case
  E'Whitespace'Ignore_all -> "ignore-all"
  E'Whitespace'Ignore_change -> "ignore-change"
  E'Whitespace'Ignore_eol -> "ignore-eol"
  E'Whitespace'Show_all -> "show-all"

-- | parse 'E'Whitespace' enum
toE'Whitespace :: Text -> P.Either String E'Whitespace
toE'Whitespace = \case
  "ignore-all" -> P.Right E'Whitespace'Ignore_all
  "ignore-change" -> P.Right E'Whitespace'Ignore_change
  "ignore-eol" -> P.Right E'Whitespace'Ignore_eol
  "show-all" -> P.Right E'Whitespace'Show_all
  s -> P.Left $ "toE'Whitespace: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyAccessToken
data AuthApiKeyAccessToken =
  AuthApiKeyAccessToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAccessToken where
  applyAuthMethod _ a@(AuthApiKeyAccessToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("access_token", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyAuthorizationHeaderToken
data AuthApiKeyAuthorizationHeaderToken =
  AuthApiKeyAuthorizationHeaderToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAuthorizationHeaderToken where
  applyAuthMethod _ a@(AuthApiKeyAuthorizationHeaderToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

-- ** AuthApiKeySudoHeader
data AuthApiKeySudoHeader =
  AuthApiKeySudoHeader Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySudoHeader where
  applyAuthMethod _ a@(AuthApiKeySudoHeader secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Sudo", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeySudoParam
data AuthApiKeySudoParam =
  AuthApiKeySudoParam Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeySudoParam where
  applyAuthMethod _ a@(AuthApiKeySudoParam secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("sudo", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyTOTPHeader
data AuthApiKeyTOTPHeader =
  AuthApiKeyTOTPHeader Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyTOTPHeader where
  applyAuthMethod _ a@(AuthApiKeyTOTPHeader secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-GITEA-OTP", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyToken
data AuthApiKeyToken =
  AuthApiKeyToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyToken where
  applyAuthMethod _ a@(AuthApiKeyToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("token", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


